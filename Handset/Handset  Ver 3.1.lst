CCS PCH C Compiler, Version 5.107, 60694               24-Jul-23 09:17

               Filename:   C:\Users\jclaude\Documents\GitHub\Nexalin-Halo\Handset\Handset  Ver 3.1.lst

               ROM used:   30782 bytes (23%)
                           Largest free fragment is 65526
               RAM used:   1367 (17%) at main() level
                           2140 (26%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   74AC
*
00008:  MOVFF  00,04
0000C:  MOVFF  01,05
00010:  MOVFF  02,06
00014:  CLRF   07
00016:  MOVFF  03,08
0001A:  MOVLB  0
0001C:  MOVFFL 3FF5,09
00022:  MOVFFL 3FF6,0A
00028:  MOVFFL 3FF7,0B
0002E:  MOVFFL 3FF8,0C
00034:  MOVLB  39
00036:  BTFSS  x91.0
00038:  GOTO   0042
0003C:  BTFSC  xA1.0
0003E:  GOTO   050C
00042:  BTFSS  x93.3
00044:  GOTO   004E
00048:  BTFSC  xA3.3
0004A:  GOTO   00F6
0004E:  BTFSS  x94.0
00050:  GOTO   005A
00054:  BTFSC  xA4.0
00056:  GOTO   04B6
0005A:  MOVFFL 09,3FF5
00060:  MOVFFL 0A,3FF6
00066:  MOVFFL 0B,3FF7
0006C:  MOVFFL 0C,3FF8
00072:  MOVFF  04,00
00076:  MOVFF  05,01
0007A:  MOVFF  06,02
0007E:  BSF    07.7
00080:  MOVFF  08,03
00084:  RETFIE 1
.................... /////////////////////////////////////////////////////////////////////
.................... //  Example program to use the custom RN487x driver 
.................... //  Mark S. Ver 2.0 20230708
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... #include <18f47K42.h>
.................... //////////// Standard Header file for the PIC18F47K42 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F47K42
00086:  CLRF   3FF7
00088:  ADDLW  9A
0008A:  MOVWF  3FF6
0008C:  MOVLW  00
0008E:  ADDWFC 3FF7,F
00090:  MOVLW  00
00092:  MOVWF  3FF8
00094:  TBLRD*+
00096:  MOVF   3FF5,W
00098:  RETURN 0
0009A:  DATA 2F,00
0009C:  DATA 2D,2D
0009E:  DATA 2D,0D
000A0:  DATA 00,00
000A2:  DATA 24,24
000A4:  DATA 24,00
000A6:  DATA 47,53
000A8:  DATA 0D,00
000AA:  DATA 47,52
000AC:  DATA 0D,00
*
000D0:  MOVLB  8
000D2:  MOVF   x57,W
000D4:  MULWF  x59
000D6:  MOVFFL 3FF3,01
000DC:  MOVFFL 3FF4,00
000E2:  MULWF  x5A
000E4:  MOVF   3FF3,W
000E6:  ADDWF  00,F
000E8:  MOVF   x58,W
000EA:  MULWF  x59
000EC:  MOVF   3FF3,W
000EE:  ADDWFC 00,W
000F0:  MOVWF  02
000F2:  MOVLB  0
000F4:  RETURN 0
*
003C2:  DATA 24,24
003C4:  DATA 24,00
003C6:  DATA 53,42
003C8:  DATA 2C,30
003CA:  DATA 39,0D
003CC:  DATA 00,00
003CE:  DATA 0D,43
003D0:  DATA 48,41
003D2:  DATA 4E,47
003D4:  DATA 49,4E
003D6:  DATA 47,20
003D8:  DATA 42,41
003DA:  DATA 55,44
003DC:  DATA 0D,0A
003DE:  DATA 00,00
003E0:  DATA 53,53
003E2:  DATA 2C,43
003E4:  DATA 30,0D
003E6:  DATA 00,00
003E8:  DATA 53,52
003EA:  DATA 2C,31
003EC:  DATA 30,30
003EE:  DATA 30,0D
003F0:  DATA 00,00
003F2:  DATA 50,5A
003F4:  DATA 0D,00
003F6:  DATA 53,2D
003F8:  DATA 2C,42
003FA:  DATA 4C,45
003FC:  DATA 2D,43
003FE:  DATA 65,6E
00400:  DATA 74,72
00402:  DATA 61,6C
00404:  DATA 0D,00
00406:  DATA 47,53
00408:  DATA 0D,00
0040A:  DATA 44,69
0040C:  DATA 73,63
0040E:  DATA 6F,6E
00410:  DATA 6E,65
00412:  DATA 63,74
00414:  DATA 65,64
00416:  DATA 0D,0A
00418:  DATA 00,00
0041A:  DATA 4B,2C
0041C:  DATA 31,0D
0041E:  DATA 00,00
00420:  DATA 4C,43
00422:  DATA 0D,00
00424:  DATA 43,49
00426:  DATA 0D,00
00428:  DATA 43,48
0042A:  DATA 57,2C
0042C:  DATA 25,30
0042E:  DATA 34,58
00430:  DATA 2C,25
00432:  DATA 73,0D
00434:  DATA 00,00
00436:  DATA 43,48
00438:  DATA 52,2C
0043A:  DATA 25,30
0043C:  DATA 34,58
0043E:  DATA 0D,00
00440:  DATA 45,72
00442:  DATA 72,6F
00444:  DATA 72,20
00446:  DATA 2D,20
00448:  DATA 53,63
0044A:  DATA 61,6E
0044C:  DATA 0D,0A
0044E:  DATA 00,00
00450:  DATA 45,72
00452:  DATA 72,6F
00454:  DATA 72,20
00456:  DATA 43,6F
00458:  DATA 6E,6E
0045A:  DATA 65,63
0045C:  DATA 74,69
0045E:  DATA 6E,67
00460:  DATA 0D,0A
00462:  DATA 00,00
00464:  DATA 43,6F
00466:  DATA 6E,6E
00468:  DATA 65,63
0046A:  DATA 74,65
0046C:  DATA 64,0D
0046E:  DATA 0A,00
00470:  DATA 0A,0D
00472:  DATA 20,53
00474:  DATA 74,61
00476:  DATA 72,74
00478:  DATA 20,44
0047A:  DATA 69,73
0047C:  DATA 70,6C
0047E:  DATA 61,79
00480:  DATA 20,43
00482:  DATA 6F,6E
00484:  DATA 66,69
00486:  DATA 67,00
00488:  DATA 0A,0D
0048A:  DATA 20,45
0048C:  DATA 6E,64
0048E:  DATA 20,44
00490:  DATA 69,73
00492:  DATA 70,6C
00494:  DATA 61,79
00496:  DATA 20,43
00498:  DATA 6F,6E
0049A:  DATA 66,69
0049C:  DATA 67,00
0049E:  DATA 0A,0D
004A0:  DATA 20,43
004A2:  DATA 6C,65
004A4:  DATA 61,72
004A6:  DATA 00,00
004A8:  DATA 0A,0D
004AA:  DATA 20,4F
004AC:  DATA 46,46
004AE:  DATA 00,00
004B0:  DATA 0A,0D
004B2:  DATA 20,4F
004B4:  DATA 4E,00
*
004D0:  TBLRD*+
004D2:  MOVF   3FF5,F
004D4:  BZ    050A
004D6:  MOVFFL 3FF6,855
004DC:  MOVFFL 3FF7,856
004E2:  MOVFFL 3FF8,857
004E8:  MOVF   3FF5,W
004EA:  MOVLB  39
004EC:  BTFSS  xA6.3
004EE:  BRA    04EC
004F0:  MOVLB  3D
004F2:  MOVWF  xD2
004F4:  MOVFFL 855,3FF6
004FA:  MOVFFL 856,3FF7
00500:  MOVFFL 857,3FF8
00506:  MOVLB  0
00508:  BRA    04D0
0050A:  RETURN 0
*
0052C:  DATA 0A,0D
0052E:  DATA 20,53
00530:  DATA 6C,65
00532:  DATA 65,70
00534:  DATA 20,6E
00536:  DATA 6F,77
00538:  DATA 00,00
0053A:  DATA 0A,0D
0053C:  DATA 20,46
0053E:  DATA 75,6C
00540:  DATA 6C,00
00542:  DATA 0A,0D
00544:  DATA 20,25
00546:  DATA 75,2C
00548:  DATA 20,25
0054A:  DATA 6C,75
0054C:  DATA 20,2C
0054E:  DATA 20,25
00550:  DATA 6C,75
00552:  DATA 2C,20
00554:  DATA 25,6C
00556:  DATA 75,2C
00558:  DATA 20,25
0055A:  DATA 6C,75
0055C:  DATA 20,00
0055E:  DATA 24,73
00560:  DATA 6C,65
00562:  DATA 65,70
00564:  DATA 2F,23
00566:  DATA 0D,00
00568:  DATA 20,48
0056A:  DATA 61,6C
0056C:  DATA 6F,20
0056E:  DATA 48,61
00570:  DATA 6E,64
00572:  DATA 73,65
00574:  DATA 74,20
00576:  DATA 56,65
00578:  DATA 72,20
0057A:  DATA 33,0D
0057C:  DATA 0A,00
0057E:  DATA 0A,0D
00580:  DATA 20,43
00582:  DATA 68,61
00584:  DATA 72,67
00586:  DATA 65,72
00588:  DATA 20,4F
0058A:  DATA 6E,20
0058C:  DATA 0A,0D
0058E:  DATA 00,00
00590:  DATA 0A,0D
00592:  DATA 20,43
00594:  DATA 68,61
00596:  DATA 72,67
00598:  DATA 65,72
0059A:  DATA 20,4F
0059C:  DATA 66,66
0059E:  DATA 20,0A
005A0:  DATA 0D,00
005A2:  DATA 0A,0D
005A4:  DATA 20,6A
005A6:  DATA 3D,25
005A8:  DATA 75,20
005AA:  DATA 0A,0D
005AC:  DATA 00,00
005AE:  DATA 24,6F
005B0:  DATA 6E,2F
005B2:  DATA 23,0D
005B4:  DATA 00,00
005B6:  DATA 24,6F
005B8:  DATA 66,66
005BA:  DATA 2F,23
005BC:  DATA 0D,00
005BE:  DATA 52,65
005C0:  DATA 6D,6F
005C2:  DATA 74,65
005C4:  DATA 20,44
005C6:  DATA 61,74
005C8:  DATA 61,3D
005CA:  DATA 25,73
005CC:  DATA 0D,0A
005CE:  DATA 00,00
*
00906:  MOVLW  8E
00908:  MOVWF  00
0090A:  MOVFF  55B,01
0090E:  MOVFF  55A,02
00912:  CLRF   03
00914:  MOVF   01,F
00916:  BNZ   092A
00918:  MOVFF  02,01
0091C:  CLRF   02
0091E:  MOVLW  08
00920:  SUBWF  00,F
00922:  MOVF   01,F
00924:  BNZ   092A
00926:  CLRF   00
00928:  BRA    093A
0092A:  BCF    3FD8.0
0092C:  BTFSC  01.7
0092E:  BRA    0938
00930:  RLCF   02,F
00932:  RLCF   01,F
00934:  DECF   00,F
00936:  BRA    092A
00938:  BCF    01.7
0093A:  RETURN 0
0093C:  MOVLB  5
0093E:  MOVF   x5A,W
00940:  BTFSC  3FD8.2
00942:  BRA    0A2C
00944:  MOVWF  00
00946:  MOVF   x5E,W
00948:  BTFSC  3FD8.2
0094A:  BRA    0A2C
0094C:  ADDWF  00,F
0094E:  BNC   0958
00950:  MOVLW  81
00952:  ADDWF  00,F
00954:  BC    0A2C
00956:  BRA    0960
00958:  MOVLW  7F
0095A:  SUBWF  00,F
0095C:  BNC   0A2C
0095E:  BZ    0A2C
00960:  MOVFF  55B,562
00964:  MOVF   x5F,W
00966:  XORWF  x62,F
00968:  BSF    x5B.7
0096A:  BSF    x5F.7
0096C:  MOVF   x5D,W
0096E:  MULWF  x61
00970:  MOVFFL 3FF4,564
00976:  MOVF   x5C,W
00978:  MULWF  x60
0097A:  MOVFFL 3FF4,03
00980:  MOVFFL 3FF3,563
00986:  MULWF  x61
00988:  MOVF   3FF3,W
0098A:  ADDWF  x64,F
0098C:  MOVF   3FF4,W
0098E:  ADDWFC x63,F
00990:  MOVLW  00
00992:  ADDWFC 03,F
00994:  MOVF   x5D,W
00996:  MULWF  x60
00998:  MOVF   3FF3,W
0099A:  ADDWF  x64,F
0099C:  MOVF   3FF4,W
0099E:  ADDWFC x63,F
009A0:  MOVLW  00
009A2:  CLRF   02
009A4:  ADDWFC 03,F
009A6:  ADDWFC 02,F
009A8:  MOVF   x5B,W
009AA:  MULWF  x61
009AC:  MOVF   3FF3,W
009AE:  ADDWF  x63,F
009B0:  MOVF   3FF4,W
009B2:  ADDWFC 03,F
009B4:  MOVLW  00
009B6:  ADDWFC 02,F
009B8:  MOVF   x5B,W
009BA:  MULWF  x60
009BC:  MOVF   3FF3,W
009BE:  ADDWF  03,F
009C0:  MOVF   3FF4,W
009C2:  ADDWFC 02,F
009C4:  MOVLW  00
009C6:  CLRF   01
009C8:  ADDWFC 01,F
009CA:  MOVF   x5D,W
009CC:  MULWF  x5F
009CE:  MOVF   3FF3,W
009D0:  ADDWF  x63,F
009D2:  MOVF   3FF4,W
009D4:  ADDWFC 03,F
009D6:  MOVLW  00
009D8:  ADDWFC 02,F
009DA:  ADDWFC 01,F
009DC:  MOVF   x5C,W
009DE:  MULWF  x5F
009E0:  MOVF   3FF3,W
009E2:  ADDWF  03,F
009E4:  MOVF   3FF4,W
009E6:  ADDWFC 02,F
009E8:  MOVLW  00
009EA:  ADDWFC 01,F
009EC:  MOVF   x5B,W
009EE:  MULWF  x5F
009F0:  MOVF   3FF3,W
009F2:  ADDWF  02,F
009F4:  MOVF   3FF4,W
009F6:  ADDWFC 01,F
009F8:  INCF   00,F
009FA:  BTFSC  01.7
009FC:  BRA    0A08
009FE:  RLCF   x63,F
00A00:  RLCF   03,F
00A02:  RLCF   02,F
00A04:  RLCF   01,F
00A06:  DECF   00,F
00A08:  MOVLW  00
00A0A:  BTFSS  x63.7
00A0C:  BRA    0A22
00A0E:  INCF   03,F
00A10:  ADDWFC 02,F
00A12:  ADDWFC 01,F
00A14:  MOVF   01,W
00A16:  BNZ   0A22
00A18:  MOVF   02,W
00A1A:  BNZ   0A22
00A1C:  MOVF   03,W
00A1E:  BNZ   0A22
00A20:  INCF   00,F
00A22:  BTFSC  x62.7
00A24:  BSF    01.7
00A26:  BTFSS  x62.7
00A28:  BCF    01.7
00A2A:  BRA    0A34
00A2C:  CLRF   00
00A2E:  CLRF   01
00A30:  CLRF   02
00A32:  CLRF   03
00A34:  MOVLB  0
00A36:  RETURN 0
00A38:  MOVLW  8E
00A3A:  MOVWF  00
00A3C:  MOVLB  5
00A3E:  MOVF   x5A,W
00A40:  SUBWF  00,F
00A42:  MOVFF  55B,02
00A46:  MOVFF  55C,01
00A4A:  BSF    02.7
00A4C:  MOVF   00,F
00A4E:  BZ    0A62
00A50:  BCF    3FD8.0
00A52:  MOVF   02,F
00A54:  BNZ   0A5A
00A56:  MOVF   01,F
00A58:  BZ    0A62
00A5A:  RRCF   02,F
00A5C:  RRCF   01,F
00A5E:  DECFSZ 00,F
00A60:  BRA    0A50
00A62:  BTFSS  x5B.7
00A64:  BRA    0A70
00A66:  COMF   01,F
00A68:  COMF   02,F
00A6A:  INCF   01,F
00A6C:  BTFSC  3FD8.2
00A6E:  INCF   02,F
00A70:  MOVLB  0
00A72:  RETURN 0
*
00B98:  TBLRD*+
00B9A:  MOVFFL 3FF6,558
00BA0:  MOVFFL 3FF7,559
00BA6:  MOVFFL 3FF8,55A
00BAC:  MOVF   3FF5,W
00BAE:  MOVLB  39
00BB0:  BTFSS  xA6.3
00BB2:  BRA    0BB0
00BB4:  MOVLB  3D
00BB6:  MOVWF  xD2
00BB8:  MOVFFL 558,3FF6
00BBE:  MOVFFL 559,3FF7
00BC4:  MOVFFL 55A,3FF8
00BCA:  MOVLB  5
00BCC:  DECFSZ x57,F
00BCE:  BRA    0BD2
00BD0:  BRA    0BD6
00BD2:  MOVLB  0
00BD4:  BRA    0B98
00BD6:  MOVLB  0
00BD8:  RETURN 0
00BDA:  MOVLB  5
00BDC:  MOVF   x5A,W
00BDE:  CLRF   01
00BE0:  SUBWF  x59,W
00BE2:  BC    0BEA
00BE4:  MOVFF  559,00
00BE8:  BRA    0C02
00BEA:  CLRF   00
00BEC:  MOVLW  08
00BEE:  MOVWF  x5B
00BF0:  RLCF   x59,F
00BF2:  RLCF   00,F
00BF4:  MOVF   x5A,W
00BF6:  SUBWF  00,W
00BF8:  BTFSC  3FD8.0
00BFA:  MOVWF  00
00BFC:  RLCF   01,F
00BFE:  DECFSZ x5B,F
00C00:  BRA    0BF0
00C02:  MOVLB  0
00C04:  RETURN 0
00C06:  MOVF   01,W
00C08:  MOVFF  557,559
00C0C:  MOVLW  64
00C0E:  MOVLB  5
00C10:  MOVWF  x5A
00C12:  MOVLB  0
00C14:  RCALL  0BDA
00C16:  MOVFF  00,557
00C1A:  MOVF   01,W
00C1C:  MOVLW  30
00C1E:  BNZ   0C30
00C20:  MOVLB  5
00C22:  BTFSS  x58.1
00C24:  BRA    0C48
00C26:  BTFSC  x58.3
00C28:  BRA    0C48
00C2A:  BTFSC  x58.4
00C2C:  MOVLW  20
00C2E:  BRA    0C38
00C30:  MOVLB  5
00C32:  BCF    x58.3
00C34:  BCF    x58.4
00C36:  BSF    x58.0
00C38:  ADDWF  01,F
00C3A:  MOVF   01,W
00C3C:  MOVLB  39
00C3E:  BTFSS  xA6.3
00C40:  BRA    0C3E
00C42:  MOVLB  3D
00C44:  MOVWF  xD2
00C46:  MOVLB  5
00C48:  MOVFF  557,559
00C4C:  MOVLW  0A
00C4E:  MOVWF  x5A
00C50:  MOVLB  0
00C52:  RCALL  0BDA
00C54:  MOVFF  00,557
00C58:  MOVF   01,W
00C5A:  MOVLW  30
00C5C:  BNZ   0C6E
00C5E:  MOVLB  5
00C60:  BTFSC  x58.3
00C62:  BRA    0C7E
00C64:  BTFSS  x58.0
00C66:  BRA    0C7E
00C68:  BTFSC  x58.4
00C6A:  MOVLW  20
00C6C:  MOVLB  0
00C6E:  ADDWF  01,F
00C70:  MOVF   01,W
00C72:  MOVLB  39
00C74:  BTFSS  xA6.3
00C76:  BRA    0C74
00C78:  MOVLB  3D
00C7A:  MOVWF  xD2
00C7C:  MOVLB  5
00C7E:  MOVLW  30
00C80:  ADDWF  x57,F
00C82:  MOVF   x57,W
00C84:  MOVLB  39
00C86:  BTFSS  xA6.3
00C88:  BRA    0C86
00C8A:  MOVLB  3D
00C8C:  MOVWF  xD2
00C8E:  MOVLB  0
00C90:  RETURN 0
00C92:  MOVFFL 3FEA,55E
00C98:  MOVFFL 3FE9,55D
00C9E:  MOVLB  5
00CA0:  SWAPF  x57,W
00CA2:  IORLW  F0
00CA4:  MOVWF  x59
00CA6:  ADDWF  x59,F
00CA8:  ADDLW  E2
00CAA:  MOVWF  x5A
00CAC:  ADDLW  32
00CAE:  MOVWF  x5C
00CB0:  MOVF   x57,W
00CB2:  ANDLW  0F
00CB4:  ADDWF  x5A,F
00CB6:  ADDWF  x5A,F
00CB8:  ADDWF  x5C,F
00CBA:  ADDLW  E9
00CBC:  MOVWF  x5B
00CBE:  ADDWF  x5B,F
00CC0:  ADDWF  x5B,F
00CC2:  SWAPF  x56,W
00CC4:  ANDLW  0F
00CC6:  ADDWF  x5B,F
00CC8:  ADDWF  x5C,F
00CCA:  RLCF   x5B,F
00CCC:  RLCF   x5C,F
00CCE:  COMF   x5C,F
00CD0:  RLCF   x5C,F
00CD2:  MOVF   x56,W
00CD4:  ANDLW  0F
00CD6:  ADDWF  x5C,F
00CD8:  RLCF   x59,F
00CDA:  MOVLW  07
00CDC:  MOVWF  x58
00CDE:  MOVLW  0A
00CE0:  DECF   x5B,F
00CE2:  ADDWF  x5C,F
00CE4:  BNC   0CE0
00CE6:  DECF   x5A,F
00CE8:  ADDWF  x5B,F
00CEA:  BNC   0CE6
00CEC:  DECF   x59,F
00CEE:  ADDWF  x5A,F
00CF0:  BNC   0CEC
00CF2:  DECF   x58,F
00CF4:  ADDWF  x59,F
00CF6:  BNC   0CF2
00CF8:  MOVLW  05
00CFA:  MOVWF  3FEA
00CFC:  MOVLW  58
00CFE:  MOVWF  3FE9
00D00:  MOVLW  07
00D02:  ANDWF  x5D,W
00D04:  BCF    x5D.6
00D06:  ADDWF  3FE9,F
00D08:  MOVLW  00
00D0A:  ADDWFC 3FEA,F
00D0C:  MOVF   3FE9,W
00D0E:  SUBLW  5C
00D10:  BNZ   0D1A
00D12:  MOVF   3FEA,W
00D14:  SUBLW  05
00D16:  BNZ   0D1A
00D18:  BSF    x5D.6
00D1A:  MOVF   3FEF,W
00D1C:  MOVWF  00
00D1E:  BNZ   0D30
00D20:  BTFSC  x5D.6
00D22:  BRA    0D30
00D24:  BTFSC  x5D.4
00D26:  BRA    0D46
00D28:  BTFSC  x5D.3
00D2A:  BRA    0D30
00D2C:  MOVLW  20
00D2E:  BRA    0D36
00D30:  BSF    x5D.3
00D32:  BCF    x5D.4
00D34:  MOVLW  30
00D36:  ADDWF  00,F
00D38:  MOVF   00,W
00D3A:  MOVLB  39
00D3C:  BTFSS  xA6.3
00D3E:  BRA    0D3C
00D40:  MOVLB  3D
00D42:  MOVWF  xD2
00D44:  MOVLB  5
00D46:  MOVF   3FEE,W
00D48:  BTFSS  x5D.6
00D4A:  BRA    0D0C
00D4C:  MOVLB  0
00D4E:  RETURN 0
*
01F66:  CLRF   00
01F68:  CLRF   01
01F6A:  MOVLB  5
01F6C:  MOVF   xDA,W
01F6E:  BCF    3FD8.0
01F70:  BTFSC  xDB.0
01F72:  ADDWF  00,F
01F74:  RRCF   00,F
01F76:  RRCF   01,F
01F78:  BTFSC  xDB.1
01F7A:  ADDWF  00,F
01F7C:  RRCF   00,F
01F7E:  RRCF   01,F
01F80:  BTFSC  xDB.2
01F82:  ADDWF  00,F
01F84:  RRCF   00,F
01F86:  RRCF   01,F
01F88:  BTFSC  xDB.3
01F8A:  ADDWF  00,F
01F8C:  RRCF   00,F
01F8E:  RRCF   01,F
01F90:  BTFSC  xDB.4
01F92:  ADDWF  00,F
01F94:  RRCF   00,F
01F96:  RRCF   01,F
01F98:  BTFSC  xDB.5
01F9A:  ADDWF  00,F
01F9C:  RRCF   00,F
01F9E:  RRCF   01,F
01FA0:  BTFSC  xDB.6
01FA2:  ADDWF  00,F
01FA4:  RRCF   00,F
01FA6:  RRCF   01,F
01FA8:  BTFSC  xDB.7
01FAA:  ADDWF  00,F
01FAC:  RRCF   00,F
01FAE:  RRCF   01,F
01FB0:  MOVLB  0
01FB2:  RETURN 0
*
034BC:  CLRF   01
034BE:  CLRF   02
034C0:  CLRF   00
034C2:  CLRF   03
034C4:  MOVLB  5
034C6:  MOVF   x5D,W
034C8:  BNZ   34CE
034CA:  MOVF   x5C,W
034CC:  BZ    34FE
034CE:  MOVLW  10
034D0:  MOVWF  x5E
034D2:  BCF    3FD8.0
034D4:  RLCF   x5A,F
034D6:  RLCF   x5B,F
034D8:  RLCF   00,F
034DA:  RLCF   03,F
034DC:  MOVF   x5D,W
034DE:  SUBWF  03,W
034E0:  BNZ   34E6
034E2:  MOVF   x5C,W
034E4:  SUBWF  00,W
034E6:  BNC   34F6
034E8:  MOVF   x5C,W
034EA:  SUBWF  00,F
034EC:  BTFSS  3FD8.0
034EE:  DECF   03,F
034F0:  MOVF   x5D,W
034F2:  SUBWF  03,F
034F4:  BSF    3FD8.0
034F6:  RLCF   01,F
034F8:  RLCF   02,F
034FA:  DECFSZ x5E,F
034FC:  BRA    34D2
034FE:  MOVLB  0
03500:  RETURN 0
*
057F8:  ADDWF  3FE8,W
057FA:  CLRF   3FF7
057FC:  RLCF   3FF7,F
057FE:  ADDLW  19
05800:  MOVWF  3FF6
05802:  MOVLW  58
05804:  ADDWFC 3FF7,F
05806:  MOVLW  00
05808:  MOVWF  3FF8
0580A:  MOVWF  3FFB
0580C:  TBLRD*-
0580E:  MOVF   3FF5,W
05810:  MOVWF  3FFA
05812:  TBLRD*
05814:  MOVF   3FF5,W
05816:  MOVWF  3FF9
05818:  DATA 22,57
0581A:  DATA 2E,57
0581C:  DATA 3A,57
0581E:  DATA 46,57
05820:  ADDWF  3FE8,W
05822:  CLRF   3FF7
05824:  RLCF   3FF7,F
05826:  ADDLW  41
05828:  MOVWF  3FF6
0582A:  MOVLW  58
0582C:  ADDWFC 3FF7,F
0582E:  MOVLW  00
05830:  MOVWF  3FF8
05832:  MOVWF  3FFB
05834:  TBLRD*-
05836:  MOVF   3FF5,W
05838:  MOVWF  3FFA
0583A:  TBLRD*
0583C:  MOVF   3FF5,W
0583E:  MOVWF  3FF9
05840:  DATA A6,57
05842:  DATA AE,57
05844:  DATA B6,57
05846:  DATA BE,57
05848:  DATA C6,57
0584A:  DATA CE,57
0584C:  DATA D6,57
0584E:  DATA DE,57
05850:  DATA E6,57
05852:  DATA EC,57
*
06348:  TBLRD*+
0634A:  MOVF   3FF5,F
0634C:  BZ    637C
0634E:  MOVFFL 3FF6,580
06354:  MOVFFL 3FF7,581
0635A:  MOVFFL 3FF8,582
06360:  MOVFFL 3FF5,5A4
06366:  RCALL  633E
06368:  MOVFFL 580,3FF6
0636E:  MOVFFL 581,3FF7
06374:  MOVFFL 582,3FF8
0637A:  BRA    6348
0637C:  RETURN 0
*
064BA:  TBLRD*+
064BC:  MOVF   3FF5,F
064BE:  BZ    64F4
064C0:  MOVFFL 3FF6,560
064C6:  MOVFFL 3FF7,561
064CC:  MOVFFL 3FF8,562
064D2:  MOVF   3FF5,W
064D4:  MOVLB  39
064D6:  BTFSS  xA3.4
064D8:  BRA    64D6
064DA:  MOVLB  3D
064DC:  MOVWF  xEA
064DE:  MOVFFL 560,3FF6
064E4:  MOVFFL 561,3FF7
064EA:  MOVFFL 562,3FF8
064F0:  MOVLB  0
064F2:  BRA    64BA
064F4:  GOTO   65BA (RETURN)
*
06684:  MOVFF  588,01
06688:  MOVFF  587,00
0668C:  TSTFSZ 00
0668E:  INCF   01,F
06690:  TBLRD*+
06692:  MOVFFL 3FF5,3FEE
06698:  DECFSZ 00,F
0669A:  BRA    6690
0669C:  DECFSZ 01,F
0669E:  BRA    6690
066A0:  CLRF   3FF8
066A2:  GOTO   66E0 (RETURN)
*
06A06:  MOVF   3FEF,F
06A08:  BZ    6A32
06A0A:  MOVFFL 3FEA,5A3
06A10:  MOVFFL 3FE9,5A2
06A16:  MOVFFL 3FEF,5A4
06A1C:  RCALL  633E
06A1E:  MOVFFL 5A3,3FEA
06A24:  MOVFFL 5A2,3FE9
06A2A:  INCF   3FE9,F
06A2C:  BTFSC  3FD8.2
06A2E:  INCF   3FEA,F
06A30:  BRA    6A06
06A32:  GOTO   6B94 (RETURN)
*
06DD6:  MOVF   3FEF,F
06DD8:  BZ    6E08
06DDA:  MOVFFL 3FEA,557
06DE0:  MOVFFL 3FE9,556
06DE6:  MOVF   3FEF,W
06DE8:  MOVLB  39
06DEA:  BTFSS  xA6.3
06DEC:  BRA    6DEA
06DEE:  MOVLB  3D
06DF0:  MOVWF  xD2
06DF2:  MOVFFL 557,3FEA
06DF8:  MOVFFL 556,3FE9
06DFE:  INCF   3FE9,F
06E00:  BTFSC  3FD8.2
06E02:  INCF   3FEA,F
06E04:  MOVLB  0
06E06:  BRA    6DD6
06E08:  GOTO   77E6 (RETURN)
*
071B0:  MOVLB  5
071B2:  MOVF   x69,W
071B4:  XORWF  x6B,W
071B6:  ANDLW  80
071B8:  MOVWF  x6D
071BA:  BTFSS  x69.7
071BC:  BRA    71C8
071BE:  COMF   x68,F
071C0:  COMF   x69,F
071C2:  INCF   x68,F
071C4:  BTFSC  3FD8.2
071C6:  INCF   x69,F
071C8:  BTFSS  x6B.7
071CA:  BRA    71D6
071CC:  COMF   x6A,F
071CE:  COMF   x6B,F
071D0:  INCF   x6A,F
071D2:  BTFSC  3FD8.2
071D4:  INCF   x6B,F
071D6:  MOVF   x68,W
071D8:  MULWF  x6A
071DA:  MOVFFL 3FF3,01
071E0:  MOVFFL 3FF4,00
071E6:  MULWF  x6B
071E8:  MOVF   3FF3,W
071EA:  ADDWF  00,F
071EC:  MOVF   x69,W
071EE:  MULWF  x6A
071F0:  MOVF   3FF3,W
071F2:  ADDWFC 00,W
071F4:  MOVWF  02
071F6:  BTFSS  x6D.7
071F8:  BRA    7204
071FA:  COMF   01,F
071FC:  COMF   02,F
071FE:  INCF   01,F
07200:  BTFSC  3FD8.2
07202:  INCF   02,F
07204:  MOVLB  0
07206:  GOTO   72EC (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device pass_strings=in_ram
.................... 
.................... #use delay(internal=32mhz)
*
005EC:  MOVLW  05
005EE:  MOVWF  3FEA
005F0:  MOVLW  A6
005F2:  MOVWF  3FE9
005F4:  MOVF   3FEF,W
005F6:  BZ    0612
005F8:  MOVLW  0A
005FA:  MOVWF  01
005FC:  CLRF   00
005FE:  DECFSZ 00,F
00600:  BRA    05FE
00602:  DECFSZ 01,F
00604:  BRA    05FC
00606:  MOVLW  5F
00608:  MOVWF  00
0060A:  DECFSZ 00,F
0060C:  BRA    060A
0060E:  DECFSZ 3FEF,F
00610:  BRA    05F8
00612:  RETURN 0
*
008E2:  MOVLW  02
008E4:  MOVLB  5
008E6:  SUBWF  x5A,F
008E8:  BNC   0902
008EA:  MOVLW  05
008EC:  MOVWF  3FEA
008EE:  MOVLW  5A
008F0:  MOVWF  3FE9
008F2:  MOVF   3FEF,W
008F4:  BZ    0902
008F6:  BRA    08FE
008F8:  BRA    08FA
008FA:  BRA    08FC
008FC:  NOP   
008FE:  DECFSZ 3FEF,F
00900:  BRA    08F8
00902:  MOVLB  0
00904:  RETURN 0
.................... 
.................... 
.................... #pin_select U1TX=PIN_C6  // for RN487x
.................... #pin_select U1RX=PIN_C7
.................... #pin_select U2TX=PIN_B3  // for 18F47K42
.................... #pin_select U2RX=PIN_B4
.................... #use rs232(baud=115200,parity=N,xmit=PIN_B3,rcv=PIN_B4,bits=8,stream=DEBUG)
.................... #pin_select CCP1OUT=PIN_C2      //battery charger PWM
.................... 
.................... //#pin_select U1TX=PIN_C6  // for 18f47K42
.................... //#pin_select U1RX=PIN_C7
.................... //#use rs232(ICD, baud=115200, stream=DEBUG, disable_ints)
.................... 
.................... #define BUTTON1 PIN_B0
.................... #define BUTTON2 PIN_B1
.................... #define CHRGR_ON    PIN_A2      //DI,SET WHEN CHARGER ATTACHED
.................... #define RST_BLE PIN_B5
.................... #define LED1    PIN_A6
.................... #define ENB_VCC PIN_A5
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
06976:  MOVFFL 566,3FEA
0697C:  MOVLB  5
0697E:  MOVF   x65,W
06980:  MOVWF  3FE9
06982:  MOVFFL 3FEF,569
06988:  MOVFFL 568,3FEA
0698E:  MOVF   x67,W
06990:  MOVWF  3FE9
06992:  MOVF   3FEF,W
06994:  SUBWF  x69,W
06996:  BNZ   69C8
....................       if (*s1 == '\0')
06998:  MOVFF  566,03
0699C:  MOVF   x65,W
0699E:  MOVWF  3FE9
069A0:  MOVFFL 03,3FEA
069A6:  MOVF   3FEF,F
069A8:  BNZ   69B0
....................          return(0);
069AA:  MOVLW  00
069AC:  MOVWF  01
069AE:  BRA    69F8
069B0:  MOVFF  566,03
069B4:  MOVF   x65,W
069B6:  INCF   x65,F
069B8:  BTFSC  3FD8.2
069BA:  INCF   x66,F
069BC:  INCF   x67,F
069BE:  BTFSC  3FD8.2
069C0:  INCF   x68,F
069C2:  MOVLB  0
069C4:  BRA    6976
069C6:  MOVLB  5
....................    return((*s1 < *s2) ? -1: 1);
069C8:  MOVFF  566,03
069CC:  MOVF   x65,W
069CE:  MOVWF  3FE9
069D0:  MOVFFL 03,3FEA
069D6:  MOVFFL 3FEF,569
069DC:  MOVFF  568,03
069E0:  MOVF   x67,W
069E2:  MOVWF  3FE9
069E4:  MOVFFL 03,3FEA
069EA:  MOVF   3FEF,W
069EC:  SUBWF  x69,W
069EE:  BC    69F4
069F0:  MOVLW  FF
069F2:  BRA    69F6
069F4:  MOVLW  01
069F6:  MOVWF  01
069F8:  MOVLB  0
069FA:  GOTO   6CA6 (RETURN)
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
06E9E:  MOVFF  569,56D
06EA2:  MOVFF  568,56C
06EA6:  MOVFFL 56D,3FEA
06EAC:  MOVLB  5
06EAE:  MOVF   x6C,W
06EB0:  MOVWF  3FE9
06EB2:  MOVF   3FEF,F
06EB4:  BZ    6F0E
....................       for (sc2 = s2; *sc2 != 0; sc2++)
06EB6:  MOVFF  56B,56F
06EBA:  MOVFF  56A,56E
06EBE:  MOVFFL 56F,3FEA
06EC4:  MOVF   x6E,W
06EC6:  MOVWF  3FE9
06EC8:  MOVF   3FEF,F
06ECA:  BZ    6F02
....................          if (*sc1 == *sc2)
06ECC:  MOVFF  56D,03
06ED0:  MOVF   x6C,W
06ED2:  MOVWF  3FE9
06ED4:  MOVFFL 03,3FEA
06EDA:  MOVFFL 3FEF,570
06EE0:  MOVFFL 56F,3FEA
06EE6:  MOVF   x6E,W
06EE8:  MOVWF  3FE9
06EEA:  MOVF   3FEF,W
06EEC:  SUBWF  x70,W
06EEE:  BNZ   6EFA
....................             return(sc1);
06EF0:  MOVFF  56C,01
06EF4:  MOVFF  56D,02
06EF8:  BRA    6F14
06EFA:  INCF   x6E,F
06EFC:  BTFSC  3FD8.2
06EFE:  INCF   x6F,F
06F00:  BRA    6EBE
06F02:  INCF   x6C,F
06F04:  BTFSC  3FD8.2
06F06:  INCF   x6D,F
06F08:  MOVLB  0
06F0A:  BRA    6EA6
06F0C:  MOVLB  5
....................    return(0);
06F0E:  MOVLW  00
06F10:  MOVWF  01
06F12:  MOVWF  02
06F14:  MOVLB  0
06F16:  GOTO   6FBA (RETURN)
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
06E0C:  MOVFF  569,56D
06E10:  MOVFF  568,56C
06E14:  MOVFFL 56D,3FEA
06E1A:  MOVLB  5
06E1C:  MOVF   x6C,W
06E1E:  MOVWF  3FE9
06E20:  MOVF   3FEF,F
06E22:  BZ    6E86
....................       for (sc2 = s2; ; sc2++)
06E24:  MOVFF  56B,56F
06E28:  MOVFF  56A,56E
....................     if (*sc2 == '\0')
06E2C:  MOVFFL 56F,3FEA
06E32:  MOVF   x6E,W
06E34:  MOVWF  3FE9
06E36:  MOVF   3FEF,F
06E38:  BNZ   6E50
....................        return(sc1 - s1);
06E3A:  MOVF   x68,W
06E3C:  SUBWF  x6C,W
06E3E:  MOVWF  00
06E40:  MOVF   x69,W
06E42:  SUBWFB x6D,W
06E44:  MOVWF  03
06E46:  MOVFF  00,01
06E4A:  MOVWF  02
06E4C:  BRA    6E98
06E4E:  BRA    6E72
....................          else if (*sc1 == *sc2)
06E50:  MOVFFL 56D,3FEA
06E56:  MOVF   x6C,W
06E58:  MOVWF  3FE9
06E5A:  MOVFFL 3FEF,570
06E60:  MOVFFL 56F,3FEA
06E66:  MOVF   x6E,W
06E68:  MOVWF  3FE9
06E6A:  MOVF   3FEF,W
06E6C:  SUBWF  x70,W
06E6E:  BNZ   6E72
....................             break;
06E70:  BRA    6E7A
06E72:  INCF   x6E,F
06E74:  BTFSC  3FD8.2
06E76:  INCF   x6F,F
06E78:  BRA    6E2C
06E7A:  INCF   x6C,F
06E7C:  BTFSC  3FD8.2
06E7E:  INCF   x6D,F
06E80:  MOVLB  0
06E82:  BRA    6E14
06E84:  MOVLB  5
....................    return(sc1 - s1);
06E86:  MOVF   x68,W
06E88:  SUBWF  x6C,W
06E8A:  MOVWF  00
06E8C:  MOVF   x69,W
06E8E:  SUBWFB x6D,W
06E90:  MOVWF  03
06E92:  MOVFF  00,01
06E96:  MOVWF  02
06E98:  MOVLB  0
06E9A:  GOTO   6F86 (RETURN)
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
06F1A:  MOVFF  569,56B
06F1E:  MOVFF  568,56A
06F22:  MOVFFL 56B,3FEA
06F28:  MOVLB  5
06F2A:  MOVF   x6A,W
06F2C:  MOVWF  3FE9
06F2E:  MOVF   3FEF,F
06F30:  BZ    6F3E
06F32:  INCF   x6A,F
06F34:  BTFSC  3FD8.2
06F36:  INCF   x6B,F
06F38:  MOVLB  0
06F3A:  BRA    6F22
06F3C:  MOVLB  5
....................    return(sc - s);
06F3E:  MOVF   x68,W
06F40:  SUBWF  x6A,W
06F42:  MOVWF  00
06F44:  MOVF   x69,W
06F46:  SUBWFB x6B,W
06F48:  MOVWF  03
06F4A:  MOVFF  00,01
06F4E:  MOVWF  02
06F50:  MOVLB  0
06F52:  GOTO   6FF4 (RETURN)
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
06F56:  MOVLB  5
06F58:  MOVF   x60,W
06F5A:  IORWF  x61,W
06F5C:  BZ    6F66
06F5E:  MOVFF  561,03
06F62:  MOVF   x60,W
06F64:  BRA    6F6C
06F66:  MOVFF  1D,03
06F6A:  MOVF   1C,W
06F6C:  MOVWF  x64
06F6E:  MOVFF  03,565
....................    beg += strspn(beg, s2);
06F72:  MOVFF  565,569
06F76:  MOVFF  564,568
06F7A:  MOVFF  563,56B
06F7E:  MOVFF  562,56A
06F82:  MOVLB  0
06F84:  BRA    6E0C
06F86:  MOVF   01,W
06F88:  MOVLB  5
06F8A:  ADDWF  x64,F
06F8C:  MOVF   02,W
06F8E:  ADDWFC x65,F
....................    if (*beg == '\0')
06F90:  MOVFFL 565,3FEA
06F96:  MOVF   x64,W
06F98:  MOVWF  3FE9
06F9A:  MOVF   3FEF,F
06F9C:  BNZ   6FA6
....................       return(0);
06F9E:  MOVLW  00
06FA0:  MOVWF  01
06FA2:  MOVWF  02
06FA4:  BRA    700A
....................       
....................    end = strpbrk(beg, s2);
06FA6:  MOVFF  565,569
06FAA:  MOVFF  564,568
06FAE:  MOVFF  563,56B
06FB2:  MOVFF  562,56A
06FB6:  MOVLB  0
06FB8:  BRA    6E9E
06FBA:  MOVFF  02,567
06FBE:  MOVFF  01,566
....................    if (end != '\0')
06FC2:  MOVLB  5
06FC4:  MOVF   x66,F
06FC6:  BNZ   6FCC
06FC8:  MOVF   x67,F
06FCA:  BZ    6FE8
....................    {
....................       *end = '\0';
06FCC:  MOVFFL 567,3FEA
06FD2:  MOVF   x66,W
06FD4:  MOVWF  3FE9
06FD6:  CLRF   3FEF
....................       end++;
06FD8:  INCF   x66,F
06FDA:  BTFSC  3FD8.2
06FDC:  INCF   x67,F
....................       save = end;
06FDE:  MOVFF  567,1D
06FE2:  MOVFF  566,1C
....................    }
06FE6:  BRA    7002
....................    else
....................       save = beg + strlen(beg);
06FE8:  MOVFF  565,569
06FEC:  MOVFF  564,568
06FF0:  MOVLB  0
06FF2:  BRA    6F1A
06FF4:  MOVF   01,W
06FF6:  MOVLB  5
06FF8:  ADDWF  x64,W
06FFA:  MOVWF  1C
06FFC:  MOVF   02,W
06FFE:  ADDWFC x65,W
07000:  MOVWF  1D
....................    
....................    return(beg);
07002:  MOVFF  564,01
07006:  MOVFF  565,02
0700A:  MOVLB  0
0700C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
0700E:  MOVLB  5
07010:  CLRF   x65
....................    sign = 0;
07012:  CLRF   x63
....................    base = 10;
07014:  MOVLW  0A
07016:  MOVWF  x64
....................    result = 0;
07018:  CLRF   x62
.................... 
....................    if (!s)
0701A:  MOVF   x60,W
0701C:  IORWF  x61,W
0701E:  BNZ   7026
....................       return 0;
07020:  MOVLW  00
07022:  MOVWF  01
07024:  BRA    71AA
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
07026:  MOVF   x65,W
07028:  INCF   x65,F
0702A:  ADDWF  x60,W
0702C:  MOVWF  3FE9
0702E:  MOVLW  00
07030:  ADDWFC x61,W
07032:  MOVWF  3FEA
07034:  MOVFFL 3FEF,566
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
0703A:  MOVF   x66,W
0703C:  SUBLW  2D
0703E:  BNZ   705A
....................    {
....................       sign = 1;         // Set the sign to negative
07040:  MOVLW  01
07042:  MOVWF  x63
....................       c = s[index++];
07044:  MOVF   x65,W
07046:  INCF   x65,F
07048:  ADDWF  x60,W
0704A:  MOVWF  3FE9
0704C:  MOVLW  00
0704E:  ADDWFC x61,W
07050:  MOVWF  3FEA
07052:  MOVFFL 3FEF,566
....................    }
07058:  BRA    7074
....................    else if (c == '+')
0705A:  MOVF   x66,W
0705C:  SUBLW  2B
0705E:  BNZ   7074
....................    {
....................       c = s[index++];
07060:  MOVF   x65,W
07062:  INCF   x65,F
07064:  ADDWF  x60,W
07066:  MOVWF  3FE9
07068:  MOVLW  00
0706A:  ADDWFC x61,W
0706C:  MOVWF  3FEA
0706E:  MOVFFL 3FEF,566
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
07074:  MOVF   x66,W
07076:  SUBLW  2F
07078:  BTFSC  3FD8.0
0707A:  BRA    719A
0707C:  MOVF   x66,W
0707E:  SUBLW  39
07080:  BTFSS  3FD8.0
07082:  BRA    719A
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
07084:  MOVF   x66,W
07086:  SUBLW  30
07088:  BNZ   70C8
0708A:  MOVF   x65,W
0708C:  ADDWF  x60,W
0708E:  MOVWF  3FE9
07090:  MOVLW  00
07092:  ADDWFC x61,W
07094:  MOVWF  3FEA
07096:  MOVF   3FEF,W
07098:  SUBLW  78
0709A:  BZ    70AE
0709C:  MOVF   x65,W
0709E:  ADDWF  x60,W
070A0:  MOVWF  3FE9
070A2:  MOVLW  00
070A4:  ADDWFC x61,W
070A6:  MOVWF  3FEA
070A8:  MOVF   3FEF,W
070AA:  SUBLW  58
070AC:  BNZ   70C8
....................       {
....................          base = 16;
070AE:  MOVLW  10
070B0:  MOVWF  x64
....................          index++;
070B2:  INCF   x65,F
....................          c = s[index++];
070B4:  MOVF   x65,W
070B6:  INCF   x65,F
070B8:  ADDWF  x60,W
070BA:  MOVWF  3FE9
070BC:  MOVLW  00
070BE:  ADDWFC x61,W
070C0:  MOVWF  3FEA
070C2:  MOVFFL 3FEF,566
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
070C8:  MOVF   x64,W
070CA:  SUBLW  0A
070CC:  BNZ   710A
....................       {
....................          while (c >= '0' && c <= '9')
070CE:  MOVF   x66,W
070D0:  SUBLW  2F
070D2:  BC    7108
070D4:  MOVF   x66,W
070D6:  SUBLW  39
070D8:  BNC   7108
....................          {
....................             result = 10*result + (c - '0');
070DA:  MOVLW  0A
070DC:  MOVWF  xDA
070DE:  MOVFF  562,5DB
070E2:  MOVLB  0
070E4:  CALL   1F66
070E8:  MOVLW  30
070EA:  MOVLB  5
070EC:  SUBWF  x66,W
070EE:  ADDWF  01,W
070F0:  MOVWF  x62
....................             c = s[index++];
070F2:  MOVF   x65,W
070F4:  INCF   x65,F
070F6:  ADDWF  x60,W
070F8:  MOVWF  3FE9
070FA:  MOVLW  00
070FC:  ADDWFC x61,W
070FE:  MOVWF  3FEA
07100:  MOVFFL 3FEF,566
07106:  BRA    70CE
....................          }
....................       }
07108:  BRA    719A
....................       else if (base == 16)    // The number is a hexa number
0710A:  MOVF   x64,W
0710C:  SUBLW  10
0710E:  BNZ   719A
....................       {
....................          c = toupper(c);
07110:  MOVF   x66,W
07112:  SUBLW  60
07114:  BC    7122
07116:  MOVF   x66,W
07118:  SUBLW  7A
0711A:  BNC   7122
0711C:  MOVF   x66,W
0711E:  ANDLW  DF
07120:  BRA    7124
07122:  MOVF   x66,W
07124:  MOVWF  x66
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
07126:  MOVF   x66,W
07128:  SUBLW  2F
0712A:  BC    7132
0712C:  MOVF   x66,W
0712E:  SUBLW  39
07130:  BC    713E
07132:  MOVF   x66,W
07134:  SUBLW  40
07136:  BC    719A
07138:  MOVF   x66,W
0713A:  SUBLW  46
0713C:  BNC   719A
....................          {
....................             if (c >= '0' && c <= '9')
0713E:  MOVF   x66,W
07140:  SUBLW  2F
07142:  BC    715C
07144:  MOVF   x66,W
07146:  SUBLW  39
07148:  BNC   715C
....................                result = (result << 4) + (c - '0');
0714A:  SWAPF  x62,W
0714C:  MOVWF  x67
0714E:  MOVLW  F0
07150:  ANDWF  x67,F
07152:  MOVLW  30
07154:  SUBWF  x66,W
07156:  ADDWF  x67,W
07158:  MOVWF  x62
0715A:  BRA    716E
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
0715C:  SWAPF  x62,W
0715E:  MOVWF  x67
07160:  MOVLW  F0
07162:  ANDWF  x67,F
07164:  MOVLW  41
07166:  SUBWF  x66,W
07168:  ADDLW  0A
0716A:  ADDWF  x67,W
0716C:  MOVWF  x62
.................... 
....................             c = s[index++];
0716E:  MOVF   x65,W
07170:  INCF   x65,F
07172:  ADDWF  x60,W
07174:  MOVWF  3FE9
07176:  MOVLW  00
07178:  ADDWFC x61,W
0717A:  MOVWF  3FEA
0717C:  MOVFFL 3FEF,566
....................             c = toupper(c);
07182:  MOVF   x66,W
07184:  SUBLW  60
07186:  BC    7194
07188:  MOVF   x66,W
0718A:  SUBLW  7A
0718C:  BNC   7194
0718E:  MOVF   x66,W
07190:  ANDLW  DF
07192:  BRA    7196
07194:  MOVF   x66,W
07196:  MOVWF  x66
07198:  BRA    7126
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
0719A:  DECFSZ x63,W
0719C:  BRA    71A6
0719E:  MOVF   x64,W
071A0:  SUBLW  0A
071A2:  BNZ   71A6
....................        result = -result;
071A4:  NEGF   x62
.................... 
....................    return(result);
071A6:  MOVFF  562,01
071AA:  MOVLB  0
071AC:  GOTO   744C (RETURN)
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
0720A:  MOVLB  5
0720C:  CLRF   x66
....................    sign = 0;
0720E:  CLRF   x64
....................    base = 10;
07210:  MOVLW  0A
07212:  MOVWF  x65
....................    result = 0;
07214:  CLRF   x63
07216:  CLRF   x62
.................... 
....................    if (!s)
07218:  MOVF   x60,W
0721A:  IORWF  x61,W
0721C:  BNZ   7226
....................       return 0;
0721E:  MOVLW  00
07220:  MOVWF  01
07222:  MOVWF  02
07224:  BRA    73EC
....................    c = s[index++];
07226:  MOVF   x66,W
07228:  INCF   x66,F
0722A:  ADDWF  x60,W
0722C:  MOVWF  3FE9
0722E:  MOVLW  00
07230:  ADDWFC x61,W
07232:  MOVWF  3FEA
07234:  MOVFFL 3FEF,567
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
0723A:  MOVF   x67,W
0723C:  SUBLW  2D
0723E:  BNZ   725A
....................    {
....................       sign = 1;         // Set the sign to negative
07240:  MOVLW  01
07242:  MOVWF  x64
....................       c = s[index++];
07244:  MOVF   x66,W
07246:  INCF   x66,F
07248:  ADDWF  x60,W
0724A:  MOVWF  3FE9
0724C:  MOVLW  00
0724E:  ADDWFC x61,W
07250:  MOVWF  3FEA
07252:  MOVFFL 3FEF,567
....................    }
07258:  BRA    7274
....................    else if (c == '+')
0725A:  MOVF   x67,W
0725C:  SUBLW  2B
0725E:  BNZ   7274
....................    {
....................       c = s[index++];
07260:  MOVF   x66,W
07262:  INCF   x66,F
07264:  ADDWF  x60,W
07266:  MOVWF  3FE9
07268:  MOVLW  00
0726A:  ADDWFC x61,W
0726C:  MOVWF  3FEA
0726E:  MOVFFL 3FEF,567
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
07274:  MOVF   x67,W
07276:  SUBLW  2F
07278:  BTFSC  3FD8.0
0727A:  BRA    73D0
0727C:  MOVF   x67,W
0727E:  SUBLW  39
07280:  BTFSS  3FD8.0
07282:  BRA    73D0
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
07284:  MOVF   x67,W
07286:  SUBLW  30
07288:  BNZ   72C8
0728A:  MOVF   x66,W
0728C:  ADDWF  x60,W
0728E:  MOVWF  3FE9
07290:  MOVLW  00
07292:  ADDWFC x61,W
07294:  MOVWF  3FEA
07296:  MOVF   3FEF,W
07298:  SUBLW  78
0729A:  BZ    72AE
0729C:  MOVF   x66,W
0729E:  ADDWF  x60,W
072A0:  MOVWF  3FE9
072A2:  MOVLW  00
072A4:  ADDWFC x61,W
072A6:  MOVWF  3FEA
072A8:  MOVF   3FEF,W
072AA:  SUBLW  58
072AC:  BNZ   72C8
....................       {
....................          base = 16;
072AE:  MOVLW  10
072B0:  MOVWF  x65
....................          index++;
072B2:  INCF   x66,F
....................          c = s[index++];
072B4:  MOVF   x66,W
072B6:  INCF   x66,F
072B8:  ADDWF  x60,W
072BA:  MOVWF  3FE9
072BC:  MOVLW  00
072BE:  ADDWFC x61,W
072C0:  MOVWF  3FEA
072C2:  MOVFFL 3FEF,567
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
072C8:  MOVF   x65,W
072CA:  SUBLW  0A
072CC:  BNZ   7314
....................       {
....................          while (c >= '0' && c <= '9')
072CE:  MOVF   x67,W
072D0:  SUBLW  2F
072D2:  BC    7312
072D4:  MOVF   x67,W
072D6:  SUBLW  39
072D8:  BNC   7312
....................          {
....................             result = 10*result + (c - '0');
072DA:  CLRF   x69
072DC:  MOVLW  0A
072DE:  MOVWF  x68
072E0:  MOVFF  563,56B
072E4:  MOVFF  562,56A
072E8:  MOVLB  0
072EA:  BRA    71B0
072EC:  MOVLW  30
072EE:  MOVLB  5
072F0:  SUBWF  x67,W
072F2:  ADDWF  01,W
072F4:  MOVWF  x62
072F6:  MOVLW  00
072F8:  ADDWFC 02,W
072FA:  MOVWF  x63
....................             c = s[index++];
072FC:  MOVF   x66,W
072FE:  INCF   x66,F
07300:  ADDWF  x60,W
07302:  MOVWF  3FE9
07304:  MOVLW  00
07306:  ADDWFC x61,W
07308:  MOVWF  3FEA
0730A:  MOVFFL 3FEF,567
07310:  BRA    72CE
....................          }
....................       }
07312:  BRA    73D0
....................       else if (base == 16)    // The number is a hexa number
07314:  MOVF   x65,W
07316:  SUBLW  10
07318:  BNZ   73D0
....................       {
....................          c = toupper(c);
0731A:  MOVF   x67,W
0731C:  SUBLW  60
0731E:  BC    732C
07320:  MOVF   x67,W
07322:  SUBLW  7A
07324:  BNC   732C
07326:  MOVF   x67,W
07328:  ANDLW  DF
0732A:  BRA    732E
0732C:  MOVF   x67,W
0732E:  MOVWF  x67
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
07330:  MOVF   x67,W
07332:  SUBLW  2F
07334:  BC    733C
07336:  MOVF   x67,W
07338:  SUBLW  39
0733A:  BC    7348
0733C:  MOVF   x67,W
0733E:  SUBLW  40
07340:  BC    73D0
07342:  MOVF   x67,W
07344:  SUBLW  46
07346:  BNC   73D0
....................          {
....................             if (c >= '0' && c <= '9')
07348:  MOVF   x67,W
0734A:  SUBLW  2F
0734C:  BC    737C
0734E:  MOVF   x67,W
07350:  SUBLW  39
07352:  BNC   737C
....................                result = (result << 4) + (c - '0');
07354:  RLCF   x62,W
07356:  MOVWF  x68
07358:  RLCF   x63,W
0735A:  MOVWF  x69
0735C:  RLCF   x68,F
0735E:  RLCF   x69,F
07360:  RLCF   x68,F
07362:  RLCF   x69,F
07364:  RLCF   x68,F
07366:  RLCF   x69,F
07368:  MOVLW  F0
0736A:  ANDWF  x68,F
0736C:  MOVLW  30
0736E:  SUBWF  x67,W
07370:  ADDWF  x68,W
07372:  MOVWF  x62
07374:  MOVLW  00
07376:  ADDWFC x69,W
07378:  MOVWF  x63
0737A:  BRA    73A4
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
0737C:  RLCF   x62,W
0737E:  MOVWF  x68
07380:  RLCF   x63,W
07382:  MOVWF  x69
07384:  RLCF   x68,F
07386:  RLCF   x69,F
07388:  RLCF   x68,F
0738A:  RLCF   x69,F
0738C:  RLCF   x68,F
0738E:  RLCF   x69,F
07390:  MOVLW  F0
07392:  ANDWF  x68,F
07394:  MOVLW  41
07396:  SUBWF  x67,W
07398:  ADDLW  0A
0739A:  ADDWF  x68,W
0739C:  MOVWF  x62
0739E:  MOVLW  00
073A0:  ADDWFC x69,W
073A2:  MOVWF  x63
.................... 
....................             c = s[index++];c = toupper(c);
073A4:  MOVF   x66,W
073A6:  INCF   x66,F
073A8:  ADDWF  x60,W
073AA:  MOVWF  3FE9
073AC:  MOVLW  00
073AE:  ADDWFC x61,W
073B0:  MOVWF  3FEA
073B2:  MOVFFL 3FEF,567
073B8:  MOVF   x67,W
073BA:  SUBLW  60
073BC:  BC    73CA
073BE:  MOVF   x67,W
073C0:  SUBLW  7A
073C2:  BNC   73CA
073C4:  MOVF   x67,W
073C6:  ANDLW  DF
073C8:  BRA    73CC
073CA:  MOVF   x67,W
073CC:  MOVWF  x67
073CE:  BRA    7330
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
073D0:  MOVF   x65,W
073D2:  SUBLW  0A
073D4:  BNZ   73E4
073D6:  DECFSZ x64,W
073D8:  BRA    73E4
....................       result = -result;
073DA:  COMF   x62,F
073DC:  COMF   x63,F
073DE:  INCF   x62,F
073E0:  BTFSC  3FD8.2
073E2:  INCF   x63,F
.................... 
....................    return(result);
073E4:  MOVFF  562,01
073E8:  MOVFF  563,02
073EC:  MOVLB  0
073EE:  RETURN 0
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #define BT_MODEL_NAME "BLE-Central"
.................... #define BT_REMOTE_NAME "Halo"
.................... #include "rn487x.c"
.................... /////////////////////////////////////////////////////////////////////
.................... //  Custom RN487x driver for the N devices
.................... //
.................... //  Primary functions:
.................... 
.................... int1 ble_start_scan(void);
.................... int1 ble_connect(int8 entry);
.................... int1 ble_disconnect(void);
.................... 
.................... int16 ble_find_handle(char * characteristic, int8 attrib);
.................... int1 ble_set_characteristic(int16 handle, char * outgoing, char * result);
.................... 
.................... int1 ble_get_status_resp(char * buffer, int16 time=1);
.................... 
.................... //
.................... // See the function documentation below for deatils on the function operation.
.................... //
.................... // Use ble_devices[] and ble_entries to find the remote devices found.
.................... //
.................... // ALSO:
.................... //    BT_MODEL_NAME should be #defined to be used to identify this module.
.................... //
.................... //    INT_RDA and GLOBAL interrupts must be enabled.
.................... //
.................... // NOTES:
.................... //    On the sample device the device information items did not seem to
.................... //    to work so that code was not included.
.................... //
.................... //    This protocol does not use the data stream so that code is not included.
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #define BLE_SERVICES "C0"     // Turn on device information
.................... #define BLE_FEATURES "1000"   // Ignore devices we can not connect to
.................... 
.................... #define BLE_LAST_DEVICE  0xFF  // Connect to last device we connected to
.................... //9524
.................... 
.................... #use rs232(UART1,baud=9600,stream=BLE,errors)
*
000AE:  MOVLB  39
000B0:  BTFSS  xA3.3
000B2:  BRA    00B0
000B4:  MOVLB  3D
000B6:  MOVF   xF9,W
000B8:  MOVWF  22
000BA:  MOVF   xE8,W
000BC:  MOVWF  01
000BE:  BTFSS  22.1
000C0:  BRA    00CA
000C2:  BCF    xF2.4
000C4:  BSF    xF7.1
000C6:  BCF    xF9.1
000C8:  BSF    xF2.4
000CA:  MOVLB  0
000CC:  GOTO   010C (RETURN)
*
0632E:  MOVLB  39
06330:  BTFSS  xA3.4
06332:  BRA    6330
06334:  MOVLB  3D
06336:  MOVWF  xEA
06338:  MOVLB  0
0633A:  GOTO   6346 (RETURN)
.................... 
.................... int1 ble_command_mode = FALSE;
.................... int1 ble_scan_mode = FALSE;
.................... 
.................... 
.................... #define BLE_CMD_BUFFER_SIZE  128            // Can use 64 if the baud rate is reduced
.................... 
.................... char ble_cmd_buffer[BLE_CMD_BUFFER_SIZE];   // Incomming data from the command stream
.................... int8 ble_cmd_next_in=0;
.................... int8 ble_cmd_next_out=0;
.................... int1 ble_overrun = FALSE;
.................... 
.................... 
.................... #define BLE_STATUS_READY 0xff
.................... #define BLE_STATUS_READ  0xfe
.................... char ble_status[64];                   // Last status message
.................... int8 ble_status_ptr=BLE_STATUS_READ;
.................... 
.................... 
.................... int8 ble_entries = 0;  // Count of entries (1 means one entry)
.................... 
.................... struct {               // These are the remote devices found in a scan
....................    char name[16];
....................    char address[16];
....................    int8 rssi;
.................... } ble_devices[32];
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////
.................... //
.................... // UTILITY functions used by the primary functions follow
.................... //
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... int8 toascii1(char c) {
....................    if(c<='9')
....................      return(c-'0');
....................    else
....................      return(c-('A'-10));
.................... }
.................... 
.................... int8 toascii(char * p) {
....................    return(toascii1(*p)*16+toascii1(*(p+1)));
.................... }
.................... 
.................... unsigned int8 hex2int1(char digit) {
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((digit-'A')+10);
.................... }
.................... 
.................... unsigned int16 hex2int4(char d1, char d2, char d3, char d4) {
....................    return( hex2int1(d1)*4096+hex2int1(d2)*256+hex2int1(d3)*16+hex2int1(d4) );
.................... }
.................... 
.................... void ble_clear_status(void) {
....................    ble_status_ptr=BLE_STATUS_READ;
*
069FE:  MOVLW  FE
06A00:  MOVWF  xE6
06A02:  GOTO   6B10 (RETURN)
.................... }
.................... 
.................... void ble_cmd_putc(char c) {
....................    fputc(c,BLE);
*
0633E:  MOVLB  5
06340:  MOVF   xA4,W
06342:  MOVLB  0
06344:  BRA    632E
06346:  RETURN 0
.................... }
.................... 
.................... int1 ble_cmd_kbhit(void) {
....................    return(ble_cmd_next_in!=ble_cmd_next_out);
*
064F8:  MOVF   xA5,W
064FA:  SUBWF  xA4,W
064FC:  BNZ   6502
064FE:  MOVLW  00
06500:  BRA    6504
06502:  MOVLW  01
06504:  MOVWF  01
06506:  RETURN 0
.................... }
.................... 
.................... char ble_cmd_getc(void) {
....................   char c;
....................   while(!ble_cmd_kbhit()) ;
06508:  RCALL  64F8
0650A:  MOVF   01,F
0650C:  BZ    6508
....................    c=ble_cmd_buffer[ble_cmd_next_out];
0650E:  CLRF   03
06510:  MOVF   xA5,W
06512:  ADDLW  24
06514:  MOVWF  3FE9
06516:  MOVLW  00
06518:  ADDWFC 03,W
0651A:  MOVWF  3FEA
0651C:  MOVFFL 3FEF,588
....................    ble_cmd_next_out=(ble_cmd_next_out+1) % sizeof(ble_cmd_buffer);
06522:  MOVLW  01
06524:  ADDWF  xA5,W
06526:  ANDLW  7F
06528:  MOVWF  xA5
....................    return(c);
0652A:  MOVLB  5
0652C:  MOVFF  588,01
06530:  MOVLB  0
06532:  RETURN 0
.................... }
.................... 
.................... char ble_cmd_tgetc(void) {
....................    int8 to;
....................    char c;
....................    
....................    to=0;
*
06D12:  MOVLB  5
06D14:  CLRF   x5C
....................    c=0;
06D16:  CLRF   x5D
....................    do {
....................       if(ble_cmd_kbhit())
06D18:  MOVLB  0
06D1A:  CALL   64F8
06D1E:  MOVF   01,F
06D20:  BZ    6D2C
....................          c=ble_cmd_getc();
06D22:  CALL   6508
06D26:  MOVFF  01,55D
06D2A:  BRA    6D38
....................       else
....................          delay_ms(10);
06D2C:  MOVLW  0A
06D2E:  MOVLB  5
06D30:  MOVWF  xA6
06D32:  MOVLB  0
06D34:  CALL   05EC
....................    } while((c==0)&&(++to<100));
06D38:  MOVLB  5
06D3A:  MOVF   x5D,F
06D3C:  BNZ   6D46
06D3E:  INCF   x5C,F
06D40:  MOVF   x5C,W
06D42:  SUBLW  63
06D44:  BC    6D18
....................    return c;
06D46:  MOVFF  55D,01
06D4A:  MOVLB  0
06D4C:  RETURN 0
.................... }
.................... 
.................... void ble_gets(char * str,int8 max) {
....................    int n,to;
....................    char c;
....................    
....................    to=0;
06D4E:  MOVLB  5
06D50:  CLRF   x5A
....................    do {
....................       c=ble_cmd_tgetc();
06D52:  MOVLB  0
06D54:  RCALL  6D12
06D56:  MOVFF  01,55B
....................    } while((c!='$')&&(c!=0));
06D5A:  MOVLB  5
06D5C:  MOVF   x5B,W
06D5E:  SUBLW  24
06D60:  BZ    6D66
06D62:  MOVF   x5B,F
06D64:  BNZ   6D52
....................    if(c==0) {
06D66:  MOVF   x5B,F
06D68:  BNZ   6D78
....................      *str=0;
06D6A:  MOVFFL 557,3FEA
06D70:  MOVF   x56,W
06D72:  MOVWF  3FE9
06D74:  CLRF   3FEF
....................      return;
06D76:  BRA    6DD0
....................    }
....................    *str=c;
06D78:  MOVFFL 557,3FEA
06D7E:  MOVF   x56,W
06D80:  MOVWF  3FE9
06D82:  MOVFFL 55B,3FEF
....................    str++;
06D88:  INCF   x56,F
06D8A:  BTFSC  3FD8.2
06D8C:  INCF   x57,F
....................    n=1;
06D8E:  MOVLW  01
06D90:  MOVWF  x59
....................    do {
....................       c=ble_cmd_tgetc();
06D92:  MOVLB  0
06D94:  RCALL  6D12
06D96:  MOVFF  01,55B
....................       *str=c;
06D9A:  MOVFFL 557,3FEA
06DA0:  MOVLB  5
06DA2:  MOVF   x56,W
06DA4:  MOVWF  3FE9
06DA6:  MOVFFL 55B,3FEF
....................       str++;
06DAC:  INCF   x56,F
06DAE:  BTFSC  3FD8.2
06DB0:  INCF   x57,F
....................       n++;
06DB2:  INCF   x59,F
....................    } while((c!='\r')&&(n<max)&&(c!=0));
06DB4:  MOVF   x5B,W
06DB6:  SUBLW  0D
06DB8:  BZ    6DC4
06DBA:  MOVF   x58,W
06DBC:  SUBWF  x59,W
06DBE:  BC    6DC4
06DC0:  MOVF   x5B,F
06DC2:  BNZ   6D92
....................    *str=0;
06DC4:  MOVFFL 557,3FEA
06DCA:  MOVF   x56,W
06DCC:  MOVWF  3FE9
06DCE:  CLRF   3FEF
06DD0:  MOVLB  0
06DD2:  GOTO   77BE (RETURN)
.................... }
.................... 
.................... void ble_clear_cmd_buffer(void) {
....................    ble_cmd_next_in=0;
*
065CA:  CLRF   xA4
....................    ble_cmd_next_out=0;
065CC:  CLRF   xA5
....................    ble_overrun=FALSE;
065CE:  BCF    23.2
065D0:  RETURN 0
.................... }
.................... 
.................... int1 wait_for_prompt(void) {
*
06534:  MOVLB  5
06536:  CLRF   x62
06538:  CLRF   x61
....................    char c;
....................    int16 to=0;
....................    
....................    c=' ';
0653A:  MOVLW  20
0653C:  MOVWF  x60
....................    while(c!='>') {
0653E:  MOVF   x60,W
06540:  SUBLW  3E
06542:  BZ    6582
....................       if(ble_cmd_kbhit()) {
06544:  MOVLB  0
06546:  RCALL  64F8
06548:  MOVF   01,F
0654A:  BZ    6554
....................          c=ble_cmd_getc();
0654C:  RCALL  6508
0654E:  MOVFF  01,560
....................       } else {
06552:  BRA    657E
....................          delay_ms(1);
06554:  MOVLW  01
06556:  MOVLB  5
06558:  MOVWF  xA6
0655A:  MOVLB  0
0655C:  CALL   05EC
....................          if(++to>5000) {
06560:  MOVLB  5
06562:  INCF   x61,F
06564:  BTFSC  3FD8.2
06566:  INCF   x62,F
06568:  MOVF   x62,W
0656A:  SUBLW  12
0656C:  BC    657E
0656E:  XORLW  FF
06570:  BNZ   6578
06572:  MOVF   x61,W
06574:  SUBLW  88
06576:  BC    657E
....................             return(TRUE);
06578:  MOVLW  01
0657A:  MOVWF  01
0657C:  BRA    659A
....................          }
....................       }
0657E:  MOVLB  5
06580:  BRA    653E
....................    }
....................    delay_ms(1000);
06582:  MOVLW  04
06584:  MOVWF  x63
06586:  MOVLW  FA
06588:  MOVWF  xA6
0658A:  MOVLB  0
0658C:  CALL   05EC
06590:  MOVLB  5
06592:  DECFSZ x63,F
06594:  BRA    6586
....................    return(FALSE);
06596:  MOVLW  00
06598:  MOVWF  01
0659A:  MOVLB  0
0659C:  RETURN 0
.................... }
.................... 
.................... void ble_get_cmd_resp(char * buffer, int16 time=1) {
*
065D2:  CLRF   1B
065D4:  BTFSC  3FD2.7
065D6:  BSF    1B.7
065D8:  BCF    3FD2.7
....................    char c;
....................    int8 max;
....................    int16 to;
....................    
....................    time*=1000;
065DA:  MOVFF  583,858
065DE:  MOVFF  582,857
065E2:  MOVLW  03
065E4:  MOVLB  8
065E6:  MOVWF  x5A
065E8:  MOVLW  E8
065EA:  MOVWF  x59
065EC:  MOVLB  0
065EE:  CALL   00D0
065F2:  BTFSC  1B.7
065F4:  BSF    3FD2.7
065F6:  MOVFF  02,583
065FA:  MOVFF  01,582
....................    
....................    to=0;
065FE:  MOVLB  5
06600:  CLRF   x87
06602:  CLRF   x86
....................    max=128;
06604:  MOVLW  80
06606:  MOVWF  x85
....................    c=' ';
06608:  MOVLW  20
0660A:  MOVWF  x84
....................    while(c!='\r') {
0660C:  MOVF   x84,W
0660E:  SUBLW  0D
06610:  BZ    6674
....................       if(ble_cmd_kbhit()) {
06612:  MOVLB  0
06614:  RCALL  64F8
06616:  MOVF   01,F
06618:  BZ    664E
....................          c=ble_cmd_getc();
0661A:  RCALL  6508
0661C:  MOVFF  01,584
....................          if(c==0)
06620:  MOVLB  5
06622:  MOVF   x84,F
06624:  BNZ   662A
....................            c=' ';
06626:  MOVLW  20
06628:  MOVWF  x84
....................          if(c>=' ') {
0662A:  MOVF   x84,W
0662C:  SUBLW  1F
0662E:  BC    664C
....................             *buffer=c;
06630:  MOVFFL 581,3FEA
06636:  MOVF   x80,W
06638:  MOVWF  3FE9
0663A:  MOVFFL 584,3FEF
....................             buffer++;
06640:  INCF   x80,F
06642:  BTFSC  3FD8.2
06644:  INCF   x81,F
....................             if(--max==0)
06646:  DECFSZ x85,F
06648:  BRA    664C
....................               break;
0664A:  BRA    6674
0664C:  MOVLB  0
....................          }
....................       }
....................       delay_ms(1);
0664E:  MOVLW  01
06650:  MOVLB  5
06652:  MOVWF  xA6
06654:  MOVLB  0
06656:  CALL   05EC
....................       if(++to>time) {
0665A:  MOVLB  5
0665C:  INCF   x86,F
0665E:  BTFSC  3FD8.2
06660:  INCF   x87,F
06662:  MOVF   x83,W
06664:  SUBWF  x87,W
06666:  BNC   6672
06668:  BNZ   6670
0666A:  MOVF   x86,W
0666C:  SUBWF  x82,W
0666E:  BC    6672
....................          break;
06670:  BRA    6674
....................       }
06672:  BRA    660C
....................    }
....................    *buffer=0;
06674:  MOVFFL 581,3FEA
0667A:  MOVF   x80,W
0667C:  MOVWF  3FE9
0667E:  CLRF   3FEF
....................    return;
06680:  MOVLB  0
06682:  RETURN 0
.................... }
.................... 
.................... void ble_enter_data_mode(void) {
....................       ble_command_mode=FALSE;
....................       delay_ms(100);
....................       printf(ble_cmd_putc,"---\r");
.................... }
.................... 
.................... int1 ble_enter_cmd_mode(void) {
....................    delay_ms(150);    
*
0659E:  MOVLW  96
065A0:  MOVLB  5
065A2:  MOVWF  xA6
065A4:  MOVLB  0
065A6:  CALL   05EC
....................    ble_command_mode=TRUE;
065AA:  BSF    23.0
....................    fprintf(BLE,"$$$");
065AC:  MOVLW  A2
065AE:  MOVWF  3FF6
065B0:  MOVLW  00
065B2:  MOVWF  3FF7
065B4:  MOVLW  00
065B6:  MOVWF  3FF8
065B8:  BRA    64BA
....................    return(!wait_for_prompt());
065BA:  RCALL  6534
065BC:  MOVF   01,F
065BE:  BZ    65C4
065C0:  MOVLW  00
065C2:  BRA    65C6
065C4:  MOVLW  01
065C6:  MOVWF  01
065C8:  RETURN 0
.................... }
.................... 
.................... int1 strcmprom(char *s1, rom char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
066A6:  MOVFF  581,03
066AA:  MOVLB  5
066AC:  MOVF   x80,W
066AE:  MOVWF  3FE9
066B0:  MOVFFL 03,3FEA
066B6:  MOVFFL 3FEF,585
066BC:  MOVFFL 584,3FF8
066C2:  MOVFFL 583,3FF7
066C8:  MOVFFL 582,3FF6
066CE:  MOVLW  05
066D0:  MOVWF  3FEA
066D2:  MOVLW  86
066D4:  MOVWF  3FE9
066D6:  CLRF   x88
066D8:  MOVLW  01
066DA:  MOVWF  x87
066DC:  MOVLB  0
066DE:  BRA    6684
066E0:  MOVLB  5
066E2:  MOVF   x86,W
066E4:  SUBWF  x85,W
066E6:  BNZ   6726
....................       if (*s1 == '\0')
066E8:  MOVFFL 581,3FEA
066EE:  MOVF   x80,W
066F0:  MOVWF  3FE9
066F2:  MOVF   3FEF,F
066F4:  BNZ   66FC
....................          return(0);
066F6:  MOVLW  00
066F8:  MOVWF  01
066FA:  BRA    672A
066FC:  MOVFF  581,03
06700:  MOVF   x80,W
06702:  INCF   x80,F
06704:  BTFSC  3FD8.2
06706:  INCF   x81,F
06708:  MOVFF  584,02
0670C:  MOVFF  583,01
06710:  MOVFF  582,00
06714:  MOVLW  01
06716:  ADDWF  x82,F
06718:  BTFSC  3FD8.0
0671A:  INCF   x83,F
0671C:  BTFSC  3FD8.2
0671E:  INCF   x84,F
06720:  MOVLB  0
06722:  BRA    66A6
06724:  MOVLB  5
....................    return(1);
06726:  MOVLW  01
06728:  MOVWF  01
0672A:  MOVLB  0
0672C:  RETURN 0
.................... }
.................... 
.................... int1 ble_check_config() {
....................    char resp[32];
.................... 
....................      delay_ms(250);       //jpc  originally 500
0672E:  MOVLW  FA
06730:  MOVLB  5
06732:  MOVWF  xA6
06734:  MOVLB  0
06736:  CALL   05EC
....................    ble_clear_cmd_buffer();
0673A:  RCALL  65CA
....................    printf(ble_cmd_putc,"GS\r");   
0673C:  MOVLW  A6
0673E:  MOVWF  3FF6
06740:  MOVLW  00
06742:  MOVWF  3FF7
06744:  MOVLW  00
06746:  MOVWF  3FF8
06748:  RCALL  6348
....................    ble_get_cmd_resp(resp);
0674A:  MOVLW  05
0674C:  MOVLB  5
0674E:  MOVWF  x81
06750:  MOVLW  60
06752:  MOVWF  x80
06754:  CLRF   x83
06756:  MOVLW  01
06758:  MOVWF  x82
0675A:  MOVLB  0
0675C:  RCALL  65D2
....................    resp[2]=0;
0675E:  MOVLB  5
06760:  CLRF   x62
....................    if(strcmprom(resp,BLE_SERVICES))
06762:  MOVLW  05
06764:  MOVWF  x81
06766:  MOVLW  60
06768:  MOVWF  x80
0676A:  MOVLW  01
0676C:  MOVWF  x84
0676E:  SETF   x83
06770:  MOVLW  FC
06772:  MOVWF  x82
06774:  MOVLB  0
06776:  RCALL  66A6
06778:  MOVF   01,F
0677A:  BZ    6782
....................      return(TRUE);
0677C:  MOVLW  01
0677E:  MOVWF  01
06780:  BRA    67DA
....................    delay_ms(250);       //jpc  originally 500
06782:  MOVLW  FA
06784:  MOVLB  5
06786:  MOVWF  xA6
06788:  MOVLB  0
0678A:  CALL   05EC
....................    ble_clear_cmd_buffer();    
0678E:  RCALL  65CA
....................    printf(ble_cmd_putc,"GR\r");   
06790:  MOVLW  AA
06792:  MOVWF  3FF6
06794:  MOVLW  00
06796:  MOVWF  3FF7
06798:  MOVLW  00
0679A:  MOVWF  3FF8
0679C:  RCALL  6348
....................    ble_get_cmd_resp(resp);
0679E:  MOVLW  05
067A0:  MOVLB  5
067A2:  MOVWF  x81
067A4:  MOVLW  60
067A6:  MOVWF  x80
067A8:  CLRF   x83
067AA:  MOVLW  01
067AC:  MOVWF  x82
067AE:  MOVLB  0
067B0:  RCALL  65D2
....................    resp[4]=0;
067B2:  MOVLB  5
067B4:  CLRF   x64
....................    if(strcmprom(resp,BLE_FEATURES))
067B6:  MOVLW  05
067B8:  MOVWF  x81
067BA:  MOVLW  60
067BC:  MOVWF  x80
067BE:  MOVLW  01
067C0:  MOVWF  x84
067C2:  SETF   x83
067C4:  MOVLW  F6
067C6:  MOVWF  x82
067C8:  MOVLB  0
067CA:  RCALL  66A6
067CC:  MOVF   01,F
067CE:  BZ    67D6
....................      return(TRUE);
067D0:  MOVLW  01
067D2:  MOVWF  01
067D4:  BRA    67DA
....................    return(FALSE);
067D6:  MOVLW  00
067D8:  MOVWF  01
067DA:  RETURN 0
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////
.................... // End of utility functions
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////
.................... // This is the interrupt function that receives and parses data from 
.................... // the RN487x.
.................... //
.................... // INT_RDA and GLOBAL interrupts must be enabled outside these functions.
.................... /////////////////////////////////////////////////////////////////////
.................... int8 scan_field,scan_idx;
.................... 
.................... #int_rda
.................... void serial_isr() {
*
000F6:  MOVLB  0
....................    static int8 scan_field,scan_idx;
....................    char c;
....................    int t;
.................... 
.................... if(bit_test(RS232_ERRORS,1))
000F8:  BTFSS  22.1
000FA:  BRA    010A
.................... fprintf(DEBUG,"L");
000FC:  MOVLW  4C
000FE:  MOVLB  39
00100:  BTFSS  xA6.3
00102:  BRA    0100
00104:  MOVLB  3D
00106:  MOVWF  xD2
00108:  MOVLB  0
....................    c=fgetc(BLE);
0010A:  BRA    00AE
0010C:  MOVFF  01,855
.................... //if(c=='g')
.................... //fprintf(DEBUG,"%c",c);
....................    if((c=='%') || (scan_field!=0)) {
00110:  MOVLB  8
00112:  MOVF   x55,W
00114:  SUBLW  25
00116:  BZ    0122
00118:  MOVLB  5
0011A:  MOVF   x0C,F
0011C:  BTFSC  3FD8.2
0011E:  BRA    0388
00120:  MOVLB  8
....................       if(!ble_scan_mode&&(scan_field!=5)) {
00122:  BTFSC  23.1
00124:  BRA    0142
00126:  MOVLB  5
00128:  MOVF   x0C,W
0012A:  SUBLW  05
0012C:  BTFSS  3FD8.2
0012E:  BRA    0134
00130:  MOVLB  8
00132:  BRA    0142
....................             ble_status_ptr=0;
00134:  MOVLB  0
00136:  CLRF   xE6
.................... //fprintf(DEBUG,"S");
....................             scan_field=5;
00138:  MOVLW  05
0013A:  MOVLB  5
0013C:  MOVWF  x0C
....................             return;
0013E:  BRA    03B8
00140:  MOVLB  8
....................       }
....................       if(scan_field==0) {
00142:  MOVLB  5
00144:  MOVF   x0C,F
00146:  BNZ   0150
....................          scan_field++;
00148:  INCF   x0C,F
....................          scan_idx=2;
0014A:  MOVLW  02
0014C:  MOVWF  x0D
.................... //fprintf(DEBUG,"0");
....................     } else if (scan_field==1) {
0014E:  BRA    0382
00150:  DECFSZ x0C,W
00152:  BRA    01F0
....................          if(c!=',')
00154:  MOVLB  8
00156:  MOVF   x55,W
00158:  SUBLW  2C
0015A:  BZ    01A4
....................             ble_devices[ble_entries].address[scan_idx++]=c;
0015C:  CLRF   x58
0015E:  MOVFF  E7,857
00162:  CLRF   x5A
00164:  MOVLW  21
00166:  MOVWF  x59
00168:  MOVLB  0
0016A:  RCALL  00D0
0016C:  MOVFF  02,858
00170:  MOVFF  01,857
00174:  MOVLW  10
00176:  MOVLB  8
00178:  ADDWF  x57,F
0017A:  MOVLW  00
0017C:  ADDWFC x58,F
0017E:  MOVLB  5
00180:  MOVF   x0D,W
00182:  INCF   x0D,F
00184:  MOVLB  8
00186:  ADDWF  x57,W
00188:  MOVWF  01
0018A:  MOVLW  00
0018C:  ADDWFC x58,W
0018E:  MOVWF  03
00190:  MOVF   01,W
00192:  ADDLW  E8
00194:  MOVWF  3FE9
00196:  MOVLW  00
00198:  ADDWFC 03,W
0019A:  MOVWF  3FEA
0019C:  MOVFFL 855,3FEF
001A2:  BRA    01EC
....................          else {
....................            scan_field=2;
001A4:  MOVLW  02
001A6:  MOVLB  5
001A8:  MOVWF  x0C
.................... //fprintf(DEBUG,"2");
....................            ble_devices[ble_entries].address[scan_idx]=0;
001AA:  MOVLB  8
001AC:  CLRF   x58
001AE:  MOVFF  E7,857
001B2:  CLRF   x5A
001B4:  MOVLW  21
001B6:  MOVWF  x59
001B8:  MOVLB  0
001BA:  RCALL  00D0
001BC:  MOVFF  02,858
001C0:  MOVFF  01,857
001C4:  MOVLW  10
001C6:  MOVLB  8
001C8:  ADDWF  x57,F
001CA:  MOVLW  00
001CC:  ADDWFC x58,F
001CE:  MOVLB  5
001D0:  MOVF   x0D,W
001D2:  MOVLB  8
001D4:  ADDWF  x57,W
001D6:  MOVWF  01
001D8:  MOVLW  00
001DA:  ADDWFC x58,W
001DC:  MOVWF  03
001DE:  MOVF   01,W
001E0:  ADDLW  E8
001E2:  MOVWF  3FE9
001E4:  MOVLW  00
001E6:  ADDWFC 03,W
001E8:  MOVWF  3FEA
001EA:  CLRF   3FEF
....................          }
....................       } else if (scan_field==2) {
001EC:  BRA    0384
001EE:  MOVLB  5
001F0:  MOVF   x0C,W
001F2:  SUBLW  02
001F4:  BNZ   0282
....................          if(c!=',')
001F6:  MOVLB  8
001F8:  MOVF   x55,W
001FA:  SUBLW  2C
001FC:  BZ    0234
....................             ble_devices[ble_entries].address[0]=c;
001FE:  CLRF   x58
00200:  MOVFF  E7,857
00204:  CLRF   x5A
00206:  MOVLW  21
00208:  MOVWF  x59
0020A:  MOVLB  0
0020C:  RCALL  00D0
0020E:  MOVFF  02,858
00212:  MOVFF  01,857
00216:  MOVLW  10
00218:  MOVLB  8
0021A:  ADDWF  x57,F
0021C:  MOVLW  00
0021E:  ADDWFC x58,F
00220:  MOVLW  E8
00222:  ADDWF  x57,W
00224:  MOVWF  3FE9
00226:  MOVLW  00
00228:  ADDWFC x58,W
0022A:  MOVWF  3FEA
0022C:  MOVFFL 855,3FEF
00232:  BRA    027E
....................          else { 
....................             ble_devices[ble_entries].address[1]=c;
00234:  CLRF   x58
00236:  MOVFF  E7,857
0023A:  CLRF   x5A
0023C:  MOVLW  21
0023E:  MOVWF  x59
00240:  MOVLB  0
00242:  RCALL  00D0
00244:  MOVFF  02,858
00248:  MOVFF  01,857
0024C:  MOVLW  10
0024E:  MOVLB  8
00250:  ADDWF  x57,F
00252:  MOVLW  00
00254:  ADDWFC x58,F
00256:  MOVLW  01
00258:  ADDWF  x57,W
0025A:  MOVWF  01
0025C:  MOVLW  00
0025E:  ADDWFC x58,W
00260:  MOVWF  03
00262:  MOVF   01,W
00264:  ADDLW  E8
00266:  MOVWF  3FE9
00268:  MOVLW  00
0026A:  ADDWFC 03,W
0026C:  MOVWF  3FEA
0026E:  MOVFFL 855,3FEF
....................             scan_field=3;
00274:  MOVLW  03
00276:  MOVLB  5
00278:  MOVWF  x0C
.................... //fprintf(DEBUG,"3");
....................             scan_idx=0;
0027A:  CLRF   x0D
0027C:  MOVLB  8
....................          }
....................       } else if (scan_field==3) {
0027E:  BRA    0384
00280:  MOVLB  5
00282:  MOVF   x0C,W
00284:  SUBLW  03
00286:  BNZ   0318
....................          if(c==',') {
00288:  MOVLB  8
0028A:  MOVF   x55,W
0028C:  SUBLW  2C
0028E:  BNZ   02DA
....................            if(scan_idx!=0) {
00290:  MOVLB  5
00292:  MOVF   x0D,F
00294:  BZ    02D2
....................                ble_devices[ble_entries].name[scan_idx]=0;
00296:  MOVLB  8
00298:  CLRF   x58
0029A:  MOVFF  E7,857
0029E:  CLRF   x5A
002A0:  MOVLW  21
002A2:  MOVWF  x59
002A4:  MOVLB  0
002A6:  RCALL  00D0
002A8:  MOVFF  01,857
002AC:  MOVLB  5
002AE:  MOVF   x0D,W
002B0:  MOVLB  8
002B2:  ADDWF  01,W
002B4:  MOVWF  01
002B6:  MOVLW  00
002B8:  ADDWFC 02,W
002BA:  MOVWF  03
002BC:  MOVF   01,W
002BE:  ADDLW  E8
002C0:  MOVWF  3FE9
002C2:  MOVLW  00
002C4:  ADDWFC 03,W
002C6:  MOVWF  3FEA
002C8:  CLRF   3FEF
....................                ble_entries++;
002CA:  MOVLB  0
002CC:  INCF   xE7,F
.................... //fprintf(DEBUG,"*");
....................                scan_idx=0;
002CE:  MOVLB  5
002D0:  CLRF   x0D
....................            }
....................            scan_field=4;
002D2:  MOVLW  04
002D4:  MOVWF  x0C
....................          } else
002D6:  BRA    0316
002D8:  MOVLB  8
....................             ble_devices[ble_entries].name[scan_idx++]=c;
002DA:  CLRF   x58
002DC:  MOVFF  E7,857
002E0:  CLRF   x5A
002E2:  MOVLW  21
002E4:  MOVWF  x59
002E6:  MOVLB  0
002E8:  RCALL  00D0
002EA:  MOVFF  02,858
002EE:  MOVFF  01,857
002F2:  MOVLB  5
002F4:  MOVF   x0D,W
002F6:  INCF   x0D,F
002F8:  ADDWF  01,W
002FA:  MOVWF  01
002FC:  MOVLW  00
002FE:  ADDWFC 02,W
00300:  MOVWF  03
00302:  MOVF   01,W
00304:  ADDLW  E8
00306:  MOVWF  3FE9
00308:  MOVLW  00
0030A:  ADDWFC 03,W
0030C:  MOVWF  3FEA
0030E:  MOVFFL 855,3FEF
00314:  MOVLB  5
....................       } else if (scan_field==4) {
00316:  BRA    0382
00318:  MOVF   x0C,W
0031A:  SUBLW  04
0031C:  BNZ   0338
....................          if((c=='%')||(c=='\r')) {
0031E:  MOVLB  8
00320:  MOVF   x55,W
00322:  SUBLW  25
00324:  BZ    032C
00326:  MOVF   x55,W
00328:  SUBLW  0D
0032A:  BNZ   0334
....................             scan_field=0;
0032C:  MOVLB  5
0032E:  CLRF   x0C
....................             scan_idx=0;
00330:  CLRF   x0D
00332:  MOVLB  8
....................          }
....................       } else if (scan_field==5) {
00334:  BRA    0384
00336:  MOVLB  5
00338:  MOVF   x0C,W
0033A:  SUBLW  05
0033C:  BNZ   0382
....................          if(c=='%') {
0033E:  MOVLB  8
00340:  MOVF   x55,W
00342:  SUBLW  25
00344:  BNZ   0364
....................             scan_field=0;
00346:  MOVLB  5
00348:  CLRF   x0C
....................             scan_idx=0;
0034A:  CLRF   x0D
....................             ble_status[ble_status_ptr]=0;
0034C:  CLRF   03
0034E:  MOVLB  0
00350:  MOVF   xE6,W
00352:  ADDLW  A6
00354:  MOVWF  3FE9
00356:  MOVLW  00
00358:  ADDWFC 03,W
0035A:  MOVWF  3FEA
0035C:  CLRF   3FEF
....................             ble_status_ptr=BLE_STATUS_READY;
0035E:  SETF   xE6
.................... //fprintf(DEBUG,"D");
....................          } else
00360:  BRA    0382
00362:  MOVLB  8
....................              if(ble_status_ptr!=64)
00364:  MOVLB  0
00366:  MOVF   xE6,W
00368:  SUBLW  40
0036A:  BZ    0382
....................                 ble_status[ble_status_ptr++]=c;
0036C:  MOVF   xE6,W
0036E:  INCF   xE6,F
00370:  CLRF   03
00372:  ADDLW  A6
00374:  MOVWF  3FE9
00376:  MOVLW  00
00378:  ADDWFC 03,W
0037A:  MOVWF  3FEA
0037C:  MOVFFL 855,3FEF
00382:  MOVLB  8
....................       }
....................    } else {
00384:  BRA    03B6
00386:  MOVLB  5
....................       ble_cmd_buffer[ble_cmd_next_in]=c;
00388:  CLRF   03
0038A:  MOVLB  0
0038C:  MOVF   xA4,W
0038E:  ADDLW  24
00390:  MOVWF  3FE9
00392:  MOVLW  00
00394:  ADDWFC 03,W
00396:  MOVWF  3FEA
00398:  MOVFFL 855,3FEF
....................       t=ble_cmd_next_in;
0039E:  MOVFF  A4,856
....................       ble_cmd_next_in=(ble_cmd_next_in+1) % sizeof(ble_cmd_buffer);
003A2:  MOVLW  01
003A4:  ADDWF  xA4,W
003A6:  ANDLW  7F
003A8:  MOVWF  xA4
....................       if(ble_cmd_next_in==ble_cmd_next_out)
003AA:  MOVF   xA5,W
003AC:  SUBWF  xA4,W
003AE:  BNZ   03B4
....................         ble_cmd_next_in=t;           // Buffer full !!
003B0:  MOVFF  856,A4
003B4:  MOVLB  8
003B6:  MOVLB  5
....................    }
003B8:  MOVLB  39
003BA:  BCF    xA3.3
003BC:  MOVLB  0
003BE:  GOTO   005A
.................... }
.................... 
.................... void ble_set_scan_mode(int1 on) {
....................    ble_scan_mode=on;
*
067DC:  BCF    23.1
067DE:  MOVLB  5
067E0:  BTFSC  xA0.0
067E2:  BSF    23.1
....................    if(on) {
067E4:  MOVF   xA0,F
067E6:  BZ    67EA
....................       scan_field=0;
067E8:  CLRF   x0A
....................    }
067EA:  MOVLB  0
067EC:  RETURN 0
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////
.................... //
.................... // ble_get_status_resp() returns a status message from the RN487x.
.................... // 
.................... // Various status messages may appear at any time.  
.................... // See Apx D of DS50002466B for a full list.
.................... //
.................... // Maybe the most useful is a DISCONNECT if the remote device
.................... // stops working.
.................... //
.................... // time is in seconds to wait for a new message.  Pass 0 to just
.................... // check if a message is waiting.
.................... //
.................... // The return value is 0 if a message is being returned.
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... int1 ble_get_status_resp(char * buffer, int16 time=1) {
*
06A36:  MOVLB  5
06A38:  CLRF   xA5
06A3A:  CLRF   xA4
06A3C:  CLRF   1B
06A3E:  BTFSC  3FD2.7
06A40:  BSF    1B.7
06A42:  BCF    3FD2.7
....................    int16 to=0;
....................    
....................    time*=500;   //jpc  was 1000
06A44:  MOVFF  5A3,858
06A48:  MOVFF  5A2,857
06A4C:  MOVLW  01
06A4E:  MOVLB  8
06A50:  MOVWF  x5A
06A52:  MOVLW  F4
06A54:  MOVWF  x59
06A56:  MOVLB  0
06A58:  CALL   00D0
06A5C:  BTFSC  1B.7
06A5E:  BSF    3FD2.7
06A60:  MOVFF  02,5A3
06A64:  MOVFF  01,5A2
....................    *buffer=0;
06A68:  MOVFFL 5A1,3FEA
06A6E:  MOVLB  5
06A70:  MOVF   xA0,W
06A72:  MOVWF  3FE9
06A74:  CLRF   3FEF
.................... 
....................    while((ble_status_ptr!=BLE_STATUS_READY)&&(++to<time)) {
06A76:  MOVLB  0
06A78:  INCFSZ xE6,W
06A7A:  BRA    6A7E
06A7C:  BRA    6AAC
06A7E:  MOVLB  5
06A80:  INCF   xA4,F
06A82:  BTFSC  3FD8.2
06A84:  INCF   xA5,F
06A86:  MOVF   xA5,W
06A88:  SUBWF  xA3,W
06A8A:  BTFSC  3FD8.0
06A8C:  BRA    6A92
06A8E:  MOVLB  0
06A90:  BRA    6AAC
06A92:  BNZ   6AA0
06A94:  MOVF   xA2,W
06A96:  SUBWF  xA4,W
06A98:  BTFSS  3FD8.0
06A9A:  BRA    6AA0
06A9C:  MOVLB  0
06A9E:  BRA    6AAC
....................          delay_ms(1);
06AA0:  MOVLW  01
06AA2:  MOVWF  xA6
06AA4:  MOVLB  0
06AA6:  CALL   05EC
06AAA:  BRA    6A78
....................    }
....................    if(ble_status_ptr==BLE_STATUS_READY) {
06AAC:  INCFSZ xE6,W
06AAE:  BRA    6AD8
....................       strcpy(buffer,ble_status);
06AB0:  MOVFFL 5A1,3FEA
06AB6:  MOVFFL 5A0,3FE9
06ABC:  CLRF   3FE2
06ABE:  MOVLW  A6
06AC0:  MOVWF  3FE1
06AC2:  MOVF   3FE7,F
06AC4:  MOVFFL 3FE6,3FEE
06ACA:  BNZ   6AC2
....................       ble_status_ptr=BLE_STATUS_READ;
06ACC:  MOVLW  FE
06ACE:  MOVWF  xE6
....................       return(FALSE);
06AD0:  MOVLW  00
06AD2:  MOVWF  01
06AD4:  BRA    6ADC
....................    } else
06AD6:  BRA    6ADC
....................       return(TRUE);
06AD8:  MOVLW  01
06ADA:  MOVWF  01
06ADC:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////
.................... //
.................... // ble_start_scan() starts scanning for remote devices.  The devices
.................... // are filled into the ble_devices table.  The function returns
.................... // right away because it could take a long time for the table to fill.
.................... // 
.................... // Note that if the RN487x is not set up right this function will reset
.................... // the module into the correct mode.
.................... //
.................... // BT_MODEL_NAME should be #defined for the string to be used to identify
.................... // this module.
.................... //
.................... // The return value is 0 if successful.
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... int1 ble_start_scan(void) {
....................    int1 err;
.................... 
....................    output_low(RST_BLE);  // Reset module
*
067EE:  BCF    3FC3.5
067F0:  BCF    3FBB.5
....................    delay_ms(10);    
067F2:  MOVLW  0A
067F4:  MOVLB  5
067F6:  MOVWF  xA6
067F8:  MOVLB  0
067FA:  CALL   05EC
....................    output_high(RST_BLE);
067FE:  BCF    3FC3.5
06800:  BSF    3FBB.5
....................  
....................    if(!ble_enter_cmd_mode()) {
06802:  RCALL  659E
06804:  MOVF   01,F
06806:  BNZ   68A8
....................       set_uart_speed(115200,BLE);
06808:  MOVLB  3D
0680A:  BCF    xF3.7
0680C:  BCF    3FC4.6
0680E:  BSF    3FBC.6
06810:  MOVLW  B0
06812:  MOVWF  xF2
06814:  CLRF   xF6
06816:  MOVLW  44
06818:  MOVWF  xF5
0681A:  CLRF   xF4
0681C:  BSF    xF3.7
....................       delay_ms(10);
0681E:  MOVLW  0A
06820:  MOVLB  5
06822:  MOVWF  xA6
06824:  MOVLB  0
06826:  CALL   05EC
....................       printf(ble_cmd_putc,"$$$");
0682A:  MOVLW  C2
0682C:  MOVWF  3FF6
0682E:  MOVLW  03
06830:  MOVWF  3FF7
06832:  MOVLW  00
06834:  MOVWF  3FF8
06836:  RCALL  6348
....................       delay_ms(10);
06838:  MOVLW  0A
0683A:  MOVLB  5
0683C:  MOVWF  xA6
0683E:  MOVLB  0
06840:  CALL   05EC
....................       printf(ble_cmd_putc,"SB,09\r");
06844:  MOVLW  C6
06846:  MOVWF  3FF6
06848:  MOVLW  03
0684A:  MOVWF  3FF7
0684C:  MOVLW  00
0684E:  MOVWF  3FF8
06850:  RCALL  6348
....................       delay_ms(100);
06852:  MOVLW  64
06854:  MOVLB  5
06856:  MOVWF  xA6
06858:  MOVLB  0
0685A:  CALL   05EC
....................       set_uart_speed(9600,BLE);
0685E:  MOVLB  3D
06860:  BCF    xF3.7
06862:  BCF    3FC4.6
06864:  BSF    3FBC.6
06866:  MOVLW  B0
06868:  MOVWF  xF2
0686A:  MOVLW  03
0686C:  MOVWF  xF6
0686E:  MOVLW  40
06870:  MOVWF  xF5
06872:  CLRF   xF4
06874:  BSF    xF3.7
....................       output_low(RST_BLE);  // Reset module
06876:  BCF    3FC3.5
06878:  BCF    3FBB.5
....................       delay_ms(10);    
0687A:  MOVLW  0A
0687C:  MOVLB  5
0687E:  MOVWF  xA6
06880:  MOVLB  0
06882:  CALL   05EC
....................       output_high(RST_BLE);
06886:  BCF    3FC3.5
06888:  BSF    3FBB.5
....................       ble_enter_cmd_mode();
0688A:  RCALL  659E
.................... fprintf(DEBUG,"\r\CHANGING BAUD\r\n");
0688C:  MOVLW  CE
0688E:  MOVWF  3FF6
06890:  MOVLW  03
06892:  MOVWF  3FF7
06894:  MOVLW  00
06896:  MOVWF  3FF8
06898:  CLRF   1B
0689A:  BTFSC  3FD2.7
0689C:  BSF    1B.7
0689E:  BCF    3FD2.7
068A0:  CALL   04D0
068A4:  BTFSC  1B.7
068A6:  BSF    3FD2.7
....................    }
.................... 
....................    err=ble_check_config();
068A8:  RCALL  672E
068AA:  MOVLB  5
068AC:  BCF    x5F.0
068AE:  BTFSC  01.0
068B0:  BSF    x5F.0
....................    if(err)
068B2:  BTFSS  x5F.0
068B4:  BRA    68C2
....................       err=ble_check_config();
068B6:  MOVLB  0
068B8:  RCALL  672E
068BA:  MOVLB  5
068BC:  BCF    x5F.0
068BE:  BTFSC  01.0
068C0:  BSF    x5F.0
.................... // err=FALSE;
....................     if(err) {
068C2:  BTFSS  x5F.0
068C4:  BRA    6924
....................       printf(ble_cmd_putc,"SS," BLE_SERVICES "\r");  
068C6:  MOVLW  E0
068C8:  MOVWF  3FF6
068CA:  MOVLW  03
068CC:  MOVWF  3FF7
068CE:  MOVLW  00
068D0:  MOVWF  3FF8
068D2:  MOVLB  0
068D4:  RCALL  6348
....................       wait_for_prompt();
068D6:  RCALL  6534
....................       printf(ble_cmd_putc,"SR,1000\r");  
068D8:  MOVLW  E8
068DA:  MOVWF  3FF6
068DC:  MOVLW  03
068DE:  MOVWF  3FF7
068E0:  MOVLW  00
068E2:  MOVWF  3FF8
068E4:  RCALL  6348
....................       wait_for_prompt();
068E6:  RCALL  6534
....................       printf(ble_cmd_putc,"PZ\r");  // Clear Services
068E8:  MOVLW  F2
068EA:  MOVWF  3FF6
068EC:  MOVLW  03
068EE:  MOVWF  3FF7
068F0:  MOVLW  00
068F2:  MOVWF  3FF8
068F4:  RCALL  6348
....................       wait_for_prompt();
068F6:  RCALL  6534
....................       printf(ble_cmd_putc,"S-," BT_MODEL_NAME "\r");
068F8:  MOVLW  F6
068FA:  MOVWF  3FF6
068FC:  MOVLW  03
068FE:  MOVWF  3FF7
06900:  MOVLW  00
06902:  MOVWF  3FF8
06904:  RCALL  6348
....................       wait_for_prompt();
06906:  RCALL  6534
....................  //     printf(ble_cmd_putc,"R,1\r");      // Reset
....................       delay_ms(500);
06908:  MOVLW  02
0690A:  MOVLB  5
0690C:  MOVWF  x60
0690E:  MOVLW  FA
06910:  MOVWF  xA6
06912:  MOVLB  0
06914:  CALL   05EC
06918:  MOVLB  5
0691A:  DECFSZ x60,F
0691C:  BRA    690E
....................       ble_enter_cmd_mode();
0691E:  MOVLB  0
06920:  RCALL  659E
06922:  MOVLB  5
....................    }   
....................         
....................    printf(ble_cmd_putc,"GS\r");   
06924:  MOVLW  06
06926:  MOVWF  3FF6
06928:  MOVLW  04
0692A:  MOVWF  3FF7
0692C:  MOVLW  00
0692E:  MOVWF  3FF8
06930:  MOVLB  0
06932:  RCALL  6348
....................    err=wait_for_prompt();
06934:  RCALL  6534
06936:  MOVLB  5
06938:  BCF    x5F.0
0693A:  BTFSC  01.0
0693C:  BSF    x5F.0
....................    ble_entries=0;
0693E:  MOVLB  0
06940:  CLRF   xE7
....................    ble_clear_cmd_buffer(); 
06942:  RCALL  65CA
....................    ble_set_scan_mode(TRUE);
06944:  MOVLW  01
06946:  MOVLB  5
06948:  MOVWF  xA0
0694A:  MOVLB  0
0694C:  RCALL  67DC
....................    if(!err)
0694E:  MOVLB  5
06950:  BTFSC  x5F.0
06952:  BRA    6968
....................       printf(ble_cmd_putc,"F\r");   // Start scanning
06954:  MOVLW  46
06956:  MOVWF  xA4
06958:  MOVLB  0
0695A:  RCALL  633E
0695C:  MOVLW  0D
0695E:  MOVLB  5
06960:  MOVWF  xA4
06962:  MOVLB  0
06964:  RCALL  633E
06966:  MOVLB  5
.................... //      printf(ble_cmd_putc,"F,%4X,%4X\r",BLE_SCAN_INTERVAL,BLE_SCAN_WINDOW);   // Start scanning
....................    return(err);
06968:  MOVLW  00
0696A:  BTFSC  x5F.0
0696C:  MOVLW  01
0696E:  MOVWF  01
06970:  MOVLB  0
06972:  GOTO   6C14 (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////
.................... //
.................... // ble_rescan() Assumes you are now scanning and will stop the scan 
.................... // and restart it.
.................... //
.................... // The return value is 0 if successful.
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... int1 ble_rescan(void) {
....................    
....................    printf(ble_cmd_putc,"X\r");
....................    delay_ms(100);
....................    ble_set_scan_mode(FALSE);
....................    ble_clear_status();
....................    wait_for_prompt();
....................    ble_entries=0;
....................    ble_clear_cmd_buffer(); 
....................    ble_set_scan_mode(TRUE);
....................    printf(ble_cmd_putc,"F\r");   // Start scanning
.................... //   printf(ble_cmd_putc,"F,%4X,%4X\r",BLE_SCAN_INTERVAL,BLE_SCAN_WINDOW);   // Start scanning
....................    return( 0);
.................... }
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////
.................... //
.................... // ble_connect() connects to a remote device.  The device is specified
.................... // by the index (first entery 0) in the ble_devices table.  After
.................... // connecting this device is put in the client mode.
.................... //
.................... // The return value is 0 if successful.
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... int1 ble_connect(int8 entry) {
....................    char resp[64];
....................    
....................    printf(ble_cmd_putc,"X\r");
*
06ADE:  MOVLW  58
06AE0:  MOVLB  5
06AE2:  MOVWF  xA4
06AE4:  MOVLB  0
06AE6:  RCALL  633E
06AE8:  MOVLW  0D
06AEA:  MOVLB  5
06AEC:  MOVWF  xA4
06AEE:  MOVLB  0
06AF0:  RCALL  633E
....................    delay_ms(500);      //jpc  was 1000
06AF2:  MOVLW  02
06AF4:  MOVLB  5
06AF6:  MOVWF  xA0
06AF8:  MOVLW  FA
06AFA:  MOVWF  xA6
06AFC:  MOVLB  0
06AFE:  CALL   05EC
06B02:  MOVLB  5
06B04:  DECFSZ xA0,F
06B06:  BRA    6AF8
....................    ble_set_scan_mode(FALSE);
06B08:  CLRF   xA0
06B0A:  MOVLB  0
06B0C:  RCALL  67DC
....................    ble_clear_status();
06B0E:  BRA    69FE
....................    if(entry==BLE_LAST_DEVICE)
06B10:  MOVLB  5
06B12:  INCFSZ x5F,W
06B14:  BRA    6B2C
....................       printf(ble_cmd_putc,"C\r");
06B16:  MOVLW  43
06B18:  MOVWF  xA4
06B1A:  MOVLB  0
06B1C:  RCALL  633E
06B1E:  MOVLW  0D
06B20:  MOVLB  5
06B22:  MOVWF  xA4
06B24:  MOVLB  0
06B26:  RCALL  633E
06B28:  BRA    6BA0
06B2A:  MOVLB  5
06B2C:  CLRF   1B
06B2E:  BTFSC  3FD2.7
06B30:  BSF    1B.7
06B32:  BCF    3FD2.7
....................    else
....................       printf(ble_cmd_putc,"C,%s\r",ble_devices[entry].address);
06B34:  MOVLB  8
06B36:  CLRF   x58
06B38:  MOVFF  55F,857
06B3C:  CLRF   x5A
06B3E:  MOVLW  21
06B40:  MOVWF  x59
06B42:  MOVLB  0
06B44:  CALL   00D0
06B48:  BTFSC  1B.7
06B4A:  BSF    3FD2.7
06B4C:  MOVFF  01,5A0
06B50:  MOVLW  10
06B52:  MOVLB  5
06B54:  ADDWF  01,W
06B56:  MOVWF  01
06B58:  MOVLW  00
06B5A:  ADDWFC 02,W
06B5C:  MOVWF  03
06B5E:  MOVF   01,W
06B60:  ADDLW  E8
06B62:  MOVWF  01
06B64:  MOVLW  00
06B66:  ADDWFC 03,F
06B68:  MOVFF  01,5A0
06B6C:  MOVFF  03,5A1
06B70:  MOVLW  43
06B72:  MOVWF  xA4
06B74:  MOVLB  0
06B76:  CALL   633E
06B7A:  MOVLW  2C
06B7C:  MOVLB  5
06B7E:  MOVWF  xA4
06B80:  MOVLB  0
06B82:  CALL   633E
06B86:  MOVFFL 5A1,3FEA
06B8C:  MOVFFL 5A0,3FE9
06B92:  BRA    6A06
06B94:  MOVLW  0D
06B96:  MOVLB  5
06B98:  MOVWF  xA4
06B9A:  MOVLB  0
06B9C:  CALL   633E
....................    do {
....................       if(ble_get_status_resp(resp,10))
06BA0:  MOVLW  05
06BA2:  MOVLB  5
06BA4:  MOVWF  xA1
06BA6:  MOVLW  60
06BA8:  MOVWF  xA0
06BAA:  CLRF   xA3
06BAC:  MOVLW  0A
06BAE:  MOVWF  xA2
06BB0:  MOVLB  0
06BB2:  RCALL  6A36
06BB4:  MOVF   01,F
06BB6:  BZ    6BBE
....................         return(TRUE);      
06BB8:  MOVLW  01
06BBA:  MOVWF  01
06BBC:  BRA    6C08
....................       if((resp[0]=='C')&&(resp[1]=='O')&&(resp[4]=='E')) {  
06BBE:  MOVLB  5
06BC0:  MOVF   x60,W
06BC2:  SUBLW  43
06BC4:  BNZ   6C04
06BC6:  MOVF   x61,W
06BC8:  SUBLW  4F
06BCA:  BNZ   6C04
06BCC:  MOVF   x64,W
06BCE:  SUBLW  45
06BD0:  BNZ   6C04
....................          delay_ms(500);      //jpc  was 1000
06BD2:  MOVLW  02
06BD4:  MOVWF  xA0
06BD6:  MOVLW  FA
06BD8:  MOVWF  xA6
06BDA:  MOVLB  0
06BDC:  CALL   05EC
06BE0:  MOVLB  5
06BE2:  DECFSZ xA0,F
06BE4:  BRA    6BD6
....................     //    fprintf(BLE,"B\r");
....................     //    wait_for_prompt();
....................         printf(ble_cmd_putc,"I\r");
06BE6:  MOVLW  49
06BE8:  MOVWF  xA4
06BEA:  MOVLB  0
06BEC:  CALL   633E
06BF0:  MOVLW  0D
06BF2:  MOVLB  5
06BF4:  MOVWF  xA4
06BF6:  MOVLB  0
06BF8:  CALL   633E
....................        // wait_for_prompt();
....................         return(FALSE);
06BFC:  MOVLW  00
06BFE:  MOVWF  01
06C00:  BRA    6C08
06C02:  MOVLB  5
....................       }
....................    } while(TRUE);
06C04:  MOVLB  0
06C06:  BRA    6BA0
06C08:  GOTO   6CB0 (RETURN)
.................... }
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////
.................... //
.................... // ble_disconnect() simply disconnects froma remote device
.................... //
.................... // The return value is 1 if the RN487x does not respond.
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... int1 ble_disconnect(void) {
....................    fprintf(DEBUG,"Disconnected\r\n");  
....................    printf(ble_cmd_putc,"K,1\r");
....................    return(wait_for_prompt());
.................... }
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////
.................... //
.................... // ble_find_handle() searches for a specific characteristic with a
.................... // specific attribute on the remote device.
.................... //
.................... // Note this version assumes a constant string for the characteristic.
.................... //
.................... // The return value is 0 if there was no match.
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... int16 ble_find_handle(char * characteristic, int8 attrib) {
....................    char * rp;
....................    int8 i;
....................    char line[128];
....................    char attrib_txt[3];
....................    int8 retries;
....................   
....................    ble_clear_cmd_buffer();
....................    sprintf(attrib_txt,"%02X",attrib);
....................    retries=0;
....................    do {
....................       printf(ble_cmd_putc,"LC\r");
....................       do {
....................          ble_get_cmd_resp(line,2);
....................          if(line[0]==0) {
....................             continue;
....................          }
....................          i=0;
....................          while((line[i]!=0)&&(line[i]<' ')) i++;
....................          if(line[i]!=' ') {
....................            continue;
....................          }  
....................          rp=characteristic;
....................          while((line[i]!=0)&&(line[i]<=' ')) i++;
....................          if((line[i]=='E')&&(line[i+1]=='N')) {
....................             break;
....................          }
....................          if(line[i]==0) {
....................               continue;
....................          }
....................          while((line[i]!=',')&&(*rp==line[i])) {
....................             i++;
....................             rp++;
....................          }
....................          if(line[i]==',') {
....................             while((line[++i]!=',')&&(line[++i]!=0)) ;
....................             if((line[i+1]==attrib_txt[0])&&(line[i+2]==attrib_txt[1])) {
....................                return(hex2int4(line[i-4],line[i-3],line[i-2],line[i-1]));
....................             }
....................          }
....................       } while(TRUE);
....................       if(++retries==1) {
....................          ble_clear_cmd_buffer();
....................          printf(ble_cmd_putc,"CI\r");
....................          wait_for_prompt();
....................       }
....................    } while(retries<2);
....................    return(0);
.................... }
.................... 
.................... 
.................... /////////////////////////////////////////////////////////////////////
.................... //
.................... // ble_set_characteristic() writes to a characteristic on the remote
.................... // server device.  It then grabs the notify response, converts it to 
.................... // an ASCII string and returns it in result.  
.................... //
.................... //  Use ble_find_handle() to get the handle for a characteristic.
.................... //
.................... //  The return value is 0 if there were no errors.
.................... /////////////////////////////////////////////////////////////////////
.................... 
.................... int1 ble_set_characteristic(int16 handle, char * outgoing, char * result) {
....................    char buffer[64]; 
....................    char * p;
....................    int8 i;
....................    
....................    ble_clear_cmd_buffer();
....................    p=buffer;
....................    i=0;
....................    while(outgoing[i]!=0) {
....................       sprintf(p,"%02X",outgoing[i]);
....................       i++;
....................       p+=2;
....................    } 
....................    sprintf(p,"00");
....................       
....................    printf(ble_cmd_putc,"CHW,%04X,%s\r",handle,buffer);
....................    do {
....................       ble_get_status_resp(buffer,20);
....................       if(buffer[0]==0) {
....................          *result=0;
....................          return(FALSE);      
....................       }
....................       if((buffer[0]=='N')&&(buffer[1]=='O')) {
....................          i=10;
....................          while(buffer[i]!=0) {
....................             *result=toascii(&buffer+i);
....................             i+=2;
....................             result++;
....................          }
....................          break;
....................       }
....................    }while(TRUE);
....................    return(TRUE);
.................... }
.................... 
.................... 
.................... int1 ble_get_characteristic(int16 handle, char * result) {
....................    char buffer[64]; 
....................    int8 i,retry;
.................... 
....................    retry=0;
....................    do {
....................       ble_clear_cmd_buffer();
....................       printf(ble_cmd_putc,"CHR,%04X\r",handle);
....................       ble_get_cmd_resp(buffer,5);
....................       if(buffer[0]=='E') {
....................         i=0;
....................       } else {
....................          ble_get_cmd_resp(buffer,5);
....................          if(buffer[0]==0) {
....................             *result=0;
....................             return(FALSE);      
....................          }
....................          if(buffer[0]=='C')
....................            i=5;
....................          else
....................            i=0;
....................          while(buffer[i]!=0) {
....................             *result=buffer[i];
....................             i++;
....................             result++;
....................          }
....................          *result=0;
....................       }
....................       if(i>6)
....................          return(TRUE);
....................        delay_ms(500);      //jpc  was 1000
....................    } while(++retry<3);
....................    return(FALSE);
.................... }
.................... 
.................... int16 ble_start(void) {
....................    int8 last_entry;
....................    int16 handle;
....................    int1 connected;
....................    
....................     connected=FALSE;
06C0C:  MOVLB  5
06C0E:  BCF    x59.0
....................     if(ble_start_scan())
06C10:  MOVLB  0
06C12:  BRA    67EE
06C14:  MOVF   01,F
06C16:  BZ    6C34
....................          fprintf(DEBUG,"Error - Scan\r\n");
06C18:  MOVLW  40
06C1A:  MOVWF  3FF6
06C1C:  MOVLW  04
06C1E:  MOVWF  3FF7
06C20:  MOVLW  00
06C22:  MOVWF  3FF8
06C24:  CLRF   1B
06C26:  BTFSC  3FD2.7
06C28:  BSF    1B.7
06C2A:  BCF    3FD2.7
06C2C:  CALL   04D0
06C30:  BTFSC  1B.7
06C32:  BSF    3FD2.7
....................     last_entry=0;           
06C34:  MOVLB  5
06C36:  CLRF   x56
....................     while(!connected) {
06C38:  BTFSC  x59.0
06C3A:  BRA    6CFC
....................        if(ble_entries!=last_entry) {
06C3C:  MOVF   x56,W
06C3E:  MOVLB  0
06C40:  SUBWF  xE7,W
06C42:  BZ    6CF8
06C44:  CLRF   1B
06C46:  BTFSC  3FD2.7
06C48:  BSF    1B.7
06C4A:  BCF    3FD2.7
....................           //fprintf(DEBUG,"Found #%u %s\r\n",last_entry+1,ble_devices[last_entry].name);
....................           if(strcmp(ble_devices[last_entry].name,BT_REMOTE_NAME )==0) {
06C4C:  MOVLB  8
06C4E:  CLRF   x58
06C50:  MOVFF  556,857
06C54:  CLRF   x5A
06C56:  MOVLW  21
06C58:  MOVWF  x59
06C5A:  MOVLB  0
06C5C:  CALL   00D0
06C60:  BTFSC  1B.7
06C62:  BSF    3FD2.7
06C64:  MOVFF  02,560
06C68:  MOVFF  01,55F
06C6C:  MOVLW  E8
06C6E:  MOVLB  5
06C70:  ADDWF  01,W
06C72:  MOVWF  01
06C74:  MOVLW  00
06C76:  ADDWFC 02,W
06C78:  MOVWF  03
06C7A:  MOVFF  01,561
06C7E:  MOVWF  x62
06C80:  MOVLW  48
06C82:  MOVWF  x5A
06C84:  MOVLW  61
06C86:  MOVWF  x5B
06C88:  MOVLW  6C
06C8A:  MOVWF  x5C
06C8C:  MOVLW  6F
06C8E:  MOVWF  x5D
06C90:  CLRF   x5E
06C92:  MOVFF  03,566
06C96:  MOVFF  01,565
06C9A:  MOVLW  05
06C9C:  MOVWF  x68
06C9E:  MOVLW  5A
06CA0:  MOVWF  x67
06CA2:  MOVLB  0
06CA4:  BRA    6976
06CA6:  MOVF   01,F
06CA8:  BNZ   6CF4
....................              if(ble_connect(last_entry)) {
06CAA:  MOVFF  556,55F
06CAE:  BRA    6ADE
06CB0:  MOVF   01,F
06CB2:  BZ    6CD2
....................                 fprintf(DEBUG,"Error Connecting\r\n");
06CB4:  MOVLW  50
06CB6:  MOVWF  3FF6
06CB8:  MOVLW  04
06CBA:  MOVWF  3FF7
06CBC:  MOVLW  00
06CBE:  MOVWF  3FF8
06CC0:  CLRF   1B
06CC2:  BTFSC  3FD2.7
06CC4:  BSF    1B.7
06CC6:  BCF    3FD2.7
06CC8:  CALL   04D0
06CCC:  BTFSC  1B.7
06CCE:  BSF    3FD2.7
....................              } else {
06CD0:  BRA    6CF4
....................                 fprintf(DEBUG,"Connected\r\n");  
06CD2:  MOVLW  64
06CD4:  MOVWF  3FF6
06CD6:  MOVLW  04
06CD8:  MOVWF  3FF7
06CDA:  MOVLW  00
06CDC:  MOVWF  3FF8
06CDE:  CLRF   1B
06CE0:  BTFSC  3FD2.7
06CE2:  BSF    1B.7
06CE4:  BCF    3FD2.7
06CE6:  CALL   04D0
06CEA:  BTFSC  1B.7
06CEC:  BSF    3FD2.7
....................                 connected=TRUE;
06CEE:  MOVLB  5
06CF0:  BSF    x59.0
06CF2:  MOVLB  0
....................                // handle=ble_find_handle(BT_CHARACTERISTIC_1);
....................                // fprintf(DEBUG,"\r\nHandle=%04X\r\n",handle); 
....................                // delay_ms(2000);
....................              }
....................             }
....................           last_entry++;
06CF4:  MOVLB  5
06CF6:  INCF   x56,F
....................        }
06CF8:  MOVLB  5
06CFA:  BRA    6C38
....................     }
....................    if(!connected)
06CFC:  BTFSC  x59.0
06CFE:  BRA    6D04
....................       handle=0;
06D00:  CLRF   x58
06D02:  CLRF   x57
....................    return handle;
06D04:  MOVFF  557,01
06D08:  MOVFF  558,02
06D0C:  MOVLB  0
06D0E:  GOTO   7718 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... typedef enum    //ADC Channels
.................... {
....................     BATT_I = 0,       //battery curent
....................     BATT_V,           //  battery voltage
....................     CHARGER,       //charger voltage
.................... }  ADC_ChannelType;
.................... 
.................... 
.................... typedef enum    //g_Flags foir internal use only
.................... {
....................     TMR1 = 0,   //flag register bit set when timer1 interrupt
....................     SECOND,   //flag register bit set when 1 second has passed
....................     FACTORY,  //flag register bit set when factory programmer attached
....................     CHGR_ON ,    //set when charger is attached
....................     BUTTON_FLG,     //set when a button2 press detected
....................   //  INT_FLG,
.................... }  SystemFlagType;
.................... 
.................... 
.................... typedef enum    //battery charging states
.................... {
....................     INIT_CHARGE = 0,  //initialize chargeer
....................     CC,     //constant current
....................     CV,     //constant voltage
....................     FULL,   //full charge
.................... }   ChargeStageType;
.................... 
.................... 
.................... typedef enum    //machine states while device is AWAKE
.................... {
....................     POST = 0,
....................     CHARGING,
....................     TREAT,      //treatment
....................     POOR_CONTACT,   //poor electrode contact
....................     FAULT,  //fault condition
.................... }  MachineStateType;
.................... 
.................... typedef enum    //electrode c ontact flags for g_Contact_Status
.................... {
....................     LEFT_FLG = 0,   //left mastoid, set when good
....................     FORE_FLG,       // forehead, set when good
....................     RIGHT_FLG,      //right mastoid, set when good
.................... }  ContactType;
.................... 
.................... // Battery charge constants C = 420 mAH
.................... int16_t const PWM_MAX = 412;    //this disables charging
.................... int16_t const PWM_MIN = 30; //this is maximum charging voltage
.................... int16_t const FULL_BATT = 410;
.................... int16_t const END_AMPS = 100;    //C/4 mA)
.................... uint16_t const CC_AMPS = 220l;   // C/2 mA
.................... uint32_t const MAX_TIME = 7200l;    //2 hours in seconds to timeout at at contant voltage mode
.................... uint32_t const CC_TIME = 7200l;     //2 hours in seconds to timeout at at contant current mode
.................... 
.................... //uint8_t const TREATTIME = 40;   //treatment minutes
.................... //uint16_t const PGRM_MEM = 0x7CFF;   //PIC18F45K22 program memory size 32K
.................... uint8_t const  HEAD = 0;
.................... uint8_t const  HAND = 1;
.................... uint8_t const  ON = 1;
.................... uint8_t const  OFF = 0;
.................... 
.................... /**Globals **/
.................... //uint8_t     g_State = POST;
.................... uint8_t     g_Flags;
.................... uint8_t     g_Paired = FALSE;  //not paired 
.................... uint8_t     g_BLE_Logo = 0;  //BLE logo blanked
.................... uint8_t     g_Contact_Status = 0;   //all electrode poor contact
.................... uint8_t     g_mode = OFF;
.................... //uint8_t     g_Setpoint = 4; //initial headset output current in mA
.................... 
.................... uint16_t    g_TreatMinutes = 40;
.................... uint16_t    g_TreatSeconds = 0;
.................... uint16_t    g_Seconds = 2400;   //60 seconds x 40 minutes
.................... 
.................... uint16_t    g_Batt_Volts = 0;     //handset battery voltage
.................... uint16_t    g_Batt_Amps = 0;     //handset battery charge current
.................... uint16_t    g_Head_Batt_Volts = 0;     //headset  battery voltage
.................... uint16_t    g_NoActivity;   //activity counter, turn off device if no activity
.................... uint8_t     g_BLE_Activity = 0; //BLE connection counter
.................... //char g_command;
.................... uint8_t g_Head_Batt_Level;
.................... char resp[32];
.................... 
.................... #include <Handset Main HaloLCD.c>
.................... 
.................... //IO Map
.................... #define RD          PIN_E0      //DO, DISPLAY READ ACTIVE LOW  p25
.................... #define WR          PIN_E1      //DO, DISPLAY WRITE ACTIVE LOW  p26
.................... #define CS          PIN_E2      //DO, DISPLAY SELECT ACTIVE LOW  p27
.................... 
.................... #define CHRGR_ON    PIN_A2      //DI,SET WHEN CHARGER ATTACHED
.................... #define P2_0        PIN_A3      //D0, TEST = 0, APP = 1
.................... //#define ENB_VCC     PIN_A5      //DO, SETCTO ENABLE VCC
.................... //#define LED1        PIN_A6      //DO, SET TO TURN ON PCB LED
.................... 
.................... #define BUTTON       PIN_B0      //DI, ACTIVE LOW BUTTON1 SENSE (On/Off)
.................... //#define BUTTON2      PIN_B1      //DI, ACTIVE LOW BUTTON2 SENSE  (Start/Stop
.................... #define DC           PIN_B2      //DO, 1=DATA, 0=COMMAND  p10
.................... #define TXD         PIN_B3      //DO, DEBUG SERIAL OUT
.................... #define RST         PIN_B4      //DO, 1= RESET DISPLAY
.................... //#define RST_BLE     PIN_B5      //DO, BLE RESET ACTIVE LOW
.................... 
.................... uint8_t const   MIN_TENS =0;
.................... uint8_t const   MIN_ONES =1;
.................... uint8_t const   SEC_TENS =2;
.................... uint8_t const   SEC_ONES =3;
.................... 
.................... uint8_t const   NUM_ZERO = 0;
.................... uint8_t const   NUM_ONE = 1;
.................... uint8_t const   NUM_TWO = 2;
.................... uint8_t const   NUM_THREE = 3;
.................... uint8_t const   NUM_FOUR = 4;
.................... uint8_t const   NUM_FIVE = 5;
.................... uint8_t const   NUM_SIX = 6;
.................... uint8_t const   NUM_SEVEN = 7;
.................... uint8_t const   NUM_EIGHT = 8;
.................... uint8_t const   NUM_NINE = 9;
.................... uint8_t const       POOR = 0;
.................... uint8_t const       GOOD = 1;
.................... uint8_t const       LEFT = 1;
.................... uint8_t const       RIGHT = 0;
.................... uint8_t const DELAY1 = 100; //100ms delay  
.................... 
.................... // Protypes
.................... void    Display_Setup(void);
.................... 
.................... void Draw_Zero(void);
.................... void Draw_One(void);
.................... void Draw_Two(void);
.................... void Draw_Three(void);
.................... void Draw_Four(void);
.................... void Draw_Five(void);
.................... void Draw_Six(void);
.................... void Draw_Seven(void);
.................... void Draw_Eight(void);
.................... void Draw_Nine(void);
.................... void Draw_BLE(void);
.................... //void Draw_Full_Battery(uint8_t BattID);
....................   
.................... /**
....................    Comm_Out(uint8 c)
....................    Write a command byte to display.
.................... **/
.................... void    Comm_Out(uint8_t c)
.................... {
....................     output_high(RD);    //Set at start
*
00614:  BCF    3FC6.0
00616:  BSF    3FBE.0
....................     output_high(WR);    //Set at start 
00618:  BCF    3FC6.1
0061A:  BSF    3FBE.1
....................     output_low(DC);     //clear to send a command
0061C:  BCF    3FC3.2
0061E:  BCF    3FBB.2
....................     output_d(c);        //load value
00620:  CLRF   3FC5
00622:  MOVFFL 854,3FBD
....................     delay_cycles(2);    //short delay
00628:  BRA    062A
....................     output_low(WR);     //start write latch
0062A:  BCF    3FC6.1
0062C:  BCF    3FBE.1
....................     delay_cycles(2);    //short delay
0062E:  BRA    0630
....................     output_high(WR);    //stop write latch 
00630:  BCF    3FC6.1
00632:  BSF    3FBE.1
00634:  RETURN 0
....................  }
.................... 
.................... 
.................... /**
....................    Data_Out(uint8_t c
....................    Write a data byte to display
.................... **/
.................... void    Data_Out(uint8_t c)
.................... {
....................     output_high(RD);    //set at start 
00636:  BCF    3FC6.0
00638:  BSF    3FBE.0
....................     output_high(WR);    //Set at start 
0063A:  BCF    3FC6.1
0063C:  BSF    3FBE.1
....................     output_high(DC);     //set for data 
0063E:  BCF    3FC3.2
00640:  BSF    3FBB.2
....................     output_d(c);        //load value
00642:  CLRF   3FC5
00644:  MOVFFL 854,3FBD
....................     delay_cycles(2);    //short delay
0064A:  BRA    064C
....................     output_low(WR);     //start write latch
0064C:  BCF    3FC6.1
0064E:  BCF    3FBE.1
....................     delay_cycles(2);    //short delay
00650:  BRA    0652
....................     output_high(WR);    //stop write latch 
00652:  BCF    3FC6.1
00654:  BSF    3FBE.1
00656:  RETURN 0
....................  }
.................... 
.................... /**
....................    Data_In(uint8 c)
....................    Read a data byte from display
.................... **/
.................... uint8_t    Data_In(void)
.................... {
....................     uint8_t    c;
....................     
....................     output_high(RD);    //set at start 
....................     output_high(WR);    //Set at start  
....................     output_high(DC);     //set for data 
....................     output_low(RD);     //start read latch
....................     delay_cycles(2);    //short delay   
....................     c=input_d();        //load value
....................     output_high(RD);    //stop read latch 
....................     return c;   //return result
.................... }
....................   
....................   
....................   
.................... /**
....................     Configure the NCD-1.8-128160 TFT display
.................... 
.................... **/
....................  
.................... void    Display_Setup(void)
.................... {
....................   //  uint8_t const DELAY1 = 100; //100ms delay  
....................     
....................     fprintf(DEBUG,"\n\r Start Display Config");
00658:  MOVLW  70
0065A:  MOVWF  3FF6
0065C:  MOVLW  04
0065E:  MOVWF  3FF7
00660:  MOVLW  00
00662:  MOVWF  3FF8
00664:  CLRF   1B
00666:  BTFSC  3FD2.7
00668:  BSF    1B.7
0066A:  BCF    3FD2.7
0066C:  RCALL  04D0
0066E:  BTFSC  1B.7
00670:  BSF    3FD2.7
....................     output_low(CS);         //put display in continuous 8 bit parallel mode 
00672:  BCF    3FC6.2
00674:  BCF    3FBE.2
....................     output_high(RD);        //read mode not selected
00676:  BCF    3FC6.0
00678:  BSF    3FBE.0
....................     output_high(WR);        //write mode not selected
0067A:  BCF    3FC6.1
0067C:  BSF    3FBE.1
....................     output_high(RST);       //release hard reset
0067E:  BCF    3FC3.4
00680:  BSF    3FBB.4
....................     delay_ms(DELAY1);
00682:  MOVLW  64
00684:  MOVLB  5
00686:  MOVWF  xA6
00688:  MOVLB  0
0068A:  RCALL  05EC
....................  
....................     Comm_Out(0x11);       //exit sleep mode
0068C:  MOVLW  11
0068E:  MOVLB  8
00690:  MOVWF  x54
00692:  MOVLB  0
00694:  RCALL  0614
....................     delay_ms(DELAY1);
00696:  MOVLW  64
00698:  MOVLB  5
0069A:  MOVWF  xA6
0069C:  MOVLB  0
0069E:  RCALL  05EC
....................     
....................     Comm_Out(0x28);       //set display off
006A0:  MOVLW  28
006A2:  MOVLB  8
006A4:  MOVWF  x54
006A6:  MOVLB  0
006A8:  RCALL  0614
....................     delay_ms(DELAY1);
006AA:  MOVLW  64
006AC:  MOVLB  5
006AE:  MOVWF  xA6
006B0:  MOVLB  0
006B2:  RCALL  05EC
.................... 
....................     Comm_Out(0x26);      //select gamma curve
006B4:  MOVLW  26
006B6:  MOVLB  8
006B8:  MOVWF  x54
006BA:  MOVLB  0
006BC:  RCALL  0614
....................     Data_Out(0x04);
006BE:  MOVLW  04
006C0:  MOVLB  8
006C2:  MOVWF  x54
006C4:  MOVLB  0
006C6:  RCALL  0636
....................     
....................     Comm_Out(0xF2);      //select F2
006C8:  MOVLW  F2
006CA:  MOVLB  8
006CC:  MOVWF  x54
006CE:  MOVLB  0
006D0:  RCALL  0614
....................     Data_Out(0x00);   
006D2:  MOVLB  8
006D4:  CLRF   x54
006D6:  MOVLB  0
006D8:  RCALL  0636
....................     
....................     Comm_Out(0xB1);      //frame rate control
006DA:  MOVLW  B1
006DC:  MOVLB  8
006DE:  MOVWF  x54
006E0:  MOVLB  0
006E2:  RCALL  0614
....................     Data_Out(0x0A);
006E4:  MOVLW  0A
006E6:  MOVLB  8
006E8:  MOVWF  x54
006EA:  MOVLB  0
006EC:  RCALL  0636
....................     Data_Out(0x14);
006EE:  MOVLW  14
006F0:  MOVLB  8
006F2:  MOVWF  x54
006F4:  MOVLB  0
006F6:  RCALL  0636
....................   
....................     Comm_Out(0xC0);     //power control 1
006F8:  MOVLW  C0
006FA:  MOVLB  8
006FC:  MOVWF  x54
006FE:  MOVLB  0
00700:  RCALL  0614
....................     Data_Out(0x0A); 
00702:  MOVLW  0A
00704:  MOVLB  8
00706:  MOVWF  x54
00708:  MOVLB  0
0070A:  RCALL  0636
....................     Data_Out(0x00);
0070C:  MOVLB  8
0070E:  CLRF   x54
00710:  MOVLB  0
00712:  RCALL  0636
....................   
....................     Comm_Out(0xC1);     //power control 2
00714:  MOVLW  C1
00716:  MOVLB  8
00718:  MOVWF  x54
0071A:  MOVLB  0
0071C:  RCALL  0614
....................     Data_Out(0x02);
0071E:  MOVLW  02
00720:  MOVLB  8
00722:  MOVWF  x54
00724:  MOVLB  0
00726:  RCALL  0636
....................   
....................     Comm_Out(0xC5);     //VCOM control 1
00728:  MOVLW  C5
0072A:  MOVLB  8
0072C:  MOVWF  x54
0072E:  MOVLB  0
00730:  RCALL  0614
....................     Data_Out(0x2F); 
00732:  MOVLW  2F
00734:  MOVLB  8
00736:  MOVWF  x54
00738:  MOVLB  0
0073A:  RCALL  0636
....................     Data_Out(0x3E);
0073C:  MOVLW  3E
0073E:  MOVLB  8
00740:  MOVWF  x54
00742:  MOVLB  0
00744:  RCALL  0636
....................   
....................     Comm_Out(0xC7);     //VCOM offset control
00746:  MOVLW  C7
00748:  MOVLB  8
0074A:  MOVWF  x54
0074C:  MOVLB  0
0074E:  RCALL  0614
....................     Data_Out(0x40);
00750:  MOVLW  40
00752:  MOVLB  8
00754:  MOVWF  x54
00756:  MOVLB  0
00758:  RCALL  0636
....................   
....................     Comm_Out(0x2A);    //column address set
0075A:  MOVLW  2A
0075C:  MOVLB  8
0075E:  MOVWF  x54
00760:  MOVLB  0
00762:  RCALL  0614
....................     Data_Out(0x00);                  
00764:  MOVLB  8
00766:  CLRF   x54
00768:  MOVLB  0
0076A:  RCALL  0636
....................     Data_Out(0x00);     //start 0x0000
0076C:  MOVLB  8
0076E:  CLRF   x54
00770:  MOVLB  0
00772:  RCALL  0636
....................     Data_Out(0x00);
00774:  MOVLB  8
00776:  CLRF   x54
00778:  MOVLB  0
0077A:  RCALL  0636
....................     Data_Out(0x7F);     //end 0x007F (0-127)
0077C:  MOVLW  7F
0077E:  MOVLB  8
00780:  MOVWF  x54
00782:  MOVLB  0
00784:  RCALL  0636
....................   
....................     Comm_Out(0x2B);     //page address set
00786:  MOVLW  2B
00788:  MOVLB  8
0078A:  MOVWF  x54
0078C:  MOVLB  0
0078E:  RCALL  0614
....................     Data_Out(0x00);                  
00790:  MOVLB  8
00792:  CLRF   x54
00794:  MOVLB  0
00796:  RCALL  0636
....................     Data_Out(0x00);     //start 0x0000
00798:  MOVLB  8
0079A:  CLRF   x54
0079C:  MOVLB  0
0079E:  RCALL  0636
....................     Data_Out(0x00);
007A0:  MOVLB  8
007A2:  CLRF   x54
007A4:  MOVLB  0
007A6:  RCALL  0636
....................     Data_Out(0x9F);     //end 0x009F  (0-159)
007A8:  MOVLW  9F
007AA:  MOVLB  8
007AC:  MOVWF  x54
007AE:  MOVLB  0
007B0:  RCALL  0636
....................   
....................     Comm_Out(0x36);     //memory access control
007B2:  MOVLW  36
007B4:  MOVLB  8
007B6:  MOVWF  x54
007B8:  MOVLB  0
007BA:  RCALL  0614
....................     Data_Out(0xC8);
007BC:  MOVLW  C8
007BE:  MOVLB  8
007C0:  MOVWF  x54
007C2:  MOVLB  0
007C4:  RCALL  0636
....................   
....................     Comm_Out(0x3A);    //pixel format = 18 bit per pixel
007C6:  MOVLW  3A
007C8:  MOVLB  8
007CA:  MOVWF  x54
007CC:  MOVLB  0
007CE:  RCALL  0614
....................     Data_Out(0x06);                  
007D0:  MOVLW  06
007D2:  MOVLB  8
007D4:  MOVWF  x54
007D6:  MOVLB  0
007D8:  RCALL  0636
....................     
....................     Comm_Out(0x29);      //display ON
007DA:  MOVLW  29
007DC:  MOVLB  8
007DE:  MOVWF  x54
007E0:  MOVLB  0
007E2:  RCALL  0614
....................     delay_ms(DELAY1);
007E4:  MOVLW  64
007E6:  MOVLB  5
007E8:  MOVWF  xA6
007EA:  MOVLB  0
007EC:  RCALL  05EC
....................     
....................     Comm_Out(0x2C);      //write memory start
007EE:  MOVLW  2C
007F0:  MOVLB  8
007F2:  MOVWF  x54
007F4:  MOVLB  0
007F6:  RCALL  0614
....................     delay_ms(DELAY1);    
007F8:  MOVLW  64
007FA:  MOVLB  5
007FC:  MOVWF  xA6
007FE:  MOVLB  0
00800:  RCALL  05EC
....................   
....................     fprintf(DEBUG,"\n\r End Display Config"); 
00802:  MOVLW  88
00804:  MOVWF  3FF6
00806:  MOVLW  04
00808:  MOVWF  3FF7
0080A:  MOVLW  00
0080C:  MOVWF  3FF8
0080E:  CLRF   1B
00810:  BTFSC  3FD2.7
00812:  BSF    1B.7
00814:  BCF    3FD2.7
00816:  RCALL  04D0
00818:  BTFSC  1B.7
0081A:  BSF    3FD2.7
0081C:  GOTO   7624 (RETURN)
....................  }
....................  
....................  
....................  void Set_Column_Address(int8_t a, int8_t b, int8_t c, int8_t d)
.................... {
....................     Comm_Out(0x2A);
*
00D50:  MOVLW  2A
00D52:  MOVLB  8
00D54:  MOVWF  x54
00D56:  MOVLB  0
00D58:  RCALL  0614
....................     Data_Out(a);Data_Out(b);
00D5A:  MOVFF  850,854
00D5E:  RCALL  0636
00D60:  MOVFF  851,854
00D64:  RCALL  0636
....................     Data_Out(c);Data_Out(d);
00D66:  MOVFF  852,854
00D6A:  RCALL  0636
00D6C:  MOVFF  853,854
00D70:  RCALL  0636
00D72:  RETURN 0
.................... }
.................... 
.................... 
.................... void Set_Page_Address(int8_t a, int8_t b, int8_t c, int8_t d)
.................... {
....................     Comm_Out(0x2B);
00D74:  MOVLW  2B
00D76:  MOVLB  8
00D78:  MOVWF  x54
00D7A:  MOVLB  0
00D7C:  RCALL  0614
....................     Data_Out(a);Data_Out(b);
00D7E:  MOVFF  850,854
00D82:  RCALL  0636
00D84:  MOVFF  851,854
00D88:  RCALL  0636
....................     Data_Out(c);Data_Out(d);
00D8A:  MOVFF  852,854
00D8E:  RCALL  0636
00D90:  MOVFF  853,854
00D94:  RCALL  0636
00D96:  RETURN 0
.................... }
.................... 
....................  
.................... /**
....................     Turn on all pixesl in red, green and blue then black
....................  
....................  **/
....................  void Display(void)
.................... {
....................     uint16_t i;
.................... 
....................     Comm_Out(0x2C);     //comamnd to write to frame memory
*
00820:  MOVLW  2C
00822:  MOVLB  8
00824:  MOVWF  x54
00826:  MOVLB  0
00828:  RCALL  0614
....................     
....................     for(i=0; i<20480; i++)   //for each pixel
0082A:  MOVLB  5
0082C:  CLRF   x57
0082E:  CLRF   x56
00830:  MOVF   x57,W
00832:  SUBLW  4F
00834:  BNC   0858
....................     {
....................         Data_Out(0xFF);     //all red pixels    
00836:  MOVLB  8
00838:  SETF   x54
0083A:  MOVLB  0
0083C:  RCALL  0636
....................         Data_Out(0x00);     //    
0083E:  MOVLB  8
00840:  CLRF   x54
00842:  MOVLB  0
00844:  RCALL  0636
....................         Data_Out(0x00);     //   
00846:  MOVLB  8
00848:  CLRF   x54
0084A:  MOVLB  0
0084C:  RCALL  0636
0084E:  MOVLB  5
00850:  INCF   x56,F
00852:  BTFSC  3FD8.2
00854:  INCF   x57,F
00856:  BRA    0830
....................     }
....................     
....................      for(i=0; i<20480; i++)   //for each pixel
00858:  CLRF   x57
0085A:  CLRF   x56
0085C:  MOVF   x57,W
0085E:  SUBLW  4F
00860:  BNC   0884
....................     {
....................         Data_Out(0x00);     //   
00862:  MOVLB  8
00864:  CLRF   x54
00866:  MOVLB  0
00868:  RCALL  0636
....................         Data_Out(0xFF);     // all  
0086A:  MOVLB  8
0086C:  SETF   x54
0086E:  MOVLB  0
00870:  RCALL  0636
....................         Data_Out(0x00);     // 
00872:  MOVLB  8
00874:  CLRF   x54
00876:  MOVLB  0
00878:  RCALL  0636
0087A:  MOVLB  5
0087C:  INCF   x56,F
0087E:  BTFSC  3FD8.2
00880:  INCF   x57,F
00882:  BRA    085C
....................           
....................     }
....................     
....................      for(i=0; i<20480; i++)   //for each pixel
00884:  CLRF   x57
00886:  CLRF   x56
00888:  MOVF   x57,W
0088A:  SUBLW  4F
0088C:  BNC   08B0
....................     {
....................         Data_Out(0x00);     //   
0088E:  MOVLB  8
00890:  CLRF   x54
00892:  MOVLB  0
00894:  RCALL  0636
....................         Data_Out(0x00);     //   
00896:  MOVLB  8
00898:  CLRF   x54
0089A:  MOVLB  0
0089C:  RCALL  0636
....................         Data_Out(0xFF);     // all blue   
0089E:  MOVLB  8
008A0:  SETF   x54
008A2:  MOVLB  0
008A4:  RCALL  0636
008A6:  MOVLB  5
008A8:  INCF   x56,F
008AA:  BTFSC  3FD8.2
008AC:  INCF   x57,F
008AE:  BRA    0888
....................     
....................     }
....................     
....................        for(i=0; i<20480; i++)   //for each pixel
008B0:  CLRF   x57
008B2:  CLRF   x56
008B4:  MOVF   x57,W
008B6:  SUBLW  4F
008B8:  BNC   08DC
....................     {
....................         Data_Out(0x00);     //   
008BA:  MOVLB  8
008BC:  CLRF   x54
008BE:  MOVLB  0
008C0:  RCALL  0636
....................         Data_Out(0x00);     //   
008C2:  MOVLB  8
008C4:  CLRF   x54
008C6:  MOVLB  0
008C8:  RCALL  0636
....................         Data_Out(0x00);     // all black
008CA:  MOVLB  8
008CC:  CLRF   x54
008CE:  MOVLB  0
008D0:  RCALL  0636
008D2:  MOVLB  5
008D4:  INCF   x56,F
008D6:  BTFSC  3FD8.2
008D8:  INCF   x57,F
008DA:  BRA    08B4
....................     }
008DC:  MOVLB  0
008DE:  GOTO   7628 (RETURN)
.................... }
.................... 
.................... /**
....................     Start location in display memory
.................... **/
.................... void Write_Memory_Start(void)
.................... {
....................     Comm_Out(0x2C);
*
00D98:  MOVLW  2C
00D9A:  MOVLB  8
00D9C:  MOVWF  x54
00D9E:  MOVLB  0
00DA0:  RCALL  0614
00DA2:  RETURN 0
.................... }
.................... 
.................... 
.................... /**
....................     Draw a white circle using 64 5x5 blocks
.................... **/
.................... void    Draw_Colon(void)
*
06236:  MOVLW  40
06238:  MOVLB  5
0623A:  MOVWF  x57
0623C:  MOVLW  3C
0623E:  MOVWF  x58
.................... {
....................     uint8_t n;
....................     uint8_t  X_CENTER = 64;    //column(X) value for center
....................     uint8_t  Y_CENTER = 60;    //row (Y) value for center
....................     
.................... /**    Set_Column_Address(0,X_CENTER,0,X_CENTER); //X coordinate
....................     Set_Page_Address(0,Y_CENTER,0,Y_CENTER);    //y coordinate
....................     Write_Memory_Start();
....................   
....................     Data_Out(0xFF);
....................     Data_Out(0xFF);
....................     Data_Out(0xFF);   
.................... **/
....................     Y_CENTER = 55;    //upper colon block
06240:  MOVLW  37
06242:  MOVWF  x58
....................     Set_Column_Address(0,X_CENTER-1,0,X_CENTER+1); //X coordinate
06244:  MOVLW  01
06246:  SUBWF  x57,W
06248:  MOVWF  x59
0624A:  MOVLW  01
0624C:  ADDWF  x57,W
0624E:  MOVWF  x5A
06250:  MOVLB  8
06252:  CLRF   x50
06254:  MOVFF  559,851
06258:  CLRF   x52
0625A:  MOVWF  x53
0625C:  MOVLB  0
0625E:  CALL   0D50
....................     Set_Page_Address(0,Y_CENTER-1,0,Y_CENTER+1);    //y coordinate
06262:  MOVLW  01
06264:  MOVLB  5
06266:  SUBWF  x58,W
06268:  MOVWF  x59
0626A:  MOVLW  01
0626C:  ADDWF  x58,W
0626E:  MOVWF  x5A
06270:  MOVLB  8
06272:  CLRF   x50
06274:  MOVFF  559,851
06278:  CLRF   x52
0627A:  MOVWF  x53
0627C:  MOVLB  0
0627E:  CALL   0D74
....................     Write_Memory_Start();
06282:  CALL   0D98
....................     for(n=0; n<9; n++) //draw a block
06286:  MOVLB  5
06288:  CLRF   x56
0628A:  MOVF   x56,W
0628C:  SUBLW  08
0628E:  BNC   62B4
....................     {
....................         Data_Out(0xFF);
06290:  MOVLB  8
06292:  SETF   x54
06294:  MOVLB  0
06296:  CALL   0636
....................         Data_Out(0xFF);
0629A:  MOVLB  8
0629C:  SETF   x54
0629E:  MOVLB  0
062A0:  CALL   0636
....................         Data_Out(0xFF);
062A4:  MOVLB  8
062A6:  SETF   x54
062A8:  MOVLB  0
062AA:  CALL   0636
062AE:  MOVLB  5
062B0:  INCF   x56,F
062B2:  BRA    628A
....................     }   
.................... 
.................... 
....................     Y_CENTER = 65;    //lower colon block 
062B4:  MOVLW  41
062B6:  MOVWF  x58
....................     Set_Column_Address(0,X_CENTER-1,0,X_CENTER+1); //X coordinate
062B8:  MOVLW  01
062BA:  SUBWF  x57,W
062BC:  MOVWF  x59
062BE:  MOVLW  01
062C0:  ADDWF  x57,W
062C2:  MOVWF  x5A
062C4:  MOVLB  8
062C6:  CLRF   x50
062C8:  MOVFF  559,851
062CC:  CLRF   x52
062CE:  MOVWF  x53
062D0:  MOVLB  0
062D2:  CALL   0D50
....................     Set_Page_Address(0,Y_CENTER-1,0,Y_CENTER+1);    //y coordinate
062D6:  MOVLW  01
062D8:  MOVLB  5
062DA:  SUBWF  x58,W
062DC:  MOVWF  x59
062DE:  MOVLW  01
062E0:  ADDWF  x58,W
062E2:  MOVWF  x5A
062E4:  MOVLB  8
062E6:  CLRF   x50
062E8:  MOVFF  559,851
062EC:  CLRF   x52
062EE:  MOVWF  x53
062F0:  MOVLB  0
062F2:  CALL   0D74
....................     Write_Memory_Start();
062F6:  CALL   0D98
....................     for(n=0; n<9; n++) //draw a block
062FA:  MOVLB  5
062FC:  CLRF   x56
062FE:  MOVF   x56,W
06300:  SUBLW  08
06302:  BNC   6328
....................     {
....................         Data_Out(0xFF);
06304:  MOVLB  8
06306:  SETF   x54
06308:  MOVLB  0
0630A:  CALL   0636
....................         Data_Out(0xFF);
0630E:  MOVLB  8
06310:  SETF   x54
06312:  MOVLB  0
06314:  CALL   0636
....................         Data_Out(0xFF);
06318:  MOVLB  8
0631A:  SETF   x54
0631C:  MOVLB  0
0631E:  CALL   0636
06322:  MOVLB  5
06324:  INCF   x56,F
06326:  BRA    62FE
....................     }   
06328:  MOVLB  0
0632A:  GOTO   63CE (RETURN)
.................... }
.................... 
.................... /**
....................     Draw a digit at the location
.................... **/
.................... void    Draw_Digit(uint8_t Location, uint8_t Value)
.................... {
....................     uint8_t x,y;
....................    
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................     
....................     switch(Location)        //identify center of the time digit
*
05712:  MOVLB  5
05714:  MOVF   x5A,W
05716:  ADDLW  FC
05718:  BC    5754
0571A:  ADDLW  04
0571C:  MOVLB  0
0571E:  GOTO   57F8
....................     {
....................         case MIN_TENS:  //tens digit of minutes
....................             x=  X_CENTER - 30;
05722:  MOVLW  22
05724:  MOVLB  5
05726:  MOVWF  x5C
....................             y = Y_CENTER;
05728:  MOVLW  3C
0572A:  MOVWF  x5D
....................             break;
0572C:  BRA    5754
....................             
....................        case MIN_ONES:   //ones digit of minutes
....................             x=  X_CENTER - 12;
0572E:  MOVLW  34
05730:  MOVLB  5
05732:  MOVWF  x5C
....................             y = Y_CENTER;       
05734:  MOVLW  3C
05736:  MOVWF  x5D
....................             break;
05738:  BRA    5754
....................             
....................        case SEC_TENS:   //tens digit of seconds
....................             x=  X_CENTER + 12;
0573A:  MOVLW  4C
0573C:  MOVLB  5
0573E:  MOVWF  x5C
....................             y = Y_CENTER;       
05740:  MOVLW  3C
05742:  MOVWF  x5D
....................             break;
05744:  BRA    5754
....................     
....................        case SEC_ONES:       //oness digit of seconds
....................             x=  X_CENTER + 30;
05746:  MOVLW  5E
05748:  MOVLB  5
0574A:  MOVWF  x5C
....................             y = Y_CENTER;              
0574C:  MOVLW  3C
0574E:  MOVWF  x5D
....................             break;    
05750:  BRA    5754
05752:  MOVLB  5
....................     }
....................     
....................     Set_Column_Address(0,(x-7),0,(x+7)); //X coordinate
05754:  MOVLW  07
05756:  SUBWF  x5C,W
05758:  MOVWF  x5E
0575A:  MOVLW  07
0575C:  ADDWF  x5C,W
0575E:  MOVWF  x5F
05760:  MOVLB  8
05762:  CLRF   x50
05764:  MOVFF  55E,851
05768:  CLRF   x52
0576A:  MOVWF  x53
0576C:  MOVLB  0
0576E:  CALL   0D50
....................     Set_Page_Address(0,(y-12),0,(y+12));    //y coordinate
05772:  MOVLW  0C
05774:  MOVLB  5
05776:  SUBWF  x5D,W
05778:  MOVWF  x5E
0577A:  MOVLW  0C
0577C:  ADDWF  x5D,W
0577E:  MOVWF  x5F
05780:  MOVLB  8
05782:  CLRF   x50
05784:  MOVFF  55E,851
05788:  CLRF   x52
0578A:  MOVWF  x53
0578C:  MOVLB  0
0578E:  CALL   0D74
....................     Write_Memory_Start();
05792:  CALL   0D98
....................      
....................     switch(Value)   //now draw the number in the time foield
05796:  MOVLB  5
05798:  MOVF   x5B,W
0579A:  ADDLW  F6
0579C:  BC    57F4
0579E:  ADDLW  0A
057A0:  MOVLB  0
057A2:  GOTO   5820
....................     {
....................         Case NUM_ZERO:
....................             Draw_Zero();
057A6:  GOTO   3502
....................             break;
057AA:  MOVLB  5
057AC:  BRA    57F4
....................             
....................         case NUM_ONE:
....................             Draw_One();
057AE:  GOTO   386A
....................             break;
057B2:  MOVLB  5
057B4:  BRA    57F4
.................... 
....................         Case NUM_TWO:
....................             Draw_Two();
057B6:  GOTO   3BD2
....................             break;
057BA:  MOVLB  5
057BC:  BRA    57F4
....................             
....................         case NUM_THREE:
....................             Draw_Three();
057BE:  GOTO   3F3A
....................             break ;           
057C2:  MOVLB  5
057C4:  BRA    57F4
.................... 
....................          Case NUM_FOUR:
....................             Draw_Four();
057C6:  GOTO   42A2
....................             break;
057CA:  MOVLB  5
057CC:  BRA    57F4
....................             
....................         case NUM_FIVE:
....................             Draw_Five();
057CE:  GOTO   460A
....................             break;       
057D2:  MOVLB  5
057D4:  BRA    57F4
.................... 
....................          Case NUM_SIX:
....................             Draw_Six();
057D6:  GOTO   4972
....................             break;
057DA:  MOVLB  5
057DC:  BRA    57F4
....................             
....................         case NUM_SEVEN:
....................            Draw_Seven();
057DE:  GOTO   4CDA
....................             break;       
057E2:  MOVLB  5
057E4:  BRA    57F4
....................  
....................         Case NUM_EIGHT:
....................             Draw_Eight();
057E6:  BRA    5042
....................             break;
057E8:  MOVLB  5
057EA:  BRA    57F4
....................             
....................         case NUM_NINE:
....................             Draw_Nine();
057EC:  BRA    53AA
....................             break;       
057EE:  MOVLB  5
057F0:  BRA    57F4
057F2:  MOVLB  5
....................     }
057F4:  MOVLB  0
057F6:  RETURN 0
....................  } 
....................     
.................... 
.................... 
.................... /**
....................     Draw a blue circle using  5x5 blocks. If Degrees = 64 then full circle
....................     
.................... **/
.................... void    Draw_Circle(void)
.................... {
....................     int8_t n,i,x,y;
....................     int8_t  const X_CENTER = 64;    //column(X) value for center
....................     int8_t  const Y_CENTER = 60;    //row (Y) value for center
....................     int8_t  Circle1[64][2]= {
....................         {50,0},
....................         {50,5},
....................         {49,10},
....................         {48,15},
....................         {46,19},
....................         {44,24},
....................        {41,28},
....................        {38,32},
....................        {35,36},
....................        {31,39},
....................        {27,42},
....................        {23,45},
....................        {18,47},
....................        {13,48},
....................        {8,49},
....................        {4,50},
....................        {-1,50},
....................        {-6,50},
....................        {-11,49},
....................        {-16,47},
....................        { -21,45},
....................        {-25,43},
....................        {-29,40},
....................        {-33,37},
....................        {-37,34},
....................        {-40,30},
....................        {-43,26},
....................        {-45,21},
....................        {-47,17},
....................        {-49,12},
....................        {-49,7},
....................        {-50,2},
....................        {-50,-3},
....................       {-49,-8},
....................       {-48,-13},
....................       {-47,-18},
....................       {-45,-22},
....................       {-42,-26},
....................       {-40,-31},
....................       {-36,-34},
....................       {-33,-38},
....................       {-29,-41},
....................       {-25,-44},
....................       {-20,-46},
....................       {-15,-48},
....................       {-11,-49},
....................       {-6,-50},
....................       {-1,-50},
....................       {4,-50},
....................       {9,-49},
....................       {14,-48},
....................       {19,-46},
....................       {23,-44},
....................       {28,-42},
....................       {32,-39},
....................       {35,-35},
....................       {39,-32},
....................       {42,-28},
....................       {44,-23},
....................       {46,-19},
....................       {48,-14},
....................       {49,-9},
....................       {50,-4},
....................       {50,1}
....................    }; 
*
01FB4:  MOVLW  32
01FB6:  MOVLB  5
01FB8:  MOVWF  x5A
01FBA:  CLRF   x5B
01FBC:  MOVWF  x5C
01FBE:  MOVLW  05
01FC0:  MOVWF  x5D
01FC2:  MOVLW  31
01FC4:  MOVWF  x5E
01FC6:  MOVLW  0A
01FC8:  MOVWF  x5F
01FCA:  MOVLW  30
01FCC:  MOVWF  x60
01FCE:  MOVLW  0F
01FD0:  MOVWF  x61
01FD2:  MOVLW  2E
01FD4:  MOVWF  x62
01FD6:  MOVLW  13
01FD8:  MOVWF  x63
01FDA:  MOVLW  2C
01FDC:  MOVWF  x64
01FDE:  MOVLW  18
01FE0:  MOVWF  x65
01FE2:  MOVLW  29
01FE4:  MOVWF  x66
01FE6:  MOVLW  1C
01FE8:  MOVWF  x67
01FEA:  MOVLW  26
01FEC:  MOVWF  x68
01FEE:  MOVLW  20
01FF0:  MOVWF  x69
01FF2:  MOVLW  23
01FF4:  MOVWF  x6A
01FF6:  MOVLW  24
01FF8:  MOVWF  x6B
01FFA:  MOVLW  1F
01FFC:  MOVWF  x6C
01FFE:  MOVLW  27
02000:  MOVWF  x6D
02002:  MOVLW  1B
02004:  MOVWF  x6E
02006:  MOVLW  2A
02008:  MOVWF  x6F
0200A:  MOVLW  17
0200C:  MOVWF  x70
0200E:  MOVLW  2D
02010:  MOVWF  x71
02012:  MOVLW  12
02014:  MOVWF  x72
02016:  MOVLW  2F
02018:  MOVWF  x73
0201A:  MOVLW  0D
0201C:  MOVWF  x74
0201E:  MOVLW  30
02020:  MOVWF  x75
02022:  MOVLW  08
02024:  MOVWF  x76
02026:  MOVLW  31
02028:  MOVWF  x77
0202A:  MOVLW  04
0202C:  MOVWF  x78
0202E:  MOVLW  32
02030:  MOVWF  x79
02032:  SETF   x7A
02034:  MOVWF  x7B
02036:  MOVLW  FA
02038:  MOVWF  x7C
0203A:  MOVLW  32
0203C:  MOVWF  x7D
0203E:  MOVLW  F5
02040:  MOVWF  x7E
02042:  MOVLW  31
02044:  MOVWF  x7F
02046:  MOVLW  F0
02048:  MOVWF  x80
0204A:  MOVLW  2F
0204C:  MOVWF  x81
0204E:  MOVLW  EB
02050:  MOVWF  x82
02052:  MOVLW  2D
02054:  MOVWF  x83
02056:  MOVLW  E7
02058:  MOVWF  x84
0205A:  MOVLW  2B
0205C:  MOVWF  x85
0205E:  MOVLW  E3
02060:  MOVWF  x86
02062:  MOVLW  28
02064:  MOVWF  x87
02066:  MOVLW  DF
02068:  MOVWF  x88
0206A:  MOVLW  25
0206C:  MOVWF  x89
0206E:  MOVLW  DB
02070:  MOVWF  x8A
02072:  MOVLW  22
02074:  MOVWF  x8B
02076:  MOVLW  D8
02078:  MOVWF  x8C
0207A:  MOVLW  1E
0207C:  MOVWF  x8D
0207E:  MOVLW  D5
02080:  MOVWF  x8E
02082:  MOVLW  1A
02084:  MOVWF  x8F
02086:  MOVLW  D3
02088:  MOVWF  x90
0208A:  MOVLW  15
0208C:  MOVWF  x91
0208E:  MOVLW  D1
02090:  MOVWF  x92
02092:  MOVLW  11
02094:  MOVWF  x93
02096:  MOVLW  CF
02098:  MOVWF  x94
0209A:  MOVLW  0C
0209C:  MOVWF  x95
0209E:  MOVLW  CF
020A0:  MOVWF  x96
020A2:  MOVLW  07
020A4:  MOVWF  x97
020A6:  MOVLW  CE
020A8:  MOVWF  x98
020AA:  MOVLW  02
020AC:  MOVWF  x99
020AE:  MOVLW  CE
020B0:  MOVWF  x9A
020B2:  MOVLW  FD
020B4:  MOVWF  x9B
020B6:  MOVLW  CF
020B8:  MOVWF  x9C
020BA:  MOVLW  F8
020BC:  MOVWF  x9D
020BE:  MOVLW  D0
020C0:  MOVWF  x9E
020C2:  MOVLW  F3
020C4:  MOVWF  x9F
020C6:  MOVLW  D1
020C8:  MOVWF  xA0
020CA:  MOVLW  EE
020CC:  MOVWF  xA1
020CE:  MOVLW  D3
020D0:  MOVWF  xA2
020D2:  MOVLW  EA
020D4:  MOVWF  xA3
020D6:  MOVLW  D6
020D8:  MOVWF  xA4
020DA:  MOVLW  E6
020DC:  MOVWF  xA5
020DE:  MOVLW  D8
020E0:  MOVWF  xA6
020E2:  MOVLW  E1
020E4:  MOVWF  xA7
020E6:  MOVLW  DC
020E8:  MOVWF  xA8
020EA:  MOVLW  DE
020EC:  MOVWF  xA9
020EE:  MOVLW  DF
020F0:  MOVWF  xAA
020F2:  MOVLW  DA
020F4:  MOVWF  xAB
020F6:  MOVLW  E3
020F8:  MOVWF  xAC
020FA:  MOVLW  D7
020FC:  MOVWF  xAD
020FE:  MOVLW  E7
02100:  MOVWF  xAE
02102:  MOVLW  D4
02104:  MOVWF  xAF
02106:  MOVLW  EC
02108:  MOVWF  xB0
0210A:  MOVLW  D2
0210C:  MOVWF  xB1
0210E:  MOVLW  F1
02110:  MOVWF  xB2
02112:  MOVLW  D0
02114:  MOVWF  xB3
02116:  MOVLW  F5
02118:  MOVWF  xB4
0211A:  MOVLW  CF
0211C:  MOVWF  xB5
0211E:  MOVLW  FA
02120:  MOVWF  xB6
02122:  MOVLW  CE
02124:  MOVWF  xB7
02126:  SETF   xB8
02128:  MOVWF  xB9
0212A:  MOVLW  04
0212C:  MOVWF  xBA
0212E:  MOVLW  CE
02130:  MOVWF  xBB
02132:  MOVLW  09
02134:  MOVWF  xBC
02136:  MOVLW  CF
02138:  MOVWF  xBD
0213A:  MOVLW  0E
0213C:  MOVWF  xBE
0213E:  MOVLW  D0
02140:  MOVWF  xBF
02142:  MOVLW  13
02144:  MOVWF  xC0
02146:  MOVLW  D2
02148:  MOVWF  xC1
0214A:  MOVLW  17
0214C:  MOVWF  xC2
0214E:  MOVLW  D4
02150:  MOVWF  xC3
02152:  MOVLW  1C
02154:  MOVWF  xC4
02156:  MOVLW  D6
02158:  MOVWF  xC5
0215A:  MOVLW  20
0215C:  MOVWF  xC6
0215E:  MOVLW  D9
02160:  MOVWF  xC7
02162:  MOVLW  23
02164:  MOVWF  xC8
02166:  MOVLW  DD
02168:  MOVWF  xC9
0216A:  MOVLW  27
0216C:  MOVWF  xCA
0216E:  MOVLW  E0
02170:  MOVWF  xCB
02172:  MOVLW  2A
02174:  MOVWF  xCC
02176:  MOVLW  E4
02178:  MOVWF  xCD
0217A:  MOVLW  2C
0217C:  MOVWF  xCE
0217E:  MOVLW  E9
02180:  MOVWF  xCF
02182:  MOVLW  2E
02184:  MOVWF  xD0
02186:  MOVLW  ED
02188:  MOVWF  xD1
0218A:  MOVLW  30
0218C:  MOVWF  xD2
0218E:  MOVLW  F2
02190:  MOVWF  xD3
02192:  MOVLW  31
02194:  MOVWF  xD4
02196:  MOVLW  F7
02198:  MOVWF  xD5
0219A:  MOVLW  32
0219C:  MOVWF  xD6
0219E:  MOVLW  FC
021A0:  MOVWF  xD7
021A2:  MOVLW  32
021A4:  MOVWF  xD8
021A6:  MOVLW  01
021A8:  MOVWF  xD9
....................       
....................     
....................    for(i=0; i<64; i++)
021AA:  CLRF   x57
021AC:  BTFSC  x57.7
021AE:  BRA    21B6
021B0:  MOVF   x57,W
021B2:  SUBLW  3F
021B4:  BNC   2296
....................    {
....................         x= Circle1[i][0]; //new column coordinate
021B6:  MOVFF  557,5DA
021BA:  MOVLW  02
021BC:  MOVWF  xDB
021BE:  MOVLB  0
021C0:  RCALL  1F66
021C2:  MOVF   01,W
021C4:  MOVLB  5
021C6:  CLRF   xDB
021C8:  MOVWF  xDA
021CA:  BTFSC  3FE8.7
021CC:  DECF   xDB,F
021CE:  MOVLW  5A
021D0:  ADDWF  xDA,W
021D2:  MOVWF  3FE9
021D4:  MOVLW  05
021D6:  ADDWFC xDB,W
021D8:  MOVWF  3FEA
021DA:  MOVFFL 3FEF,558
....................         y= Circle1[i][1];   //new pagecoordinate
021E0:  MOVFF  557,5DA
021E4:  MOVLW  02
021E6:  MOVWF  xDB
021E8:  MOVLB  0
021EA:  RCALL  1F66
021EC:  MOVF   01,W
021EE:  MOVLB  5
021F0:  CLRF   xDB
021F2:  MOVWF  xDA
021F4:  BTFSC  3FE8.7
021F6:  DECF   xDB,F
021F8:  MOVLW  01
021FA:  ADDWF  xDA,W
021FC:  MOVWF  01
021FE:  MOVLW  00
02200:  ADDWFC xDB,W
02202:  MOVWF  03
02204:  MOVF   01,W
02206:  ADDLW  5A
02208:  MOVWF  3FE9
0220A:  MOVLW  05
0220C:  ADDWFC 03,W
0220E:  MOVWF  3FEA
02210:  MOVFFL 3FEF,559
....................         
....................         Set_Column_Address(0,(X_CENTER+x-2),0,(X_CENTER+x+2)); //X coordinate
02216:  MOVLW  40
02218:  ADDWF  x58,W
0221A:  ADDLW  FE
0221C:  MOVWF  xDA
0221E:  MOVLW  40
02220:  ADDWF  x58,W
02222:  ADDLW  02
02224:  MOVWF  xDB
02226:  MOVLB  8
02228:  CLRF   x50
0222A:  MOVFF  5DA,851
0222E:  CLRF   x52
02230:  MOVWF  x53
02232:  MOVLB  0
02234:  CALL   0D50
....................         Set_Page_Address(0,(Y_CENTER+y-2),0,(Y_CENTER+y+2));    //y coordinate
02238:  MOVLW  3C
0223A:  MOVLB  5
0223C:  ADDWF  x59,W
0223E:  ADDLW  FE
02240:  MOVWF  xDA
02242:  MOVLW  3C
02244:  ADDWF  x59,W
02246:  ADDLW  02
02248:  MOVWF  xDB
0224A:  MOVLB  8
0224C:  CLRF   x50
0224E:  MOVFF  5DA,851
02252:  CLRF   x52
02254:  MOVWF  x53
02256:  MOVLB  0
02258:  CALL   0D74
....................     //    Set_Column_Address(0,(X_CENTER+x-1),0,(X_CENTER+x+1)); //X coordinate
....................     //    Set_Page_Address(0,(Y_CENTER+y-1),0,(Y_CENTER+y+1));    //y coordinate
....................         Write_Memory_Start();
0225C:  CALL   0D98
....................         
....................         for(n=0; n<9; n++) //draw a block
02260:  MOVLB  5
02262:  CLRF   x56
02264:  BTFSC  x56.7
02266:  BRA    226E
02268:  MOVF   x56,W
0226A:  SUBLW  08
0226C:  BNC   2292
....................         {
....................             Data_Out(0x00);
0226E:  MOVLB  8
02270:  CLRF   x54
02272:  MOVLB  0
02274:  CALL   0636
....................             Data_Out(0xFF);
02278:  MOVLB  8
0227A:  SETF   x54
0227C:  MOVLB  0
0227E:  CALL   0636
....................             Data_Out(0xFF);
02282:  MOVLB  8
02284:  SETF   x54
02286:  MOVLB  0
02288:  CALL   0636
0228C:  MOVLB  5
0228E:  INCF   x56,F
02290:  BRA    2264
....................         }
02292:  INCF   x57,F
02294:  BRA    21AC
....................     } 
02296:  MOVLB  0
02298:  GOTO   29A6 (RETURN)
.................... }
.................... 
.................... 
.................... /**
....................     Draw a 0 digit
.................... **/
.................... void    Draw_Zero(void)
.................... {
....................     uint16_t    n;
....................     
....................     uint8_t Zero[375]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,
....................     0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
*
03502:  MOVLB  5
03504:  CLRF   x60
03506:  CLRF   x61
03508:  CLRF   x62
0350A:  CLRF   x63
0350C:  CLRF   x64
0350E:  CLRF   x65
03510:  CLRF   x66
03512:  CLRF   x67
03514:  CLRF   x68
03516:  CLRF   x69
03518:  CLRF   x6A
0351A:  CLRF   x6B
0351C:  CLRF   x6C
0351E:  CLRF   x6D
03520:  CLRF   x6E
03522:  CLRF   x6F
03524:  CLRF   x70
03526:  CLRF   x71
03528:  CLRF   x72
0352A:  CLRF   x73
0352C:  MOVLW  01
0352E:  MOVWF  x74
03530:  MOVWF  x75
03532:  MOVWF  x76
03534:  MOVWF  x77
03536:  MOVWF  x78
03538:  CLRF   x79
0353A:  CLRF   x7A
0353C:  CLRF   x7B
0353E:  CLRF   x7C
03540:  CLRF   x7D
03542:  CLRF   x7E
03544:  CLRF   x7F
03546:  CLRF   x80
03548:  MOVWF  x81
0354A:  MOVWF  x82
0354C:  MOVWF  x83
0354E:  MOVWF  x84
03550:  MOVWF  x85
03552:  MOVWF  x86
03554:  MOVWF  x87
03556:  MOVWF  x88
03558:  CLRF   x89
0355A:  CLRF   x8A
0355C:  CLRF   x8B
0355E:  CLRF   x8C
03560:  CLRF   x8D
03562:  CLRF   x8E
03564:  MOVWF  x8F
03566:  MOVWF  x90
03568:  MOVWF  x91
0356A:  MOVWF  x92
0356C:  MOVWF  x93
0356E:  MOVWF  x94
03570:  MOVWF  x95
03572:  MOVWF  x96
03574:  MOVWF  x97
03576:  MOVWF  x98
03578:  CLRF   x99
0357A:  CLRF   x9A
0357C:  CLRF   x9B
0357E:  CLRF   x9C
03580:  MOVWF  x9D
03582:  MOVWF  x9E
03584:  MOVWF  x9F
03586:  CLRF   xA0
03588:  CLRF   xA1
0358A:  CLRF   xA2
0358C:  CLRF   xA3
0358E:  CLRF   xA4
03590:  CLRF   xA5
03592:  MOVWF  xA6
03594:  MOVWF  xA7
03596:  MOVWF  xA8
03598:  CLRF   xA9
0359A:  CLRF   xAA
0359C:  CLRF   xAB
0359E:  MOVWF  xAC
035A0:  MOVWF  xAD
035A2:  MOVWF  xAE
035A4:  CLRF   xAF
035A6:  CLRF   xB0
035A8:  CLRF   xB1
035AA:  CLRF   xB2
035AC:  CLRF   xB3
035AE:  CLRF   xB4
035B0:  CLRF   xB5
035B2:  MOVWF  xB6
035B4:  MOVWF  xB7
035B6:  MOVWF  xB8
035B8:  CLRF   xB9
035BA:  CLRF   xBA
035BC:  MOVWF  xBB
035BE:  MOVWF  xBC
035C0:  MOVWF  xBD
035C2:  CLRF   xBE
035C4:  CLRF   xBF
035C6:  CLRF   xC0
035C8:  CLRF   xC1
035CA:  CLRF   xC2
035CC:  CLRF   xC3
035CE:  CLRF   xC4
035D0:  MOVWF  xC5
035D2:  MOVWF  xC6
035D4:  MOVWF  xC7
035D6:  CLRF   xC8
035D8:  CLRF   xC9
035DA:  MOVWF  xCA
035DC:  MOVWF  xCB
035DE:  MOVWF  xCC
035E0:  CLRF   xCD
035E2:  CLRF   xCE
035E4:  CLRF   xCF
035E6:  CLRF   xD0
035E8:  CLRF   xD1
035EA:  CLRF   xD2
035EC:  CLRF   xD3
035EE:  MOVWF  xD4
035F0:  MOVWF  xD5
035F2:  MOVWF  xD6
035F4:  CLRF   xD7
035F6:  CLRF   xD8
035F8:  MOVWF  xD9
035FA:  MOVWF  xDA
035FC:  MOVWF  xDB
035FE:  CLRF   xDC
03600:  CLRF   xDD
03602:  CLRF   xDE
03604:  CLRF   xDF
03606:  CLRF   xE0
03608:  CLRF   xE1
0360A:  CLRF   xE2
0360C:  MOVWF  xE3
0360E:  MOVWF  xE4
03610:  MOVWF  xE5
03612:  CLRF   xE6
03614:  CLRF   xE7
03616:  MOVWF  xE8
03618:  MOVWF  xE9
0361A:  MOVWF  xEA
0361C:  CLRF   xEB
0361E:  CLRF   xEC
03620:  CLRF   xED
03622:  CLRF   xEE
03624:  CLRF   xEF
03626:  CLRF   xF0
03628:  CLRF   xF1
0362A:  MOVWF  xF2
0362C:  MOVWF  xF3
0362E:  MOVWF  xF4
03630:  CLRF   xF5
03632:  CLRF   xF6
03634:  MOVWF  xF7
03636:  MOVWF  xF8
03638:  MOVWF  xF9
0363A:  CLRF   xFA
0363C:  CLRF   xFB
0363E:  CLRF   xFC
03640:  CLRF   xFD
03642:  CLRF   xFE
03644:  CLRF   xFF
03646:  MOVLB  6
03648:  CLRF   x00
0364A:  MOVWF  x01
0364C:  MOVWF  x02
0364E:  MOVWF  x03
03650:  CLRF   x04
03652:  CLRF   x05
03654:  MOVWF  x06
03656:  MOVWF  x07
03658:  MOVWF  x08
0365A:  CLRF   x09
0365C:  CLRF   x0A
0365E:  CLRF   x0B
03660:  CLRF   x0C
03662:  CLRF   x0D
03664:  CLRF   x0E
03666:  CLRF   x0F
03668:  MOVWF  x10
0366A:  MOVWF  x11
0366C:  MOVWF  x12
0366E:  CLRF   x13
03670:  CLRF   x14
03672:  MOVWF  x15
03674:  MOVWF  x16
03676:  MOVWF  x17
03678:  CLRF   x18
0367A:  CLRF   x19
0367C:  CLRF   x1A
0367E:  CLRF   x1B
03680:  CLRF   x1C
03682:  CLRF   x1D
03684:  CLRF   x1E
03686:  MOVWF  x1F
03688:  MOVWF  x20
0368A:  MOVWF  x21
0368C:  CLRF   x22
0368E:  CLRF   x23
03690:  MOVWF  x24
03692:  MOVWF  x25
03694:  MOVWF  x26
03696:  CLRF   x27
03698:  CLRF   x28
0369A:  CLRF   x29
0369C:  CLRF   x2A
0369E:  CLRF   x2B
036A0:  CLRF   x2C
036A2:  CLRF   x2D
036A4:  MOVWF  x2E
036A6:  MOVWF  x2F
036A8:  MOVWF  x30
036AA:  CLRF   x31
036AC:  CLRF   x32
036AE:  MOVWF  x33
036B0:  MOVWF  x34
036B2:  MOVWF  x35
036B4:  CLRF   x36
036B6:  CLRF   x37
036B8:  CLRF   x38
036BA:  CLRF   x39
036BC:  CLRF   x3A
036BE:  CLRF   x3B
036C0:  CLRF   x3C
036C2:  MOVWF  x3D
036C4:  MOVWF  x3E
036C6:  MOVWF  x3F
036C8:  CLRF   x40
036CA:  CLRF   x41
036CC:  MOVWF  x42
036CE:  MOVWF  x43
036D0:  MOVWF  x44
036D2:  CLRF   x45
036D4:  CLRF   x46
036D6:  CLRF   x47
036D8:  CLRF   x48
036DA:  CLRF   x49
036DC:  CLRF   x4A
036DE:  CLRF   x4B
036E0:  MOVWF  x4C
036E2:  MOVWF  x4D
036E4:  MOVWF  x4E
036E6:  CLRF   x4F
036E8:  CLRF   x50
036EA:  MOVWF  x51
036EC:  MOVWF  x52
036EE:  MOVWF  x53
036F0:  CLRF   x54
036F2:  CLRF   x55
036F4:  CLRF   x56
036F6:  CLRF   x57
036F8:  CLRF   x58
036FA:  CLRF   x59
036FC:  CLRF   x5A
036FE:  MOVWF  x5B
03700:  MOVWF  x5C
03702:  MOVWF  x5D
03704:  CLRF   x5E
03706:  CLRF   x5F
03708:  MOVWF  x60
0370A:  MOVWF  x61
0370C:  MOVWF  x62
0370E:  CLRF   x63
03710:  CLRF   x64
03712:  CLRF   x65
03714:  CLRF   x66
03716:  CLRF   x67
03718:  CLRF   x68
0371A:  CLRF   x69
0371C:  MOVWF  x6A
0371E:  MOVWF  x6B
03720:  MOVWF  x6C
03722:  CLRF   x6D
03724:  CLRF   x6E
03726:  MOVWF  x6F
03728:  MOVWF  x70
0372A:  MOVWF  x71
0372C:  CLRF   x72
0372E:  CLRF   x73
03730:  CLRF   x74
03732:  CLRF   x75
03734:  CLRF   x76
03736:  CLRF   x77
03738:  CLRF   x78
0373A:  MOVWF  x79
0373C:  MOVWF  x7A
0373E:  MOVWF  x7B
03740:  CLRF   x7C
03742:  CLRF   x7D
03744:  MOVWF  x7E
03746:  MOVWF  x7F
03748:  MOVWF  x80
0374A:  CLRF   x81
0374C:  CLRF   x82
0374E:  CLRF   x83
03750:  CLRF   x84
03752:  CLRF   x85
03754:  CLRF   x86
03756:  CLRF   x87
03758:  MOVWF  x88
0375A:  MOVWF  x89
0375C:  MOVWF  x8A
0375E:  CLRF   x8B
03760:  CLRF   x8C
03762:  MOVWF  x8D
03764:  MOVWF  x8E
03766:  MOVWF  x8F
03768:  CLRF   x90
0376A:  CLRF   x91
0376C:  CLRF   x92
0376E:  CLRF   x93
03770:  CLRF   x94
03772:  CLRF   x95
03774:  MOVWF  x96
03776:  MOVWF  x97
03778:  MOVWF  x98
0377A:  CLRF   x99
0377C:  CLRF   x9A
0377E:  CLRF   x9B
03780:  CLRF   x9C
03782:  MOVWF  x9D
03784:  MOVWF  x9E
03786:  MOVWF  x9F
03788:  MOVWF  xA0
0378A:  MOVWF  xA1
0378C:  MOVWF  xA2
0378E:  MOVWF  xA3
03790:  MOVWF  xA4
03792:  MOVWF  xA5
03794:  MOVWF  xA6
03796:  CLRF   xA7
03798:  CLRF   xA8
0379A:  CLRF   xA9
0379C:  CLRF   xAA
0379E:  CLRF   xAB
037A0:  CLRF   xAC
037A2:  MOVWF  xAD
037A4:  MOVWF  xAE
037A6:  MOVWF  xAF
037A8:  MOVWF  xB0
037AA:  MOVWF  xB1
037AC:  MOVWF  xB2
037AE:  MOVWF  xB3
037B0:  MOVWF  xB4
037B2:  CLRF   xB5
037B4:  CLRF   xB6
037B6:  CLRF   xB7
037B8:  CLRF   xB8
037BA:  CLRF   xB9
037BC:  CLRF   xBA
037BE:  CLRF   xBB
037C0:  CLRF   xBC
037C2:  CLRF   xBD
037C4:  MOVWF  xBE
037C6:  MOVWF  xBF
037C8:  MOVWF  xC0
037CA:  MOVWF  xC1
037CC:  MOVWF  xC2
037CE:  CLRF   xC3
037D0:  CLRF   xC4
037D2:  CLRF   xC5
037D4:  CLRF   xC6
037D6:  CLRF   xC7
037D8:  CLRF   xC8
037DA:  CLRF   xC9
037DC:  CLRF   xCA
037DE:  CLRF   xCB
037E0:  CLRF   xCC
037E2:  CLRF   xCD
037E4:  CLRF   xCE
037E6:  CLRF   xCF
037E8:  CLRF   xD0
037EA:  CLRF   xD1
037EC:  CLRF   xD2
037EE:  CLRF   xD3
037F0:  CLRF   xD4
037F2:  CLRF   xD5
037F4:  CLRF   xD6
.................... 
....................     for(n=0; n<375; n++) //draw a block
037F6:  MOVLB  5
037F8:  CLRF   x5F
037FA:  CLRF   x5E
037FC:  MOVF   x5F,W
037FE:  SUBLW  01
03800:  BNC   3864
03802:  BNZ   380A
03804:  MOVF   x5E,W
03806:  SUBLW  76
03808:  BNC   3864
....................     {
....................        if(Zero[n] == 1)
0380A:  MOVLW  60
0380C:  ADDWF  x5E,W
0380E:  MOVWF  3FE9
03810:  MOVLW  05
03812:  ADDWFC x5F,W
03814:  MOVWF  3FEA
03816:  DECFSZ 3FEF,W
03818:  BRA    383C
....................        {
....................             Data_Out(0xFF);
0381A:  MOVLB  8
0381C:  SETF   x54
0381E:  MOVLB  0
03820:  CALL   0636
....................             Data_Out(0xFF);
03824:  MOVLB  8
03826:  SETF   x54
03828:  MOVLB  0
0382A:  CALL   0636
....................             Data_Out(0xFF);
0382E:  MOVLB  8
03830:  SETF   x54
03832:  MOVLB  0
03834:  CALL   0636
....................        }
03838:  BRA    385A
0383A:  MOVLB  5
....................        else
....................        {
....................             Data_Out(0x00);
0383C:  MOVLB  8
0383E:  CLRF   x54
03840:  MOVLB  0
03842:  CALL   0636
....................             Data_Out(0x00);
03846:  MOVLB  8
03848:  CLRF   x54
0384A:  MOVLB  0
0384C:  CALL   0636
....................             Data_Out(0x00);
03850:  MOVLB  8
03852:  CLRF   x54
03854:  MOVLB  0
03856:  CALL   0636
....................        }
0385A:  MOVLB  5
0385C:  INCF   x5E,F
0385E:  BTFSC  3FD8.2
03860:  INCF   x5F,F
03862:  BRA    37FC
....................        
....................     } 
03864:  MOVLB  0
03866:  GOTO   57AA (RETURN)
.................... }
.................... 
.................... 
.................... /**
....................     Draw a 1 digit
.................... **/
.................... void    Draw_One(void)
.................... {
....................     uint16_t    n;
....................     uint8_t One[375]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,
....................     0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,
....................     0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,
....................     0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,
....................     0,0,1,1,1,1,0,1,1,1,0,0,0,0,0,
....................     0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
0386A:  MOVLB  5
0386C:  CLRF   x60
0386E:  CLRF   x61
03870:  CLRF   x62
03872:  CLRF   x63
03874:  CLRF   x64
03876:  CLRF   x65
03878:  CLRF   x66
0387A:  CLRF   x67
0387C:  CLRF   x68
0387E:  CLRF   x69
03880:  CLRF   x6A
03882:  CLRF   x6B
03884:  CLRF   x6C
03886:  CLRF   x6D
03888:  CLRF   x6E
0388A:  CLRF   x6F
0388C:  CLRF   x70
0388E:  CLRF   x71
03890:  CLRF   x72
03892:  CLRF   x73
03894:  CLRF   x74
03896:  CLRF   x75
03898:  CLRF   x76
0389A:  MOVLW  01
0389C:  MOVWF  x77
0389E:  MOVWF  x78
038A0:  CLRF   x79
038A2:  CLRF   x7A
038A4:  CLRF   x7B
038A6:  CLRF   x7C
038A8:  CLRF   x7D
038AA:  CLRF   x7E
038AC:  CLRF   x7F
038AE:  CLRF   x80
038B0:  CLRF   x81
038B2:  CLRF   x82
038B4:  CLRF   x83
038B6:  CLRF   x84
038B8:  MOVWF  x85
038BA:  MOVWF  x86
038BC:  MOVWF  x87
038BE:  CLRF   x88
038C0:  CLRF   x89
038C2:  CLRF   x8A
038C4:  CLRF   x8B
038C6:  CLRF   x8C
038C8:  CLRF   x8D
038CA:  CLRF   x8E
038CC:  CLRF   x8F
038CE:  CLRF   x90
038D0:  CLRF   x91
038D2:  CLRF   x92
038D4:  MOVWF  x93
038D6:  MOVWF  x94
038D8:  MOVWF  x95
038DA:  MOVWF  x96
038DC:  CLRF   x97
038DE:  CLRF   x98
038E0:  CLRF   x99
038E2:  CLRF   x9A
038E4:  CLRF   x9B
038E6:  CLRF   x9C
038E8:  CLRF   x9D
038EA:  CLRF   x9E
038EC:  CLRF   x9F
038EE:  CLRF   xA0
038F0:  MOVWF  xA1
038F2:  MOVWF  xA2
038F4:  MOVWF  xA3
038F6:  MOVWF  xA4
038F8:  MOVWF  xA5
038FA:  CLRF   xA6
038FC:  CLRF   xA7
038FE:  CLRF   xA8
03900:  CLRF   xA9
03902:  CLRF   xAA
03904:  CLRF   xAB
03906:  CLRF   xAC
03908:  CLRF   xAD
0390A:  CLRF   xAE
0390C:  MOVWF  xAF
0390E:  MOVWF  xB0
03910:  MOVWF  xB1
03912:  MOVWF  xB2
03914:  MOVWF  xB3
03916:  MOVWF  xB4
03918:  CLRF   xB5
0391A:  CLRF   xB6
0391C:  CLRF   xB7
0391E:  CLRF   xB8
03920:  CLRF   xB9
03922:  CLRF   xBA
03924:  CLRF   xBB
03926:  CLRF   xBC
03928:  MOVWF  xBD
0392A:  MOVWF  xBE
0392C:  MOVWF  xBF
0392E:  MOVWF  xC0
03930:  MOVWF  xC1
03932:  MOVWF  xC2
03934:  MOVWF  xC3
03936:  CLRF   xC4
03938:  CLRF   xC5
0393A:  CLRF   xC6
0393C:  CLRF   xC7
0393E:  CLRF   xC8
03940:  CLRF   xC9
03942:  CLRF   xCA
03944:  MOVWF  xCB
03946:  MOVWF  xCC
03948:  MOVWF  xCD
0394A:  MOVWF  xCE
0394C:  MOVWF  xCF
0394E:  MOVWF  xD0
03950:  MOVWF  xD1
03952:  MOVWF  xD2
03954:  CLRF   xD3
03956:  CLRF   xD4
03958:  CLRF   xD5
0395A:  CLRF   xD6
0395C:  CLRF   xD7
0395E:  CLRF   xD8
03960:  CLRF   xD9
03962:  MOVWF  xDA
03964:  MOVWF  xDB
03966:  MOVWF  xDC
03968:  MOVWF  xDD
0396A:  CLRF   xDE
0396C:  MOVWF  xDF
0396E:  MOVWF  xE0
03970:  MOVWF  xE1
03972:  CLRF   xE2
03974:  CLRF   xE3
03976:  CLRF   xE4
03978:  CLRF   xE5
0397A:  CLRF   xE6
0397C:  CLRF   xE7
0397E:  CLRF   xE8
03980:  MOVWF  xE9
03982:  MOVWF  xEA
03984:  MOVWF  xEB
03986:  CLRF   xEC
03988:  CLRF   xED
0398A:  MOVWF  xEE
0398C:  MOVWF  xEF
0398E:  MOVWF  xF0
03990:  CLRF   xF1
03992:  CLRF   xF2
03994:  CLRF   xF3
03996:  CLRF   xF4
03998:  CLRF   xF5
0399A:  CLRF   xF6
0399C:  CLRF   xF7
0399E:  CLRF   xF8
039A0:  CLRF   xF9
039A2:  CLRF   xFA
039A4:  CLRF   xFB
039A6:  CLRF   xFC
039A8:  MOVWF  xFD
039AA:  MOVWF  xFE
039AC:  MOVWF  xFF
039AE:  MOVLB  6
039B0:  CLRF   x00
039B2:  CLRF   x01
039B4:  CLRF   x02
039B6:  CLRF   x03
039B8:  CLRF   x04
039BA:  CLRF   x05
039BC:  CLRF   x06
039BE:  CLRF   x07
039C0:  CLRF   x08
039C2:  CLRF   x09
039C4:  CLRF   x0A
039C6:  CLRF   x0B
039C8:  MOVWF  x0C
039CA:  MOVWF  x0D
039CC:  MOVWF  x0E
039CE:  CLRF   x0F
039D0:  CLRF   x10
039D2:  CLRF   x11
039D4:  CLRF   x12
039D6:  CLRF   x13
039D8:  CLRF   x14
039DA:  CLRF   x15
039DC:  CLRF   x16
039DE:  CLRF   x17
039E0:  CLRF   x18
039E2:  CLRF   x19
039E4:  CLRF   x1A
039E6:  MOVWF  x1B
039E8:  MOVWF  x1C
039EA:  MOVWF  x1D
039EC:  CLRF   x1E
039EE:  CLRF   x1F
039F0:  CLRF   x20
039F2:  CLRF   x21
039F4:  CLRF   x22
039F6:  CLRF   x23
039F8:  CLRF   x24
039FA:  CLRF   x25
039FC:  CLRF   x26
039FE:  CLRF   x27
03A00:  CLRF   x28
03A02:  CLRF   x29
03A04:  MOVWF  x2A
03A06:  MOVWF  x2B
03A08:  MOVWF  x2C
03A0A:  CLRF   x2D
03A0C:  CLRF   x2E
03A0E:  CLRF   x2F
03A10:  CLRF   x30
03A12:  CLRF   x31
03A14:  CLRF   x32
03A16:  CLRF   x33
03A18:  CLRF   x34
03A1A:  CLRF   x35
03A1C:  CLRF   x36
03A1E:  CLRF   x37
03A20:  CLRF   x38
03A22:  MOVWF  x39
03A24:  MOVWF  x3A
03A26:  MOVWF  x3B
03A28:  CLRF   x3C
03A2A:  CLRF   x3D
03A2C:  CLRF   x3E
03A2E:  CLRF   x3F
03A30:  CLRF   x40
03A32:  CLRF   x41
03A34:  CLRF   x42
03A36:  CLRF   x43
03A38:  CLRF   x44
03A3A:  CLRF   x45
03A3C:  CLRF   x46
03A3E:  CLRF   x47
03A40:  MOVWF  x48
03A42:  MOVWF  x49
03A44:  MOVWF  x4A
03A46:  CLRF   x4B
03A48:  CLRF   x4C
03A4A:  CLRF   x4D
03A4C:  CLRF   x4E
03A4E:  CLRF   x4F
03A50:  CLRF   x50
03A52:  CLRF   x51
03A54:  CLRF   x52
03A56:  CLRF   x53
03A58:  CLRF   x54
03A5A:  CLRF   x55
03A5C:  CLRF   x56
03A5E:  MOVWF  x57
03A60:  MOVWF  x58
03A62:  MOVWF  x59
03A64:  CLRF   x5A
03A66:  CLRF   x5B
03A68:  CLRF   x5C
03A6A:  CLRF   x5D
03A6C:  CLRF   x5E
03A6E:  CLRF   x5F
03A70:  CLRF   x60
03A72:  CLRF   x61
03A74:  CLRF   x62
03A76:  CLRF   x63
03A78:  CLRF   x64
03A7A:  CLRF   x65
03A7C:  MOVWF  x66
03A7E:  MOVWF  x67
03A80:  MOVWF  x68
03A82:  CLRF   x69
03A84:  CLRF   x6A
03A86:  CLRF   x6B
03A88:  CLRF   x6C
03A8A:  CLRF   x6D
03A8C:  CLRF   x6E
03A8E:  CLRF   x6F
03A90:  CLRF   x70
03A92:  CLRF   x71
03A94:  CLRF   x72
03A96:  CLRF   x73
03A98:  CLRF   x74
03A9A:  MOVWF  x75
03A9C:  MOVWF  x76
03A9E:  MOVWF  x77
03AA0:  CLRF   x78
03AA2:  CLRF   x79
03AA4:  CLRF   x7A
03AA6:  CLRF   x7B
03AA8:  CLRF   x7C
03AAA:  CLRF   x7D
03AAC:  CLRF   x7E
03AAE:  CLRF   x7F
03AB0:  CLRF   x80
03AB2:  CLRF   x81
03AB4:  CLRF   x82
03AB6:  CLRF   x83
03AB8:  MOVWF  x84
03ABA:  MOVWF  x85
03ABC:  MOVWF  x86
03ABE:  CLRF   x87
03AC0:  CLRF   x88
03AC2:  CLRF   x89
03AC4:  CLRF   x8A
03AC6:  CLRF   x8B
03AC8:  CLRF   x8C
03ACA:  CLRF   x8D
03ACC:  CLRF   x8E
03ACE:  CLRF   x8F
03AD0:  CLRF   x90
03AD2:  CLRF   x91
03AD4:  CLRF   x92
03AD6:  MOVWF  x93
03AD8:  MOVWF  x94
03ADA:  MOVWF  x95
03ADC:  CLRF   x96
03ADE:  CLRF   x97
03AE0:  CLRF   x98
03AE2:  CLRF   x99
03AE4:  CLRF   x9A
03AE6:  CLRF   x9B
03AE8:  CLRF   x9C
03AEA:  CLRF   x9D
03AEC:  CLRF   x9E
03AEE:  CLRF   x9F
03AF0:  CLRF   xA0
03AF2:  CLRF   xA1
03AF4:  MOVWF  xA2
03AF6:  MOVWF  xA3
03AF8:  MOVWF  xA4
03AFA:  CLRF   xA5
03AFC:  CLRF   xA6
03AFE:  CLRF   xA7
03B00:  CLRF   xA8
03B02:  CLRF   xA9
03B04:  CLRF   xAA
03B06:  CLRF   xAB
03B08:  CLRF   xAC
03B0A:  CLRF   xAD
03B0C:  CLRF   xAE
03B0E:  CLRF   xAF
03B10:  CLRF   xB0
03B12:  MOVWF  xB1
03B14:  MOVWF  xB2
03B16:  MOVWF  xB3
03B18:  CLRF   xB4
03B1A:  CLRF   xB5
03B1C:  CLRF   xB6
03B1E:  CLRF   xB7
03B20:  CLRF   xB8
03B22:  CLRF   xB9
03B24:  CLRF   xBA
03B26:  CLRF   xBB
03B28:  CLRF   xBC
03B2A:  CLRF   xBD
03B2C:  CLRF   xBE
03B2E:  CLRF   xBF
03B30:  MOVWF  xC0
03B32:  MOVWF  xC1
03B34:  MOVWF  xC2
03B36:  CLRF   xC3
03B38:  CLRF   xC4
03B3A:  CLRF   xC5
03B3C:  CLRF   xC6
03B3E:  CLRF   xC7
03B40:  CLRF   xC8
03B42:  CLRF   xC9
03B44:  CLRF   xCA
03B46:  CLRF   xCB
03B48:  CLRF   xCC
03B4A:  CLRF   xCD
03B4C:  CLRF   xCE
03B4E:  CLRF   xCF
03B50:  CLRF   xD0
03B52:  CLRF   xD1
03B54:  CLRF   xD2
03B56:  CLRF   xD3
03B58:  CLRF   xD4
03B5A:  CLRF   xD5
03B5C:  CLRF   xD6
....................   
....................    for(n=0; n<375; n++) //draw a block
03B5E:  MOVLB  5
03B60:  CLRF   x5F
03B62:  CLRF   x5E
03B64:  MOVF   x5F,W
03B66:  SUBLW  01
03B68:  BNC   3BCC
03B6A:  BNZ   3B72
03B6C:  MOVF   x5E,W
03B6E:  SUBLW  76
03B70:  BNC   3BCC
....................     {
....................        if(One[n] == 1)
03B72:  MOVLW  60
03B74:  ADDWF  x5E,W
03B76:  MOVWF  3FE9
03B78:  MOVLW  05
03B7A:  ADDWFC x5F,W
03B7C:  MOVWF  3FEA
03B7E:  DECFSZ 3FEF,W
03B80:  BRA    3BA4
....................        {
....................             Data_Out(0xFF);
03B82:  MOVLB  8
03B84:  SETF   x54
03B86:  MOVLB  0
03B88:  CALL   0636
....................             Data_Out(0xFF);
03B8C:  MOVLB  8
03B8E:  SETF   x54
03B90:  MOVLB  0
03B92:  CALL   0636
....................             Data_Out(0xFF);
03B96:  MOVLB  8
03B98:  SETF   x54
03B9A:  MOVLB  0
03B9C:  CALL   0636
....................        } else
03BA0:  BRA    3BC2
03BA2:  MOVLB  5
....................        {
....................             Data_Out(0x00);
03BA4:  MOVLB  8
03BA6:  CLRF   x54
03BA8:  MOVLB  0
03BAA:  CALL   0636
....................             Data_Out(0x00);
03BAE:  MOVLB  8
03BB0:  CLRF   x54
03BB2:  MOVLB  0
03BB4:  CALL   0636
....................             Data_Out(0x00);
03BB8:  MOVLB  8
03BBA:  CLRF   x54
03BBC:  MOVLB  0
03BBE:  CALL   0636
....................        }
03BC2:  MOVLB  5
03BC4:  INCF   x5E,F
03BC6:  BTFSC  3FD8.2
03BC8:  INCF   x5F,F
03BCA:  BRA    3B64
....................        
....................     } 
03BCC:  MOVLB  0
03BCE:  GOTO   57B2 (RETURN)
.................... }
.................... 
.................... 
.................... /**
....................     Draw a 2 digit
.................... **/
.................... void    Draw_Two(void)
.................... {
....................     uint16_t    n;
....................     uint8_t Two[375]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,1,1,1,1,1,0,0,0,0,1,1,1,1,0,
....................     0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,
....................     0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,
....................     0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,
....................     0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,
....................     0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,
....................     0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,
....................     0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,
....................     0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
03BD2:  MOVLB  5
03BD4:  CLRF   x60
03BD6:  CLRF   x61
03BD8:  CLRF   x62
03BDA:  CLRF   x63
03BDC:  CLRF   x64
03BDE:  CLRF   x65
03BE0:  CLRF   x66
03BE2:  CLRF   x67
03BE4:  CLRF   x68
03BE6:  CLRF   x69
03BE8:  CLRF   x6A
03BEA:  CLRF   x6B
03BEC:  CLRF   x6C
03BEE:  CLRF   x6D
03BF0:  CLRF   x6E
03BF2:  CLRF   x6F
03BF4:  CLRF   x70
03BF6:  CLRF   x71
03BF8:  CLRF   x72
03BFA:  CLRF   x73
03BFC:  MOVLW  01
03BFE:  MOVWF  x74
03C00:  MOVWF  x75
03C02:  MOVWF  x76
03C04:  MOVWF  x77
03C06:  MOVWF  x78
03C08:  MOVWF  x79
03C0A:  CLRF   x7A
03C0C:  CLRF   x7B
03C0E:  CLRF   x7C
03C10:  CLRF   x7D
03C12:  CLRF   x7E
03C14:  CLRF   x7F
03C16:  CLRF   x80
03C18:  MOVWF  x81
03C1A:  MOVWF  x82
03C1C:  MOVWF  x83
03C1E:  MOVWF  x84
03C20:  MOVWF  x85
03C22:  MOVWF  x86
03C24:  MOVWF  x87
03C26:  MOVWF  x88
03C28:  MOVWF  x89
03C2A:  CLRF   x8A
03C2C:  CLRF   x8B
03C2E:  CLRF   x8C
03C30:  CLRF   x8D
03C32:  CLRF   x8E
03C34:  MOVWF  x8F
03C36:  MOVWF  x90
03C38:  MOVWF  x91
03C3A:  MOVWF  x92
03C3C:  MOVWF  x93
03C3E:  MOVWF  x94
03C40:  MOVWF  x95
03C42:  MOVWF  x96
03C44:  MOVWF  x97
03C46:  MOVWF  x98
03C48:  MOVWF  x99
03C4A:  CLRF   x9A
03C4C:  CLRF   x9B
03C4E:  CLRF   x9C
03C50:  MOVWF  x9D
03C52:  MOVWF  x9E
03C54:  MOVWF  x9F
03C56:  MOVWF  xA0
03C58:  MOVWF  xA1
03C5A:  CLRF   xA2
03C5C:  CLRF   xA3
03C5E:  CLRF   xA4
03C60:  CLRF   xA5
03C62:  MOVWF  xA6
03C64:  MOVWF  xA7
03C66:  MOVWF  xA8
03C68:  MOVWF  xA9
03C6A:  CLRF   xAA
03C6C:  CLRF   xAB
03C6E:  MOVWF  xAC
03C70:  MOVWF  xAD
03C72:  MOVWF  xAE
03C74:  MOVWF  xAF
03C76:  CLRF   xB0
03C78:  CLRF   xB1
03C7A:  CLRF   xB2
03C7C:  CLRF   xB3
03C7E:  CLRF   xB4
03C80:  CLRF   xB5
03C82:  MOVWF  xB6
03C84:  MOVWF  xB7
03C86:  MOVWF  xB8
03C88:  CLRF   xB9
03C8A:  CLRF   xBA
03C8C:  MOVWF  xBB
03C8E:  MOVWF  xBC
03C90:  MOVWF  xBD
03C92:  MOVWF  xBE
03C94:  CLRF   xBF
03C96:  CLRF   xC0
03C98:  CLRF   xC1
03C9A:  CLRF   xC2
03C9C:  CLRF   xC3
03C9E:  MOVWF  xC4
03CA0:  MOVWF  xC5
03CA2:  MOVWF  xC6
03CA4:  MOVWF  xC7
03CA6:  CLRF   xC8
03CA8:  CLRF   xC9
03CAA:  CLRF   xCA
03CAC:  CLRF   xCB
03CAE:  CLRF   xCC
03CB0:  CLRF   xCD
03CB2:  CLRF   xCE
03CB4:  CLRF   xCF
03CB6:  CLRF   xD0
03CB8:  CLRF   xD1
03CBA:  CLRF   xD2
03CBC:  MOVWF  xD3
03CBE:  MOVWF  xD4
03CC0:  MOVWF  xD5
03CC2:  MOVWF  xD6
03CC4:  CLRF   xD7
03CC6:  CLRF   xD8
03CC8:  CLRF   xD9
03CCA:  CLRF   xDA
03CCC:  CLRF   xDB
03CCE:  CLRF   xDC
03CD0:  CLRF   xDD
03CD2:  CLRF   xDE
03CD4:  CLRF   xDF
03CD6:  CLRF   xE0
03CD8:  CLRF   xE1
03CDA:  MOVWF  xE2
03CDC:  MOVWF  xE3
03CDE:  MOVWF  xE4
03CE0:  MOVWF  xE5
03CE2:  CLRF   xE6
03CE4:  CLRF   xE7
03CE6:  CLRF   xE8
03CE8:  CLRF   xE9
03CEA:  CLRF   xEA
03CEC:  CLRF   xEB
03CEE:  CLRF   xEC
03CF0:  CLRF   xED
03CF2:  CLRF   xEE
03CF4:  CLRF   xEF
03CF6:  CLRF   xF0
03CF8:  MOVWF  xF1
03CFA:  MOVWF  xF2
03CFC:  MOVWF  xF3
03CFE:  MOVWF  xF4
03D00:  CLRF   xF5
03D02:  CLRF   xF6
03D04:  CLRF   xF7
03D06:  CLRF   xF8
03D08:  CLRF   xF9
03D0A:  CLRF   xFA
03D0C:  CLRF   xFB
03D0E:  CLRF   xFC
03D10:  CLRF   xFD
03D12:  CLRF   xFE
03D14:  MOVWF  xFF
03D16:  MOVLB  6
03D18:  MOVWF  x00
03D1A:  MOVWF  x01
03D1C:  MOVWF  x02
03D1E:  CLRF   x03
03D20:  CLRF   x04
03D22:  CLRF   x05
03D24:  CLRF   x06
03D26:  CLRF   x07
03D28:  CLRF   x08
03D2A:  CLRF   x09
03D2C:  CLRF   x0A
03D2E:  CLRF   x0B
03D30:  CLRF   x0C
03D32:  CLRF   x0D
03D34:  MOVWF  x0E
03D36:  MOVWF  x0F
03D38:  MOVWF  x10
03D3A:  MOVWF  x11
03D3C:  CLRF   x12
03D3E:  CLRF   x13
03D40:  CLRF   x14
03D42:  CLRF   x15
03D44:  CLRF   x16
03D46:  CLRF   x17
03D48:  CLRF   x18
03D4A:  CLRF   x19
03D4C:  CLRF   x1A
03D4E:  CLRF   x1B
03D50:  MOVWF  x1C
03D52:  MOVWF  x1D
03D54:  MOVWF  x1E
03D56:  MOVWF  x1F
03D58:  CLRF   x20
03D5A:  CLRF   x21
03D5C:  CLRF   x22
03D5E:  CLRF   x23
03D60:  CLRF   x24
03D62:  CLRF   x25
03D64:  CLRF   x26
03D66:  CLRF   x27
03D68:  CLRF   x28
03D6A:  CLRF   x29
03D6C:  MOVWF  x2A
03D6E:  MOVWF  x2B
03D70:  MOVWF  x2C
03D72:  MOVWF  x2D
03D74:  CLRF   x2E
03D76:  CLRF   x2F
03D78:  CLRF   x30
03D7A:  CLRF   x31
03D7C:  CLRF   x32
03D7E:  CLRF   x33
03D80:  CLRF   x34
03D82:  CLRF   x35
03D84:  CLRF   x36
03D86:  CLRF   x37
03D88:  MOVWF  x38
03D8A:  MOVWF  x39
03D8C:  MOVWF  x3A
03D8E:  MOVWF  x3B
03D90:  CLRF   x3C
03D92:  CLRF   x3D
03D94:  CLRF   x3E
03D96:  CLRF   x3F
03D98:  CLRF   x40
03D9A:  CLRF   x41
03D9C:  CLRF   x42
03D9E:  CLRF   x43
03DA0:  CLRF   x44
03DA2:  CLRF   x45
03DA4:  MOVWF  x46
03DA6:  MOVWF  x47
03DA8:  MOVWF  x48
03DAA:  MOVWF  x49
03DAC:  CLRF   x4A
03DAE:  CLRF   x4B
03DB0:  CLRF   x4C
03DB2:  CLRF   x4D
03DB4:  CLRF   x4E
03DB6:  CLRF   x4F
03DB8:  CLRF   x50
03DBA:  CLRF   x51
03DBC:  CLRF   x52
03DBE:  CLRF   x53
03DC0:  MOVWF  x54
03DC2:  MOVWF  x55
03DC4:  MOVWF  x56
03DC6:  MOVWF  x57
03DC8:  CLRF   x58
03DCA:  CLRF   x59
03DCC:  CLRF   x5A
03DCE:  CLRF   x5B
03DD0:  CLRF   x5C
03DD2:  CLRF   x5D
03DD4:  CLRF   x5E
03DD6:  CLRF   x5F
03DD8:  CLRF   x60
03DDA:  CLRF   x61
03DDC:  MOVWF  x62
03DDE:  MOVWF  x63
03DE0:  MOVWF  x64
03DE2:  MOVWF  x65
03DE4:  CLRF   x66
03DE6:  CLRF   x67
03DE8:  CLRF   x68
03DEA:  CLRF   x69
03DEC:  CLRF   x6A
03DEE:  CLRF   x6B
03DF0:  CLRF   x6C
03DF2:  CLRF   x6D
03DF4:  CLRF   x6E
03DF6:  CLRF   x6F
03DF8:  MOVWF  x70
03DFA:  MOVWF  x71
03DFC:  MOVWF  x72
03DFE:  MOVWF  x73
03E00:  CLRF   x74
03E02:  CLRF   x75
03E04:  CLRF   x76
03E06:  CLRF   x77
03E08:  CLRF   x78
03E0A:  CLRF   x79
03E0C:  CLRF   x7A
03E0E:  CLRF   x7B
03E10:  CLRF   x7C
03E12:  CLRF   x7D
03E14:  CLRF   x7E
03E16:  MOVWF  x7F
03E18:  MOVWF  x80
03E1A:  MOVWF  x81
03E1C:  MOVWF  x82
03E1E:  CLRF   x83
03E20:  CLRF   x84
03E22:  CLRF   x85
03E24:  CLRF   x86
03E26:  CLRF   x87
03E28:  CLRF   x88
03E2A:  CLRF   x89
03E2C:  CLRF   x8A
03E2E:  CLRF   x8B
03E30:  CLRF   x8C
03E32:  MOVWF  x8D
03E34:  MOVWF  x8E
03E36:  MOVWF  x8F
03E38:  MOVWF  x90
03E3A:  MOVWF  x91
03E3C:  CLRF   x92
03E3E:  CLRF   x93
03E40:  CLRF   x94
03E42:  CLRF   x95
03E44:  CLRF   x96
03E46:  CLRF   x97
03E48:  CLRF   x98
03E4A:  CLRF   x99
03E4C:  CLRF   x9A
03E4E:  CLRF   x9B
03E50:  MOVWF  x9C
03E52:  MOVWF  x9D
03E54:  MOVWF  x9E
03E56:  MOVWF  x9F
03E58:  MOVWF  xA0
03E5A:  MOVWF  xA1
03E5C:  MOVWF  xA2
03E5E:  MOVWF  xA3
03E60:  MOVWF  xA4
03E62:  MOVWF  xA5
03E64:  MOVWF  xA6
03E66:  MOVWF  xA7
03E68:  MOVWF  xA8
03E6A:  CLRF   xA9
03E6C:  MOVWF  xAA
03E6E:  MOVWF  xAB
03E70:  MOVWF  xAC
03E72:  MOVWF  xAD
03E74:  MOVWF  xAE
03E76:  MOVWF  xAF
03E78:  MOVWF  xB0
03E7A:  MOVWF  xB1
03E7C:  MOVWF  xB2
03E7E:  MOVWF  xB3
03E80:  MOVWF  xB4
03E82:  MOVWF  xB5
03E84:  MOVWF  xB6
03E86:  MOVWF  xB7
03E88:  CLRF   xB8
03E8A:  MOVWF  xB9
03E8C:  MOVWF  xBA
03E8E:  MOVWF  xBB
03E90:  MOVWF  xBC
03E92:  MOVWF  xBD
03E94:  MOVWF  xBE
03E96:  MOVWF  xBF
03E98:  MOVWF  xC0
03E9A:  MOVWF  xC1
03E9C:  MOVWF  xC2
03E9E:  MOVWF  xC3
03EA0:  MOVWF  xC4
03EA2:  MOVWF  xC5
03EA4:  MOVWF  xC6
03EA6:  CLRF   xC7
03EA8:  CLRF   xC8
03EAA:  CLRF   xC9
03EAC:  CLRF   xCA
03EAE:  CLRF   xCB
03EB0:  CLRF   xCC
03EB2:  CLRF   xCD
03EB4:  CLRF   xCE
03EB6:  CLRF   xCF
03EB8:  CLRF   xD0
03EBA:  CLRF   xD1
03EBC:  CLRF   xD2
03EBE:  CLRF   xD3
03EC0:  CLRF   xD4
03EC2:  CLRF   xD5
03EC4:  CLRF   xD6
....................     
....................     for(n=0; n<375; n++) //draw a block
03EC6:  MOVLB  5
03EC8:  CLRF   x5F
03ECA:  CLRF   x5E
03ECC:  MOVF   x5F,W
03ECE:  SUBLW  01
03ED0:  BNC   3F34
03ED2:  BNZ   3EDA
03ED4:  MOVF   x5E,W
03ED6:  SUBLW  76
03ED8:  BNC   3F34
....................     {
....................        if(Two[n] == 1)
03EDA:  MOVLW  60
03EDC:  ADDWF  x5E,W
03EDE:  MOVWF  3FE9
03EE0:  MOVLW  05
03EE2:  ADDWFC x5F,W
03EE4:  MOVWF  3FEA
03EE6:  DECFSZ 3FEF,W
03EE8:  BRA    3F0C
....................        {
....................             Data_Out(0xFF);
03EEA:  MOVLB  8
03EEC:  SETF   x54
03EEE:  MOVLB  0
03EF0:  CALL   0636
....................             Data_Out(0xFF);
03EF4:  MOVLB  8
03EF6:  SETF   x54
03EF8:  MOVLB  0
03EFA:  CALL   0636
....................             Data_Out(0xFF);
03EFE:  MOVLB  8
03F00:  SETF   x54
03F02:  MOVLB  0
03F04:  CALL   0636
....................        } else
03F08:  BRA    3F2A
03F0A:  MOVLB  5
....................        {
....................             Data_Out(0x00);
03F0C:  MOVLB  8
03F0E:  CLRF   x54
03F10:  MOVLB  0
03F12:  CALL   0636
....................             Data_Out(0x00);
03F16:  MOVLB  8
03F18:  CLRF   x54
03F1A:  MOVLB  0
03F1C:  CALL   0636
....................             Data_Out(0x00);
03F20:  MOVLB  8
03F22:  CLRF   x54
03F24:  MOVLB  0
03F26:  CALL   0636
....................        }
03F2A:  MOVLB  5
03F2C:  INCF   x5E,F
03F2E:  BTFSC  3FD8.2
03F30:  INCF   x5F,F
03F32:  BRA    3ECC
....................        
....................     } 
03F34:  MOVLB  0
03F36:  GOTO   57BA (RETURN)
.................... }
.................... 
.................... 
.................... /**
....................     Draw a 3 digit
.................... **/
.................... void    Draw_Three(void)
.................... {
....................     uint16_t    n;
....................     uint8_t Three[375]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,
....................     1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,
....................     1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,
....................     0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,
....................     0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,
....................     1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,
....................     1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,
....................     0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,0,0,0,0,0};
03F3A:  MOVLB  5
03F3C:  CLRF   x60
03F3E:  CLRF   x61
03F40:  CLRF   x62
03F42:  CLRF   x63
03F44:  CLRF   x64
03F46:  CLRF   x65
03F48:  CLRF   x66
03F4A:  CLRF   x67
03F4C:  CLRF   x68
03F4E:  CLRF   x69
03F50:  CLRF   x6A
03F52:  CLRF   x6B
03F54:  CLRF   x6C
03F56:  CLRF   x6D
03F58:  CLRF   x6E
03F5A:  CLRF   x6F
03F5C:  CLRF   x70
03F5E:  CLRF   x71
03F60:  CLRF   x72
03F62:  CLRF   x73
03F64:  MOVLW  01
03F66:  MOVWF  x74
03F68:  MOVWF  x75
03F6A:  MOVWF  x76
03F6C:  MOVWF  x77
03F6E:  MOVWF  x78
03F70:  CLRF   x79
03F72:  CLRF   x7A
03F74:  CLRF   x7B
03F76:  CLRF   x7C
03F78:  CLRF   x7D
03F7A:  CLRF   x7E
03F7C:  CLRF   x7F
03F7E:  CLRF   x80
03F80:  MOVWF  x81
03F82:  MOVWF  x82
03F84:  MOVWF  x83
03F86:  MOVWF  x84
03F88:  MOVWF  x85
03F8A:  MOVWF  x86
03F8C:  MOVWF  x87
03F8E:  MOVWF  x88
03F90:  CLRF   x89
03F92:  CLRF   x8A
03F94:  CLRF   x8B
03F96:  CLRF   x8C
03F98:  CLRF   x8D
03F9A:  CLRF   x8E
03F9C:  MOVWF  x8F
03F9E:  MOVWF  x90
03FA0:  MOVWF  x91
03FA2:  MOVWF  x92
03FA4:  MOVWF  x93
03FA6:  MOVWF  x94
03FA8:  MOVWF  x95
03FAA:  MOVWF  x96
03FAC:  MOVWF  x97
03FAE:  MOVWF  x98
03FB0:  MOVWF  x99
03FB2:  CLRF   x9A
03FB4:  CLRF   x9B
03FB6:  CLRF   x9C
03FB8:  MOVWF  x9D
03FBA:  MOVWF  x9E
03FBC:  MOVWF  x9F
03FBE:  MOVWF  xA0
03FC0:  MOVWF  xA1
03FC2:  MOVWF  xA2
03FC4:  MOVWF  xA3
03FC6:  MOVWF  xA4
03FC8:  MOVWF  xA5
03FCA:  MOVWF  xA6
03FCC:  MOVWF  xA7
03FCE:  MOVWF  xA8
03FD0:  CLRF   xA9
03FD2:  CLRF   xAA
03FD4:  CLRF   xAB
03FD6:  MOVWF  xAC
03FD8:  MOVWF  xAD
03FDA:  MOVWF  xAE
03FDC:  MOVWF  xAF
03FDE:  MOVWF  xB0
03FE0:  CLRF   xB1
03FE2:  CLRF   xB2
03FE4:  CLRF   xB3
03FE6:  MOVWF  xB4
03FE8:  MOVWF  xB5
03FEA:  MOVWF  xB6
03FEC:  MOVWF  xB7
03FEE:  MOVWF  xB8
03FF0:  CLRF   xB9
03FF2:  MOVWF  xBA
03FF4:  MOVWF  xBB
03FF6:  MOVWF  xBC
03FF8:  MOVWF  xBD
03FFA:  MOVWF  xBE
03FFC:  CLRF   xBF
03FFE:  CLRF   xC0
04000:  CLRF   xC1
04002:  CLRF   xC2
04004:  CLRF   xC3
04006:  MOVWF  xC4
04008:  MOVWF  xC5
0400A:  MOVWF  xC6
0400C:  MOVWF  xC7
0400E:  CLRF   xC8
04010:  MOVWF  xC9
04012:  MOVWF  xCA
04014:  MOVWF  xCB
04016:  MOVWF  xCC
04018:  CLRF   xCD
0401A:  CLRF   xCE
0401C:  CLRF   xCF
0401E:  CLRF   xD0
04020:  CLRF   xD1
04022:  CLRF   xD2
04024:  MOVWF  xD3
04026:  MOVWF  xD4
04028:  MOVWF  xD5
0402A:  MOVWF  xD6
0402C:  CLRF   xD7
0402E:  CLRF   xD8
04030:  CLRF   xD9
04032:  CLRF   xDA
04034:  CLRF   xDB
04036:  CLRF   xDC
04038:  CLRF   xDD
0403A:  CLRF   xDE
0403C:  CLRF   xDF
0403E:  CLRF   xE0
04040:  CLRF   xE1
04042:  MOVWF  xE2
04044:  MOVWF  xE3
04046:  MOVWF  xE4
04048:  MOVWF  xE5
0404A:  CLRF   xE6
0404C:  CLRF   xE7
0404E:  CLRF   xE8
04050:  CLRF   xE9
04052:  CLRF   xEA
04054:  CLRF   xEB
04056:  CLRF   xEC
04058:  CLRF   xED
0405A:  CLRF   xEE
0405C:  CLRF   xEF
0405E:  CLRF   xF0
04060:  MOVWF  xF1
04062:  MOVWF  xF2
04064:  MOVWF  xF3
04066:  MOVWF  xF4
04068:  CLRF   xF5
0406A:  CLRF   xF6
0406C:  CLRF   xF7
0406E:  CLRF   xF8
04070:  CLRF   xF9
04072:  CLRF   xFA
04074:  CLRF   xFB
04076:  CLRF   xFC
04078:  CLRF   xFD
0407A:  CLRF   xFE
0407C:  MOVWF  xFF
0407E:  MOVLB  6
04080:  MOVWF  x00
04082:  MOVWF  x01
04084:  MOVWF  x02
04086:  MOVWF  x03
04088:  CLRF   x04
0408A:  CLRF   x05
0408C:  CLRF   x06
0408E:  CLRF   x07
04090:  CLRF   x08
04092:  CLRF   x09
04094:  MOVWF  x0A
04096:  MOVWF  x0B
04098:  MOVWF  x0C
0409A:  MOVWF  x0D
0409C:  MOVWF  x0E
0409E:  MOVWF  x0F
040A0:  MOVWF  x10
040A2:  MOVWF  x11
040A4:  CLRF   x12
040A6:  CLRF   x13
040A8:  CLRF   x14
040AA:  CLRF   x15
040AC:  CLRF   x16
040AE:  CLRF   x17
040B0:  CLRF   x18
040B2:  MOVWF  x19
040B4:  MOVWF  x1A
040B6:  MOVWF  x1B
040B8:  MOVWF  x1C
040BA:  MOVWF  x1D
040BC:  MOVWF  x1E
040BE:  MOVWF  x1F
040C0:  CLRF   x20
040C2:  CLRF   x21
040C4:  CLRF   x22
040C6:  CLRF   x23
040C8:  CLRF   x24
040CA:  CLRF   x25
040CC:  CLRF   x26
040CE:  CLRF   x27
040D0:  MOVWF  x28
040D2:  MOVWF  x29
040D4:  MOVWF  x2A
040D6:  MOVWF  x2B
040D8:  MOVWF  x2C
040DA:  MOVWF  x2D
040DC:  MOVWF  x2E
040DE:  MOVWF  x2F
040E0:  CLRF   x30
040E2:  CLRF   x31
040E4:  CLRF   x32
040E6:  CLRF   x33
040E8:  CLRF   x34
040EA:  CLRF   x35
040EC:  CLRF   x36
040EE:  CLRF   x37
040F0:  CLRF   x38
040F2:  CLRF   x39
040F4:  CLRF   x3A
040F6:  MOVWF  x3B
040F8:  MOVWF  x3C
040FA:  MOVWF  x3D
040FC:  MOVWF  x3E
040FE:  MOVWF  x3F
04100:  CLRF   x40
04102:  CLRF   x41
04104:  CLRF   x42
04106:  CLRF   x43
04108:  CLRF   x44
0410A:  CLRF   x45
0410C:  CLRF   x46
0410E:  CLRF   x47
04110:  CLRF   x48
04112:  CLRF   x49
04114:  CLRF   x4A
04116:  MOVWF  x4B
04118:  MOVWF  x4C
0411A:  MOVWF  x4D
0411C:  MOVWF  x4E
0411E:  CLRF   x4F
04120:  CLRF   x50
04122:  CLRF   x51
04124:  CLRF   x52
04126:  CLRF   x53
04128:  CLRF   x54
0412A:  CLRF   x55
0412C:  CLRF   x56
0412E:  CLRF   x57
04130:  CLRF   x58
04132:  CLRF   x59
04134:  MOVWF  x5A
04136:  MOVWF  x5B
04138:  MOVWF  x5C
0413A:  MOVWF  x5D
0413C:  CLRF   x5E
0413E:  CLRF   x5F
04140:  CLRF   x60
04142:  CLRF   x61
04144:  CLRF   x62
04146:  CLRF   x63
04148:  CLRF   x64
0414A:  CLRF   x65
0414C:  CLRF   x66
0414E:  CLRF   x67
04150:  CLRF   x68
04152:  MOVWF  x69
04154:  MOVWF  x6A
04156:  MOVWF  x6B
04158:  MOVWF  x6C
0415A:  CLRF   x6D
0415C:  MOVWF  x6E
0415E:  MOVWF  x6F
04160:  MOVWF  x70
04162:  MOVWF  x71
04164:  CLRF   x72
04166:  CLRF   x73
04168:  CLRF   x74
0416A:  CLRF   x75
0416C:  CLRF   x76
0416E:  CLRF   x77
04170:  MOVWF  x78
04172:  MOVWF  x79
04174:  MOVWF  x7A
04176:  MOVWF  x7B
04178:  CLRF   x7C
0417A:  MOVWF  x7D
0417C:  MOVWF  x7E
0417E:  MOVWF  x7F
04180:  MOVWF  x80
04182:  MOVWF  x81
04184:  CLRF   x82
04186:  CLRF   x83
04188:  CLRF   x84
0418A:  CLRF   x85
0418C:  CLRF   x86
0418E:  MOVWF  x87
04190:  MOVWF  x88
04192:  MOVWF  x89
04194:  MOVWF  x8A
04196:  CLRF   x8B
04198:  CLRF   x8C
0419A:  MOVWF  x8D
0419C:  MOVWF  x8E
0419E:  MOVWF  x8F
041A0:  MOVWF  x90
041A2:  MOVWF  x91
041A4:  CLRF   x92
041A6:  CLRF   x93
041A8:  CLRF   x94
041AA:  MOVWF  x95
041AC:  MOVWF  x96
041AE:  MOVWF  x97
041B0:  MOVWF  x98
041B2:  MOVWF  x99
041B4:  CLRF   x9A
041B6:  CLRF   x9B
041B8:  MOVWF  x9C
041BA:  MOVWF  x9D
041BC:  MOVWF  x9E
041BE:  MOVWF  x9F
041C0:  MOVWF  xA0
041C2:  MOVWF  xA1
041C4:  MOVWF  xA2
041C6:  MOVWF  xA3
041C8:  MOVWF  xA4
041CA:  MOVWF  xA5
041CC:  MOVWF  xA6
041CE:  MOVWF  xA7
041D0:  CLRF   xA8
041D2:  CLRF   xA9
041D4:  CLRF   xAA
041D6:  CLRF   xAB
041D8:  MOVWF  xAC
041DA:  MOVWF  xAD
041DC:  MOVWF  xAE
041DE:  MOVWF  xAF
041E0:  MOVWF  xB0
041E2:  MOVWF  xB1
041E4:  MOVWF  xB2
041E6:  MOVWF  xB3
041E8:  MOVWF  xB4
041EA:  MOVWF  xB5
041EC:  MOVWF  xB6
041EE:  CLRF   xB7
041F0:  CLRF   xB8
041F2:  CLRF   xB9
041F4:  CLRF   xBA
041F6:  CLRF   xBB
041F8:  CLRF   xBC
041FA:  MOVWF  xBD
041FC:  MOVWF  xBE
041FE:  MOVWF  xBF
04200:  MOVWF  xC0
04202:  MOVWF  xC1
04204:  MOVWF  xC2
04206:  MOVWF  xC3
04208:  CLRF   xC4
0420A:  CLRF   xC5
0420C:  CLRF   xC6
0420E:  CLRF   xC7
04210:  CLRF   xC8
04212:  CLRF   xC9
04214:  CLRF   xCA
04216:  CLRF   xCB
04218:  CLRF   xCC
0421A:  MOVWF  xCD
0421C:  MOVWF  xCE
0421E:  MOVWF  xCF
04220:  MOVWF  xD0
04222:  MOVWF  xD1
04224:  CLRF   xD2
04226:  CLRF   xD3
04228:  CLRF   xD4
0422A:  CLRF   xD5
0422C:  CLRF   xD6
....................     
....................     for(n=0; n<375; n++) //draw a block
0422E:  MOVLB  5
04230:  CLRF   x5F
04232:  CLRF   x5E
04234:  MOVF   x5F,W
04236:  SUBLW  01
04238:  BNC   429C
0423A:  BNZ   4242
0423C:  MOVF   x5E,W
0423E:  SUBLW  76
04240:  BNC   429C
....................     {
....................        if(Three[n] == 1)
04242:  MOVLW  60
04244:  ADDWF  x5E,W
04246:  MOVWF  3FE9
04248:  MOVLW  05
0424A:  ADDWFC x5F,W
0424C:  MOVWF  3FEA
0424E:  DECFSZ 3FEF,W
04250:  BRA    4274
....................        {
....................             Data_Out(0xFF);
04252:  MOVLB  8
04254:  SETF   x54
04256:  MOVLB  0
04258:  CALL   0636
....................             Data_Out(0xFF);
0425C:  MOVLB  8
0425E:  SETF   x54
04260:  MOVLB  0
04262:  CALL   0636
....................             Data_Out(0xFF);
04266:  MOVLB  8
04268:  SETF   x54
0426A:  MOVLB  0
0426C:  CALL   0636
....................        } else
04270:  BRA    4292
04272:  MOVLB  5
....................        {
....................             Data_Out(0x00);
04274:  MOVLB  8
04276:  CLRF   x54
04278:  MOVLB  0
0427A:  CALL   0636
....................             Data_Out(0x00);
0427E:  MOVLB  8
04280:  CLRF   x54
04282:  MOVLB  0
04284:  CALL   0636
....................             Data_Out(0x00);
04288:  MOVLB  8
0428A:  CLRF   x54
0428C:  MOVLB  0
0428E:  CALL   0636
....................        }
04292:  MOVLB  5
04294:  INCF   x5E,F
04296:  BTFSC  3FD8.2
04298:  INCF   x5F,F
0429A:  BRA    4234
....................        
....................     } 
0429C:  MOVLB  0
0429E:  GOTO   57C2 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /**
....................     Draw a 4 digit
.................... **/
.................... void    Draw_Four(void)
.................... {
....................     uint16_t    n;
....................     uint8_t Four[375]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,
....................     0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,
....................     0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,
....................     0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,
....................     0,0,0,0,0,1,1,1,1,0,1,1,1,0,0,
....................     0,0,0,0,0,1,1,1,1,0,1,1,1,0,0,
....................     0,0,0,0,1,1,1,1,0,0,1,1,1,0,0,
....................     0,0,0,0,1,1,1,1,0,0,1,1,1,0,0,
....................     0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,
....................     0,0,1,1,1,1,0,0,0,0,1,1,1,0,0,
....................     0,0,1,1,1,1,0,0,0,0,1,1,1,0,0,
....................     0,1,1,1,1,0,0,0,0,0,1,1,1,0,0,
....................     1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
042A2:  MOVLB  5
042A4:  CLRF   x60
042A6:  CLRF   x61
042A8:  CLRF   x62
042AA:  CLRF   x63
042AC:  CLRF   x64
042AE:  CLRF   x65
042B0:  CLRF   x66
042B2:  CLRF   x67
042B4:  CLRF   x68
042B6:  CLRF   x69
042B8:  CLRF   x6A
042BA:  CLRF   x6B
042BC:  CLRF   x6C
042BE:  CLRF   x6D
042C0:  CLRF   x6E
042C2:  CLRF   x6F
042C4:  CLRF   x70
042C6:  CLRF   x71
042C8:  CLRF   x72
042CA:  CLRF   x73
042CC:  CLRF   x74
042CE:  CLRF   x75
042D0:  CLRF   x76
042D2:  CLRF   x77
042D4:  MOVLW  01
042D6:  MOVWF  x78
042D8:  MOVWF  x79
042DA:  MOVWF  x7A
042DC:  MOVWF  x7B
042DE:  CLRF   x7C
042E0:  CLRF   x7D
042E2:  CLRF   x7E
042E4:  CLRF   x7F
042E6:  CLRF   x80
042E8:  CLRF   x81
042EA:  CLRF   x82
042EC:  CLRF   x83
042EE:  CLRF   x84
042F0:  CLRF   x85
042F2:  CLRF   x86
042F4:  MOVWF  x87
042F6:  MOVWF  x88
042F8:  MOVWF  x89
042FA:  MOVWF  x8A
042FC:  CLRF   x8B
042FE:  CLRF   x8C
04300:  CLRF   x8D
04302:  CLRF   x8E
04304:  CLRF   x8F
04306:  CLRF   x90
04308:  CLRF   x91
0430A:  CLRF   x92
0430C:  CLRF   x93
0430E:  CLRF   x94
04310:  MOVWF  x95
04312:  MOVWF  x96
04314:  MOVWF  x97
04316:  MOVWF  x98
04318:  MOVWF  x99
0431A:  CLRF   x9A
0431C:  CLRF   x9B
0431E:  CLRF   x9C
04320:  CLRF   x9D
04322:  CLRF   x9E
04324:  CLRF   x9F
04326:  CLRF   xA0
04328:  CLRF   xA1
0432A:  CLRF   xA2
0432C:  MOVWF  xA3
0432E:  MOVWF  xA4
04330:  MOVWF  xA5
04332:  MOVWF  xA6
04334:  MOVWF  xA7
04336:  MOVWF  xA8
04338:  CLRF   xA9
0433A:  CLRF   xAA
0433C:  CLRF   xAB
0433E:  CLRF   xAC
04340:  CLRF   xAD
04342:  CLRF   xAE
04344:  CLRF   xAF
04346:  CLRF   xB0
04348:  MOVWF  xB1
0434A:  MOVWF  xB2
0434C:  MOVWF  xB3
0434E:  MOVWF  xB4
04350:  MOVWF  xB5
04352:  MOVWF  xB6
04354:  MOVWF  xB7
04356:  CLRF   xB8
04358:  CLRF   xB9
0435A:  CLRF   xBA
0435C:  CLRF   xBB
0435E:  CLRF   xBC
04360:  CLRF   xBD
04362:  CLRF   xBE
04364:  CLRF   xBF
04366:  MOVWF  xC0
04368:  MOVWF  xC1
0436A:  MOVWF  xC2
0436C:  MOVWF  xC3
0436E:  MOVWF  xC4
04370:  MOVWF  xC5
04372:  MOVWF  xC6
04374:  CLRF   xC7
04376:  CLRF   xC8
04378:  CLRF   xC9
0437A:  CLRF   xCA
0437C:  CLRF   xCB
0437E:  CLRF   xCC
04380:  CLRF   xCD
04382:  MOVWF  xCE
04384:  MOVWF  xCF
04386:  MOVWF  xD0
04388:  MOVWF  xD1
0438A:  CLRF   xD2
0438C:  MOVWF  xD3
0438E:  MOVWF  xD4
04390:  MOVWF  xD5
04392:  CLRF   xD6
04394:  CLRF   xD7
04396:  CLRF   xD8
04398:  CLRF   xD9
0439A:  CLRF   xDA
0439C:  CLRF   xDB
0439E:  CLRF   xDC
043A0:  MOVWF  xDD
043A2:  MOVWF  xDE
043A4:  MOVWF  xDF
043A6:  MOVWF  xE0
043A8:  CLRF   xE1
043AA:  MOVWF  xE2
043AC:  MOVWF  xE3
043AE:  MOVWF  xE4
043B0:  CLRF   xE5
043B2:  CLRF   xE6
043B4:  CLRF   xE7
043B6:  CLRF   xE8
043B8:  CLRF   xE9
043BA:  CLRF   xEA
043BC:  MOVWF  xEB
043BE:  MOVWF  xEC
043C0:  MOVWF  xED
043C2:  MOVWF  xEE
043C4:  CLRF   xEF
043C6:  CLRF   xF0
043C8:  MOVWF  xF1
043CA:  MOVWF  xF2
043CC:  MOVWF  xF3
043CE:  CLRF   xF4
043D0:  CLRF   xF5
043D2:  CLRF   xF6
043D4:  CLRF   xF7
043D6:  CLRF   xF8
043D8:  CLRF   xF9
043DA:  MOVWF  xFA
043DC:  MOVWF  xFB
043DE:  MOVWF  xFC
043E0:  MOVWF  xFD
043E2:  CLRF   xFE
043E4:  CLRF   xFF
043E6:  MOVLB  6
043E8:  MOVWF  x00
043EA:  MOVWF  x01
043EC:  MOVWF  x02
043EE:  CLRF   x03
043F0:  CLRF   x04
043F2:  CLRF   x05
043F4:  CLRF   x06
043F6:  CLRF   x07
043F8:  MOVWF  x08
043FA:  MOVWF  x09
043FC:  MOVWF  x0A
043FE:  MOVWF  x0B
04400:  CLRF   x0C
04402:  CLRF   x0D
04404:  CLRF   x0E
04406:  MOVWF  x0F
04408:  MOVWF  x10
0440A:  MOVWF  x11
0440C:  CLRF   x12
0440E:  CLRF   x13
04410:  CLRF   x14
04412:  CLRF   x15
04414:  MOVWF  x16
04416:  MOVWF  x17
04418:  MOVWF  x18
0441A:  MOVWF  x19
0441C:  CLRF   x1A
0441E:  CLRF   x1B
04420:  CLRF   x1C
04422:  CLRF   x1D
04424:  MOVWF  x1E
04426:  MOVWF  x1F
04428:  MOVWF  x20
0442A:  CLRF   x21
0442C:  CLRF   x22
0442E:  CLRF   x23
04430:  CLRF   x24
04432:  MOVWF  x25
04434:  MOVWF  x26
04436:  MOVWF  x27
04438:  MOVWF  x28
0443A:  CLRF   x29
0443C:  CLRF   x2A
0443E:  CLRF   x2B
04440:  CLRF   x2C
04442:  MOVWF  x2D
04444:  MOVWF  x2E
04446:  MOVWF  x2F
04448:  CLRF   x30
0444A:  CLRF   x31
0444C:  CLRF   x32
0444E:  MOVWF  x33
04450:  MOVWF  x34
04452:  MOVWF  x35
04454:  MOVWF  x36
04456:  CLRF   x37
04458:  CLRF   x38
0445A:  CLRF   x39
0445C:  CLRF   x3A
0445E:  CLRF   x3B
04460:  MOVWF  x3C
04462:  MOVWF  x3D
04464:  MOVWF  x3E
04466:  CLRF   x3F
04468:  CLRF   x40
0446A:  MOVWF  x41
0446C:  MOVWF  x42
0446E:  MOVWF  x43
04470:  MOVWF  x44
04472:  CLRF   x45
04474:  CLRF   x46
04476:  CLRF   x47
04478:  CLRF   x48
0447A:  CLRF   x49
0447C:  CLRF   x4A
0447E:  MOVWF  x4B
04480:  MOVWF  x4C
04482:  MOVWF  x4D
04484:  CLRF   x4E
04486:  CLRF   x4F
04488:  MOVWF  x50
0448A:  MOVWF  x51
0448C:  MOVWF  x52
0448E:  MOVWF  x53
04490:  MOVWF  x54
04492:  MOVWF  x55
04494:  MOVWF  x56
04496:  MOVWF  x57
04498:  MOVWF  x58
0449A:  MOVWF  x59
0449C:  MOVWF  x5A
0449E:  MOVWF  x5B
044A0:  MOVWF  x5C
044A2:  MOVWF  x5D
044A4:  MOVWF  x5E
044A6:  MOVWF  x5F
044A8:  MOVWF  x60
044AA:  MOVWF  x61
044AC:  MOVWF  x62
044AE:  MOVWF  x63
044B0:  MOVWF  x64
044B2:  MOVWF  x65
044B4:  MOVWF  x66
044B6:  MOVWF  x67
044B8:  MOVWF  x68
044BA:  MOVWF  x69
044BC:  MOVWF  x6A
044BE:  MOVWF  x6B
044C0:  MOVWF  x6C
044C2:  MOVWF  x6D
044C4:  MOVWF  x6E
044C6:  MOVWF  x6F
044C8:  MOVWF  x70
044CA:  MOVWF  x71
044CC:  MOVWF  x72
044CE:  MOVWF  x73
044D0:  MOVWF  x74
044D2:  MOVWF  x75
044D4:  MOVWF  x76
044D6:  MOVWF  x77
044D8:  MOVWF  x78
044DA:  MOVWF  x79
044DC:  MOVWF  x7A
044DE:  MOVWF  x7B
044E0:  MOVWF  x7C
044E2:  CLRF   x7D
044E4:  CLRF   x7E
044E6:  CLRF   x7F
044E8:  CLRF   x80
044EA:  CLRF   x81
044EC:  CLRF   x82
044EE:  CLRF   x83
044F0:  CLRF   x84
044F2:  CLRF   x85
044F4:  CLRF   x86
044F6:  MOVWF  x87
044F8:  MOVWF  x88
044FA:  MOVWF  x89
044FC:  CLRF   x8A
044FE:  CLRF   x8B
04500:  CLRF   x8C
04502:  CLRF   x8D
04504:  CLRF   x8E
04506:  CLRF   x8F
04508:  CLRF   x90
0450A:  CLRF   x91
0450C:  CLRF   x92
0450E:  CLRF   x93
04510:  CLRF   x94
04512:  CLRF   x95
04514:  MOVWF  x96
04516:  MOVWF  x97
04518:  MOVWF  x98
0451A:  CLRF   x99
0451C:  CLRF   x9A
0451E:  CLRF   x9B
04520:  CLRF   x9C
04522:  CLRF   x9D
04524:  CLRF   x9E
04526:  CLRF   x9F
04528:  CLRF   xA0
0452A:  CLRF   xA1
0452C:  CLRF   xA2
0452E:  CLRF   xA3
04530:  CLRF   xA4
04532:  MOVWF  xA5
04534:  MOVWF  xA6
04536:  MOVWF  xA7
04538:  CLRF   xA8
0453A:  CLRF   xA9
0453C:  CLRF   xAA
0453E:  CLRF   xAB
04540:  CLRF   xAC
04542:  CLRF   xAD
04544:  CLRF   xAE
04546:  CLRF   xAF
04548:  CLRF   xB0
0454A:  CLRF   xB1
0454C:  CLRF   xB2
0454E:  CLRF   xB3
04550:  MOVWF  xB4
04552:  MOVWF  xB5
04554:  MOVWF  xB6
04556:  CLRF   xB7
04558:  CLRF   xB8
0455A:  CLRF   xB9
0455C:  CLRF   xBA
0455E:  CLRF   xBB
04560:  CLRF   xBC
04562:  CLRF   xBD
04564:  CLRF   xBE
04566:  CLRF   xBF
04568:  CLRF   xC0
0456A:  CLRF   xC1
0456C:  CLRF   xC2
0456E:  MOVWF  xC3
04570:  MOVWF  xC4
04572:  MOVWF  xC5
04574:  CLRF   xC6
04576:  CLRF   xC7
04578:  CLRF   xC8
0457A:  CLRF   xC9
0457C:  CLRF   xCA
0457E:  CLRF   xCB
04580:  CLRF   xCC
04582:  CLRF   xCD
04584:  CLRF   xCE
04586:  CLRF   xCF
04588:  CLRF   xD0
0458A:  CLRF   xD1
0458C:  CLRF   xD2
0458E:  CLRF   xD3
04590:  CLRF   xD4
04592:  CLRF   xD5
04594:  CLRF   xD6
....................     
....................     for(n=0; n<375; n++) //draw a block
04596:  MOVLB  5
04598:  CLRF   x5F
0459A:  CLRF   x5E
0459C:  MOVF   x5F,W
0459E:  SUBLW  01
045A0:  BNC   4604
045A2:  BNZ   45AA
045A4:  MOVF   x5E,W
045A6:  SUBLW  76
045A8:  BNC   4604
....................     {
....................        if(Four[n] == 1)
045AA:  MOVLW  60
045AC:  ADDWF  x5E,W
045AE:  MOVWF  3FE9
045B0:  MOVLW  05
045B2:  ADDWFC x5F,W
045B4:  MOVWF  3FEA
045B6:  DECFSZ 3FEF,W
045B8:  BRA    45DC
....................        {
....................             Data_Out(0xFF);
045BA:  MOVLB  8
045BC:  SETF   x54
045BE:  MOVLB  0
045C0:  CALL   0636
....................             Data_Out(0xFF);
045C4:  MOVLB  8
045C6:  SETF   x54
045C8:  MOVLB  0
045CA:  CALL   0636
....................             Data_Out(0xFF);
045CE:  MOVLB  8
045D0:  SETF   x54
045D2:  MOVLB  0
045D4:  CALL   0636
....................        } else
045D8:  BRA    45FA
045DA:  MOVLB  5
....................        {
....................             Data_Out(0x00);
045DC:  MOVLB  8
045DE:  CLRF   x54
045E0:  MOVLB  0
045E2:  CALL   0636
....................             Data_Out(0x00);
045E6:  MOVLB  8
045E8:  CLRF   x54
045EA:  MOVLB  0
045EC:  CALL   0636
....................             Data_Out(0x00);
045F0:  MOVLB  8
045F2:  CLRF   x54
045F4:  MOVLB  0
045F6:  CALL   0636
....................        }
045FA:  MOVLB  5
045FC:  INCF   x5E,F
045FE:  BTFSC  3FD8.2
04600:  INCF   x5F,F
04602:  BRA    459C
....................        
....................     } 
04604:  MOVLB  0
04606:  GOTO   57CA (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /**
....................     Draw a 5 digit
.................... **/
.................... void    Draw_Five(void)
.................... {
....................     uint16_t    n;
....................     uint8_t Five[375]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,
....................     0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,
....................     0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,
....................     0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,
....................     0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,
....................     0,0,1,1,1,0,0,0,0,0,1,1,1,1,1,
....................     0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
....................     0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
....................     0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
....................     0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
....................     0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
....................     0,1,1,1,0,0,0,0,0,0,0,1,1,1,1,
....................     0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,
....................     0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,
....................     0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
0460A:  MOVLB  5
0460C:  CLRF   x60
0460E:  CLRF   x61
04610:  CLRF   x62
04612:  CLRF   x63
04614:  CLRF   x64
04616:  CLRF   x65
04618:  CLRF   x66
0461A:  CLRF   x67
0461C:  CLRF   x68
0461E:  CLRF   x69
04620:  CLRF   x6A
04622:  CLRF   x6B
04624:  CLRF   x6C
04626:  CLRF   x6D
04628:  CLRF   x6E
0462A:  CLRF   x6F
0462C:  CLRF   x70
0462E:  MOVLW  01
04630:  MOVWF  x71
04632:  MOVWF  x72
04634:  MOVWF  x73
04636:  MOVWF  x74
04638:  MOVWF  x75
0463A:  MOVWF  x76
0463C:  MOVWF  x77
0463E:  MOVWF  x78
04640:  MOVWF  x79
04642:  MOVWF  x7A
04644:  MOVWF  x7B
04646:  MOVWF  x7C
04648:  CLRF   x7D
0464A:  CLRF   x7E
0464C:  CLRF   x7F
0464E:  MOVWF  x80
04650:  MOVWF  x81
04652:  MOVWF  x82
04654:  MOVWF  x83
04656:  MOVWF  x84
04658:  MOVWF  x85
0465A:  MOVWF  x86
0465C:  MOVWF  x87
0465E:  MOVWF  x88
04660:  MOVWF  x89
04662:  MOVWF  x8A
04664:  MOVWF  x8B
04666:  CLRF   x8C
04668:  CLRF   x8D
0466A:  CLRF   x8E
0466C:  MOVWF  x8F
0466E:  MOVWF  x90
04670:  MOVWF  x91
04672:  MOVWF  x92
04674:  MOVWF  x93
04676:  MOVWF  x94
04678:  MOVWF  x95
0467A:  MOVWF  x96
0467C:  MOVWF  x97
0467E:  MOVWF  x98
04680:  MOVWF  x99
04682:  MOVWF  x9A
04684:  CLRF   x9B
04686:  CLRF   x9C
04688:  CLRF   x9D
0468A:  MOVWF  x9E
0468C:  MOVWF  x9F
0468E:  MOVWF  xA0
04690:  MOVWF  xA1
04692:  CLRF   xA2
04694:  CLRF   xA3
04696:  CLRF   xA4
04698:  CLRF   xA5
0469A:  CLRF   xA6
0469C:  CLRF   xA7
0469E:  CLRF   xA8
046A0:  CLRF   xA9
046A2:  CLRF   xAA
046A4:  CLRF   xAB
046A6:  CLRF   xAC
046A8:  MOVWF  xAD
046AA:  MOVWF  xAE
046AC:  MOVWF  xAF
046AE:  CLRF   xB0
046B0:  CLRF   xB1
046B2:  CLRF   xB2
046B4:  CLRF   xB3
046B6:  CLRF   xB4
046B8:  CLRF   xB5
046BA:  CLRF   xB6
046BC:  CLRF   xB7
046BE:  CLRF   xB8
046C0:  CLRF   xB9
046C2:  CLRF   xBA
046C4:  CLRF   xBB
046C6:  MOVWF  xBC
046C8:  MOVWF  xBD
046CA:  MOVWF  xBE
046CC:  CLRF   xBF
046CE:  CLRF   xC0
046D0:  CLRF   xC1
046D2:  CLRF   xC2
046D4:  CLRF   xC3
046D6:  CLRF   xC4
046D8:  CLRF   xC5
046DA:  CLRF   xC6
046DC:  CLRF   xC7
046DE:  CLRF   xC8
046E0:  CLRF   xC9
046E2:  CLRF   xCA
046E4:  MOVWF  xCB
046E6:  MOVWF  xCC
046E8:  MOVWF  xCD
046EA:  CLRF   xCE
046EC:  CLRF   xCF
046EE:  CLRF   xD0
046F0:  CLRF   xD1
046F2:  CLRF   xD2
046F4:  CLRF   xD3
046F6:  CLRF   xD4
046F8:  CLRF   xD5
046FA:  CLRF   xD6
046FC:  CLRF   xD7
046FE:  CLRF   xD8
04700:  CLRF   xD9
04702:  MOVWF  xDA
04704:  MOVWF  xDB
04706:  MOVWF  xDC
04708:  MOVWF  xDD
0470A:  MOVWF  xDE
0470C:  MOVWF  xDF
0470E:  MOVWF  xE0
04710:  MOVWF  xE1
04712:  MOVWF  xE2
04714:  MOVWF  xE3
04716:  CLRF   xE4
04718:  CLRF   xE5
0471A:  CLRF   xE6
0471C:  CLRF   xE7
0471E:  CLRF   xE8
04720:  MOVWF  xE9
04722:  MOVWF  xEA
04724:  MOVWF  xEB
04726:  MOVWF  xEC
04728:  MOVWF  xED
0472A:  MOVWF  xEE
0472C:  MOVWF  xEF
0472E:  MOVWF  xF0
04730:  MOVWF  xF1
04732:  MOVWF  xF2
04734:  MOVWF  xF3
04736:  CLRF   xF4
04738:  CLRF   xF5
0473A:  CLRF   xF6
0473C:  CLRF   xF7
0473E:  MOVWF  xF8
04740:  MOVWF  xF9
04742:  MOVWF  xFA
04744:  MOVWF  xFB
04746:  MOVWF  xFC
04748:  MOVWF  xFD
0474A:  MOVWF  xFE
0474C:  MOVWF  xFF
0474E:  MOVLB  6
04750:  MOVWF  x00
04752:  MOVWF  x01
04754:  MOVWF  x02
04756:  MOVWF  x03
04758:  CLRF   x04
0475A:  CLRF   x05
0475C:  CLRF   x06
0475E:  MOVWF  x07
04760:  MOVWF  x08
04762:  MOVWF  x09
04764:  CLRF   x0A
04766:  CLRF   x0B
04768:  CLRF   x0C
0476A:  CLRF   x0D
0476C:  CLRF   x0E
0476E:  MOVWF  x0F
04770:  MOVWF  x10
04772:  MOVWF  x11
04774:  MOVWF  x12
04776:  MOVWF  x13
04778:  CLRF   x14
0477A:  CLRF   x15
0477C:  CLRF   x16
0477E:  CLRF   x17
04780:  CLRF   x18
04782:  CLRF   x19
04784:  CLRF   x1A
04786:  CLRF   x1B
04788:  CLRF   x1C
0478A:  CLRF   x1D
0478C:  CLRF   x1E
0478E:  MOVWF  x1F
04790:  MOVWF  x20
04792:  MOVWF  x21
04794:  MOVWF  x22
04796:  CLRF   x23
04798:  CLRF   x24
0479A:  CLRF   x25
0479C:  CLRF   x26
0479E:  CLRF   x27
047A0:  CLRF   x28
047A2:  CLRF   x29
047A4:  CLRF   x2A
047A6:  CLRF   x2B
047A8:  CLRF   x2C
047AA:  CLRF   x2D
047AC:  MOVWF  x2E
047AE:  MOVWF  x2F
047B0:  MOVWF  x30
047B2:  MOVWF  x31
047B4:  CLRF   x32
047B6:  CLRF   x33
047B8:  CLRF   x34
047BA:  CLRF   x35
047BC:  CLRF   x36
047BE:  CLRF   x37
047C0:  CLRF   x38
047C2:  CLRF   x39
047C4:  CLRF   x3A
047C6:  CLRF   x3B
047C8:  CLRF   x3C
047CA:  MOVWF  x3D
047CC:  MOVWF  x3E
047CE:  MOVWF  x3F
047D0:  MOVWF  x40
047D2:  CLRF   x41
047D4:  CLRF   x42
047D6:  CLRF   x43
047D8:  CLRF   x44
047DA:  CLRF   x45
047DC:  CLRF   x46
047DE:  CLRF   x47
047E0:  CLRF   x48
047E2:  CLRF   x49
047E4:  CLRF   x4A
047E6:  CLRF   x4B
047E8:  MOVWF  x4C
047EA:  MOVWF  x4D
047EC:  MOVWF  x4E
047EE:  MOVWF  x4F
047F0:  CLRF   x50
047F2:  CLRF   x51
047F4:  CLRF   x52
047F6:  CLRF   x53
047F8:  CLRF   x54
047FA:  CLRF   x55
047FC:  CLRF   x56
047FE:  CLRF   x57
04800:  CLRF   x58
04802:  CLRF   x59
04804:  CLRF   x5A
04806:  MOVWF  x5B
04808:  MOVWF  x5C
0480A:  MOVWF  x5D
0480C:  MOVWF  x5E
0480E:  CLRF   x5F
04810:  MOVWF  x60
04812:  MOVWF  x61
04814:  MOVWF  x62
04816:  CLRF   x63
04818:  CLRF   x64
0481A:  CLRF   x65
0481C:  CLRF   x66
0481E:  CLRF   x67
04820:  CLRF   x68
04822:  CLRF   x69
04824:  MOVWF  x6A
04826:  MOVWF  x6B
04828:  MOVWF  x6C
0482A:  MOVWF  x6D
0482C:  CLRF   x6E
0482E:  MOVWF  x6F
04830:  MOVWF  x70
04832:  MOVWF  x71
04834:  CLRF   x72
04836:  CLRF   x73
04838:  CLRF   x74
0483A:  CLRF   x75
0483C:  CLRF   x76
0483E:  CLRF   x77
04840:  MOVWF  x78
04842:  MOVWF  x79
04844:  MOVWF  x7A
04846:  MOVWF  x7B
04848:  CLRF   x7C
0484A:  CLRF   x7D
0484C:  MOVWF  x7E
0484E:  MOVWF  x7F
04850:  MOVWF  x80
04852:  MOVWF  x81
04854:  CLRF   x82
04856:  CLRF   x83
04858:  CLRF   x84
0485A:  CLRF   x85
0485C:  MOVWF  x86
0485E:  MOVWF  x87
04860:  MOVWF  x88
04862:  MOVWF  x89
04864:  MOVWF  x8A
04866:  CLRF   x8B
04868:  CLRF   x8C
0486A:  MOVWF  x8D
0486C:  MOVWF  x8E
0486E:  MOVWF  x8F
04870:  MOVWF  x90
04872:  MOVWF  x91
04874:  MOVWF  x92
04876:  MOVWF  x93
04878:  MOVWF  x94
0487A:  MOVWF  x95
0487C:  MOVWF  x96
0487E:  MOVWF  x97
04880:  MOVWF  x98
04882:  CLRF   x99
04884:  CLRF   x9A
04886:  CLRF   x9B
04888:  CLRF   x9C
0488A:  MOVWF  x9D
0488C:  MOVWF  x9E
0488E:  MOVWF  x9F
04890:  MOVWF  xA0
04892:  MOVWF  xA1
04894:  MOVWF  xA2
04896:  MOVWF  xA3
04898:  MOVWF  xA4
0489A:  MOVWF  xA5
0489C:  MOVWF  xA6
0489E:  CLRF   xA7
048A0:  CLRF   xA8
048A2:  CLRF   xA9
048A4:  CLRF   xAA
048A6:  CLRF   xAB
048A8:  CLRF   xAC
048AA:  CLRF   xAD
048AC:  MOVWF  xAE
048AE:  MOVWF  xAF
048B0:  MOVWF  xB0
048B2:  MOVWF  xB1
048B4:  MOVWF  xB2
048B6:  MOVWF  xB3
048B8:  CLRF   xB4
048BA:  CLRF   xB5
048BC:  CLRF   xB6
048BE:  CLRF   xB7
048C0:  CLRF   xB8
048C2:  CLRF   xB9
048C4:  CLRF   xBA
048C6:  CLRF   xBB
048C8:  CLRF   xBC
048CA:  CLRF   xBD
048CC:  CLRF   xBE
048CE:  CLRF   xBF
048D0:  CLRF   xC0
048D2:  CLRF   xC1
048D4:  CLRF   xC2
048D6:  CLRF   xC3
048D8:  CLRF   xC4
048DA:  CLRF   xC5
048DC:  CLRF   xC6
048DE:  CLRF   xC7
048E0:  CLRF   xC8
048E2:  CLRF   xC9
048E4:  CLRF   xCA
048E6:  CLRF   xCB
048E8:  CLRF   xCC
048EA:  CLRF   xCD
048EC:  CLRF   xCE
048EE:  CLRF   xCF
048F0:  CLRF   xD0
048F2:  CLRF   xD1
048F4:  CLRF   xD2
048F6:  CLRF   xD3
048F8:  CLRF   xD4
048FA:  CLRF   xD5
048FC:  CLRF   xD6
....................     
....................     for(n=0; n<375; n++) //draw a block
048FE:  MOVLB  5
04900:  CLRF   x5F
04902:  CLRF   x5E
04904:  MOVF   x5F,W
04906:  SUBLW  01
04908:  BNC   496C
0490A:  BNZ   4912
0490C:  MOVF   x5E,W
0490E:  SUBLW  76
04910:  BNC   496C
....................     {
....................        if(Five[n] == 1)
04912:  MOVLW  60
04914:  ADDWF  x5E,W
04916:  MOVWF  3FE9
04918:  MOVLW  05
0491A:  ADDWFC x5F,W
0491C:  MOVWF  3FEA
0491E:  DECFSZ 3FEF,W
04920:  BRA    4944
....................        {
....................             Data_Out(0xFF);
04922:  MOVLB  8
04924:  SETF   x54
04926:  MOVLB  0
04928:  CALL   0636
....................             Data_Out(0xFF);
0492C:  MOVLB  8
0492E:  SETF   x54
04930:  MOVLB  0
04932:  CALL   0636
....................             Data_Out(0xFF);
04936:  MOVLB  8
04938:  SETF   x54
0493A:  MOVLB  0
0493C:  CALL   0636
....................        } else
04940:  BRA    4962
04942:  MOVLB  5
....................        {
....................             Data_Out(0x00);
04944:  MOVLB  8
04946:  CLRF   x54
04948:  MOVLB  0
0494A:  CALL   0636
....................             Data_Out(0x00);
0494E:  MOVLB  8
04950:  CLRF   x54
04952:  MOVLB  0
04954:  CALL   0636
....................             Data_Out(0x00);
04958:  MOVLB  8
0495A:  CLRF   x54
0495C:  MOVLB  0
0495E:  CALL   0636
....................        }
04962:  MOVLB  5
04964:  INCF   x5E,F
04966:  BTFSC  3FD8.2
04968:  INCF   x5F,F
0496A:  BRA    4904
....................        
....................     } 
0496C:  MOVLB  0
0496E:  GOTO   57D2 (RETURN)
.................... }
.................... 
.................... 
.................... /**
....................     Draw a 6 digit
.................... **/
.................... void    Draw_Six(void)
.................... {
....................     uint16_t    n;
....................     uint8_t Six[375]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,
....................     0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,
....................     0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,
....................     0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,
....................     0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,
....................     0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,
....................     0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,
....................     0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
....................     0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,
....................     0,1,1,1,1,1,0,0,0,0,0,1,1,1,1,
....................     0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,
....................     0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,
....................     0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,
....................     0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,
....................     0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,
....................     0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,
....................     0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,
....................     0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
04972:  MOVLB  5
04974:  CLRF   x60
04976:  CLRF   x61
04978:  CLRF   x62
0497A:  CLRF   x63
0497C:  CLRF   x64
0497E:  CLRF   x65
04980:  CLRF   x66
04982:  CLRF   x67
04984:  CLRF   x68
04986:  CLRF   x69
04988:  CLRF   x6A
0498A:  CLRF   x6B
0498C:  CLRF   x6C
0498E:  CLRF   x6D
04990:  CLRF   x6E
04992:  CLRF   x6F
04994:  CLRF   x70
04996:  CLRF   x71
04998:  CLRF   x72
0499A:  CLRF   x73
0499C:  CLRF   x74
0499E:  MOVLW  01
049A0:  MOVWF  x75
049A2:  MOVWF  x76
049A4:  MOVWF  x77
049A6:  MOVWF  x78
049A8:  MOVWF  x79
049AA:  CLRF   x7A
049AC:  CLRF   x7B
049AE:  CLRF   x7C
049B0:  CLRF   x7D
049B2:  CLRF   x7E
049B4:  CLRF   x7F
049B6:  CLRF   x80
049B8:  CLRF   x81
049BA:  CLRF   x82
049BC:  MOVWF  x83
049BE:  MOVWF  x84
049C0:  MOVWF  x85
049C2:  MOVWF  x86
049C4:  MOVWF  x87
049C6:  MOVWF  x88
049C8:  MOVWF  x89
049CA:  CLRF   x8A
049CC:  CLRF   x8B
049CE:  CLRF   x8C
049D0:  CLRF   x8D
049D2:  CLRF   x8E
049D4:  CLRF   x8F
049D6:  CLRF   x90
049D8:  MOVWF  x91
049DA:  MOVWF  x92
049DC:  MOVWF  x93
049DE:  MOVWF  x94
049E0:  MOVWF  x95
049E2:  MOVWF  x96
049E4:  MOVWF  x97
049E6:  MOVWF  x98
049E8:  MOVWF  x99
049EA:  CLRF   x9A
049EC:  CLRF   x9B
049EE:  CLRF   x9C
049F0:  CLRF   x9D
049F2:  CLRF   x9E
049F4:  MOVWF  x9F
049F6:  MOVWF  xA0
049F8:  MOVWF  xA1
049FA:  MOVWF  xA2
049FC:  MOVWF  xA3
049FE:  MOVWF  xA4
04A00:  MOVWF  xA5
04A02:  MOVWF  xA6
04A04:  MOVWF  xA7
04A06:  MOVWF  xA8
04A08:  MOVWF  xA9
04A0A:  CLRF   xAA
04A0C:  CLRF   xAB
04A0E:  CLRF   xAC
04A10:  CLRF   xAD
04A12:  MOVWF  xAE
04A14:  MOVWF  xAF
04A16:  MOVWF  xB0
04A18:  CLRF   xB1
04A1A:  CLRF   xB2
04A1C:  CLRF   xB3
04A1E:  CLRF   xB4
04A20:  CLRF   xB5
04A22:  CLRF   xB6
04A24:  MOVWF  xB7
04A26:  MOVWF  xB8
04A28:  MOVWF  xB9
04A2A:  CLRF   xBA
04A2C:  CLRF   xBB
04A2E:  MOVWF  xBC
04A30:  MOVWF  xBD
04A32:  MOVWF  xBE
04A34:  CLRF   xBF
04A36:  CLRF   xC0
04A38:  CLRF   xC1
04A3A:  CLRF   xC2
04A3C:  CLRF   xC3
04A3E:  CLRF   xC4
04A40:  CLRF   xC5
04A42:  MOVWF  xC6
04A44:  MOVWF  xC7
04A46:  MOVWF  xC8
04A48:  CLRF   xC9
04A4A:  CLRF   xCA
04A4C:  MOVWF  xCB
04A4E:  MOVWF  xCC
04A50:  MOVWF  xCD
04A52:  CLRF   xCE
04A54:  CLRF   xCF
04A56:  CLRF   xD0
04A58:  CLRF   xD1
04A5A:  CLRF   xD2
04A5C:  CLRF   xD3
04A5E:  CLRF   xD4
04A60:  CLRF   xD5
04A62:  CLRF   xD6
04A64:  CLRF   xD7
04A66:  CLRF   xD8
04A68:  CLRF   xD9
04A6A:  MOVWF  xDA
04A6C:  MOVWF  xDB
04A6E:  MOVWF  xDC
04A70:  CLRF   xDD
04A72:  CLRF   xDE
04A74:  CLRF   xDF
04A76:  CLRF   xE0
04A78:  CLRF   xE1
04A7A:  CLRF   xE2
04A7C:  CLRF   xE3
04A7E:  CLRF   xE4
04A80:  CLRF   xE5
04A82:  CLRF   xE6
04A84:  CLRF   xE7
04A86:  CLRF   xE8
04A88:  MOVWF  xE9
04A8A:  MOVWF  xEA
04A8C:  MOVWF  xEB
04A8E:  CLRF   xEC
04A90:  CLRF   xED
04A92:  CLRF   xEE
04A94:  CLRF   xEF
04A96:  CLRF   xF0
04A98:  CLRF   xF1
04A9A:  CLRF   xF2
04A9C:  CLRF   xF3
04A9E:  CLRF   xF4
04AA0:  CLRF   xF5
04AA2:  CLRF   xF6
04AA4:  MOVWF  xF7
04AA6:  MOVWF  xF8
04AA8:  MOVWF  xF9
04AAA:  MOVWF  xFA
04AAC:  MOVWF  xFB
04AAE:  MOVWF  xFC
04AB0:  MOVWF  xFD
04AB2:  MOVWF  xFE
04AB4:  MOVWF  xFF
04AB6:  MOVLB  6
04AB8:  MOVWF  x00
04ABA:  CLRF   x01
04ABC:  CLRF   x02
04ABE:  CLRF   x03
04AC0:  CLRF   x04
04AC2:  CLRF   x05
04AC4:  MOVWF  x06
04AC6:  MOVWF  x07
04AC8:  MOVWF  x08
04ACA:  MOVWF  x09
04ACC:  MOVWF  x0A
04ACE:  MOVWF  x0B
04AD0:  MOVWF  x0C
04AD2:  MOVWF  x0D
04AD4:  MOVWF  x0E
04AD6:  MOVWF  x0F
04AD8:  MOVWF  x10
04ADA:  MOVWF  x11
04ADC:  CLRF   x12
04ADE:  CLRF   x13
04AE0:  CLRF   x14
04AE2:  MOVWF  x15
04AE4:  MOVWF  x16
04AE6:  MOVWF  x17
04AE8:  MOVWF  x18
04AEA:  MOVWF  x19
04AEC:  MOVWF  x1A
04AEE:  MOVWF  x1B
04AF0:  MOVWF  x1C
04AF2:  MOVWF  x1D
04AF4:  MOVWF  x1E
04AF6:  MOVWF  x1F
04AF8:  MOVWF  x20
04AFA:  MOVWF  x21
04AFC:  CLRF   x22
04AFE:  CLRF   x23
04B00:  MOVWF  x24
04B02:  MOVWF  x25
04B04:  MOVWF  x26
04B06:  MOVWF  x27
04B08:  MOVWF  x28
04B0A:  MOVWF  x29
04B0C:  CLRF   x2A
04B0E:  CLRF   x2B
04B10:  CLRF   x2C
04B12:  MOVWF  x2D
04B14:  MOVWF  x2E
04B16:  MOVWF  x2F
04B18:  MOVWF  x30
04B1A:  MOVWF  x31
04B1C:  CLRF   x32
04B1E:  MOVWF  x33
04B20:  MOVWF  x34
04B22:  MOVWF  x35
04B24:  MOVWF  x36
04B26:  MOVWF  x37
04B28:  CLRF   x38
04B2A:  CLRF   x39
04B2C:  CLRF   x3A
04B2E:  CLRF   x3B
04B30:  CLRF   x3C
04B32:  MOVWF  x3D
04B34:  MOVWF  x3E
04B36:  MOVWF  x3F
04B38:  MOVWF  x40
04B3A:  CLRF   x41
04B3C:  MOVWF  x42
04B3E:  MOVWF  x43
04B40:  MOVWF  x44
04B42:  MOVWF  x45
04B44:  CLRF   x46
04B46:  CLRF   x47
04B48:  CLRF   x48
04B4A:  CLRF   x49
04B4C:  CLRF   x4A
04B4E:  CLRF   x4B
04B50:  MOVWF  x4C
04B52:  MOVWF  x4D
04B54:  MOVWF  x4E
04B56:  MOVWF  x4F
04B58:  CLRF   x50
04B5A:  MOVWF  x51
04B5C:  MOVWF  x52
04B5E:  MOVWF  x53
04B60:  MOVWF  x54
04B62:  CLRF   x55
04B64:  CLRF   x56
04B66:  CLRF   x57
04B68:  CLRF   x58
04B6A:  CLRF   x59
04B6C:  CLRF   x5A
04B6E:  MOVWF  x5B
04B70:  MOVWF  x5C
04B72:  MOVWF  x5D
04B74:  MOVWF  x5E
04B76:  CLRF   x5F
04B78:  MOVWF  x60
04B7A:  MOVWF  x61
04B7C:  MOVWF  x62
04B7E:  MOVWF  x63
04B80:  CLRF   x64
04B82:  CLRF   x65
04B84:  CLRF   x66
04B86:  CLRF   x67
04B88:  CLRF   x68
04B8A:  CLRF   x69
04B8C:  MOVWF  x6A
04B8E:  MOVWF  x6B
04B90:  MOVWF  x6C
04B92:  MOVWF  x6D
04B94:  CLRF   x6E
04B96:  CLRF   x6F
04B98:  MOVWF  x70
04B9A:  MOVWF  x71
04B9C:  MOVWF  x72
04B9E:  CLRF   x73
04BA0:  CLRF   x74
04BA2:  CLRF   x75
04BA4:  CLRF   x76
04BA6:  CLRF   x77
04BA8:  CLRF   x78
04BAA:  MOVWF  x79
04BAC:  MOVWF  x7A
04BAE:  MOVWF  x7B
04BB0:  MOVWF  x7C
04BB2:  CLRF   x7D
04BB4:  CLRF   x7E
04BB6:  MOVWF  x7F
04BB8:  MOVWF  x80
04BBA:  MOVWF  x81
04BBC:  CLRF   x82
04BBE:  CLRF   x83
04BC0:  CLRF   x84
04BC2:  CLRF   x85
04BC4:  CLRF   x86
04BC6:  CLRF   x87
04BC8:  MOVWF  x88
04BCA:  MOVWF  x89
04BCC:  MOVWF  x8A
04BCE:  CLRF   x8B
04BD0:  CLRF   x8C
04BD2:  CLRF   x8D
04BD4:  MOVWF  x8E
04BD6:  MOVWF  x8F
04BD8:  MOVWF  x90
04BDA:  MOVWF  x91
04BDC:  CLRF   x92
04BDE:  CLRF   x93
04BE0:  CLRF   x94
04BE2:  CLRF   x95
04BE4:  MOVWF  x96
04BE6:  MOVWF  x97
04BE8:  MOVWF  x98
04BEA:  MOVWF  x99
04BEC:  CLRF   x9A
04BEE:  CLRF   x9B
04BF0:  CLRF   x9C
04BF2:  CLRF   x9D
04BF4:  MOVWF  x9E
04BF6:  MOVWF  x9F
04BF8:  MOVWF  xA0
04BFA:  MOVWF  xA1
04BFC:  MOVWF  xA2
04BFE:  MOVWF  xA3
04C00:  MOVWF  xA4
04C02:  MOVWF  xA5
04C04:  MOVWF  xA6
04C06:  MOVWF  xA7
04C08:  CLRF   xA8
04C0A:  CLRF   xA9
04C0C:  CLRF   xAA
04C0E:  CLRF   xAB
04C10:  CLRF   xAC
04C12:  CLRF   xAD
04C14:  MOVWF  xAE
04C16:  MOVWF  xAF
04C18:  MOVWF  xB0
04C1A:  MOVWF  xB1
04C1C:  MOVWF  xB2
04C1E:  MOVWF  xB3
04C20:  MOVWF  xB4
04C22:  MOVWF  xB5
04C24:  CLRF   xB6
04C26:  CLRF   xB7
04C28:  CLRF   xB8
04C2A:  CLRF   xB9
04C2C:  CLRF   xBA
04C2E:  CLRF   xBB
04C30:  CLRF   xBC
04C32:  CLRF   xBD
04C34:  CLRF   xBE
04C36:  MOVWF  xBF
04C38:  MOVWF  xC0
04C3A:  MOVWF  xC1
04C3C:  MOVWF  xC2
04C3E:  MOVWF  xC3
04C40:  CLRF   xC4
04C42:  CLRF   xC5
04C44:  CLRF   xC6
04C46:  CLRF   xC7
04C48:  CLRF   xC8
04C4A:  CLRF   xC9
04C4C:  CLRF   xCA
04C4E:  CLRF   xCB
04C50:  CLRF   xCC
04C52:  CLRF   xCD
04C54:  CLRF   xCE
04C56:  CLRF   xCF
04C58:  CLRF   xD0
04C5A:  CLRF   xD1
04C5C:  CLRF   xD2
04C5E:  CLRF   xD3
04C60:  CLRF   xD4
04C62:  CLRF   xD5
04C64:  CLRF   xD6
....................     
....................     for(n=0; n<375; n++) //draw a block
04C66:  MOVLB  5
04C68:  CLRF   x5F
04C6A:  CLRF   x5E
04C6C:  MOVF   x5F,W
04C6E:  SUBLW  01
04C70:  BNC   4CD4
04C72:  BNZ   4C7A
04C74:  MOVF   x5E,W
04C76:  SUBLW  76
04C78:  BNC   4CD4
....................     {
....................        if(Six[n] == 1)
04C7A:  MOVLW  60
04C7C:  ADDWF  x5E,W
04C7E:  MOVWF  3FE9
04C80:  MOVLW  05
04C82:  ADDWFC x5F,W
04C84:  MOVWF  3FEA
04C86:  DECFSZ 3FEF,W
04C88:  BRA    4CAC
....................        {
....................             Data_Out(0xFF);
04C8A:  MOVLB  8
04C8C:  SETF   x54
04C8E:  MOVLB  0
04C90:  CALL   0636
....................             Data_Out(0xFF);
04C94:  MOVLB  8
04C96:  SETF   x54
04C98:  MOVLB  0
04C9A:  CALL   0636
....................             Data_Out(0xFF);
04C9E:  MOVLB  8
04CA0:  SETF   x54
04CA2:  MOVLB  0
04CA4:  CALL   0636
....................        } else
04CA8:  BRA    4CCA
04CAA:  MOVLB  5
....................        {
....................             Data_Out(0x00);
04CAC:  MOVLB  8
04CAE:  CLRF   x54
04CB0:  MOVLB  0
04CB2:  CALL   0636
....................             Data_Out(0x00);
04CB6:  MOVLB  8
04CB8:  CLRF   x54
04CBA:  MOVLB  0
04CBC:  CALL   0636
....................             Data_Out(0x00);
04CC0:  MOVLB  8
04CC2:  CLRF   x54
04CC4:  MOVLB  0
04CC6:  CALL   0636
....................        }
04CCA:  MOVLB  5
04CCC:  INCF   x5E,F
04CCE:  BTFSC  3FD8.2
04CD0:  INCF   x5F,F
04CD2:  BRA    4C6C
....................        
....................     } 
04CD4:  MOVLB  0
04CD6:  GOTO   57DA (RETURN)
.................... }
.................... 
.................... 
.................... /**
....................     Draw a 7 digit
.................... **/
.................... void    Draw_Seven(void)
.................... {
....................     uint16_t    n;
....................     uint8_t Seven[375]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,
....................     0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,
....................     0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,
....................     0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,
....................     0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,
....................     0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,
....................     0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,
....................     0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,
....................     0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,
....................     0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,
....................     0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,
....................     0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
04CDA:  MOVLB  5
04CDC:  CLRF   x60
04CDE:  CLRF   x61
04CE0:  CLRF   x62
04CE2:  CLRF   x63
04CE4:  CLRF   x64
04CE6:  CLRF   x65
04CE8:  CLRF   x66
04CEA:  CLRF   x67
04CEC:  CLRF   x68
04CEE:  CLRF   x69
04CF0:  CLRF   x6A
04CF2:  CLRF   x6B
04CF4:  CLRF   x6C
04CF6:  CLRF   x6D
04CF8:  CLRF   x6E
04CFA:  CLRF   x6F
04CFC:  MOVLW  01
04CFE:  MOVWF  x70
04D00:  MOVWF  x71
04D02:  MOVWF  x72
04D04:  MOVWF  x73
04D06:  MOVWF  x74
04D08:  MOVWF  x75
04D0A:  MOVWF  x76
04D0C:  MOVWF  x77
04D0E:  MOVWF  x78
04D10:  MOVWF  x79
04D12:  MOVWF  x7A
04D14:  MOVWF  x7B
04D16:  MOVWF  x7C
04D18:  MOVWF  x7D
04D1A:  CLRF   x7E
04D1C:  MOVWF  x7F
04D1E:  MOVWF  x80
04D20:  MOVWF  x81
04D22:  MOVWF  x82
04D24:  MOVWF  x83
04D26:  MOVWF  x84
04D28:  MOVWF  x85
04D2A:  MOVWF  x86
04D2C:  MOVWF  x87
04D2E:  MOVWF  x88
04D30:  MOVWF  x89
04D32:  MOVWF  x8A
04D34:  MOVWF  x8B
04D36:  MOVWF  x8C
04D38:  CLRF   x8D
04D3A:  MOVWF  x8E
04D3C:  MOVWF  x8F
04D3E:  MOVWF  x90
04D40:  MOVWF  x91
04D42:  MOVWF  x92
04D44:  MOVWF  x93
04D46:  MOVWF  x94
04D48:  MOVWF  x95
04D4A:  MOVWF  x96
04D4C:  MOVWF  x97
04D4E:  MOVWF  x98
04D50:  MOVWF  x99
04D52:  MOVWF  x9A
04D54:  MOVWF  x9B
04D56:  CLRF   x9C
04D58:  CLRF   x9D
04D5A:  CLRF   x9E
04D5C:  CLRF   x9F
04D5E:  CLRF   xA0
04D60:  CLRF   xA1
04D62:  CLRF   xA2
04D64:  CLRF   xA3
04D66:  CLRF   xA4
04D68:  CLRF   xA5
04D6A:  MOVWF  xA6
04D6C:  MOVWF  xA7
04D6E:  MOVWF  xA8
04D70:  MOVWF  xA9
04D72:  CLRF   xAA
04D74:  CLRF   xAB
04D76:  CLRF   xAC
04D78:  CLRF   xAD
04D7A:  CLRF   xAE
04D7C:  CLRF   xAF
04D7E:  CLRF   xB0
04D80:  CLRF   xB1
04D82:  CLRF   xB2
04D84:  CLRF   xB3
04D86:  MOVWF  xB4
04D88:  MOVWF  xB5
04D8A:  MOVWF  xB6
04D8C:  MOVWF  xB7
04D8E:  MOVWF  xB8
04D90:  CLRF   xB9
04D92:  CLRF   xBA
04D94:  CLRF   xBB
04D96:  CLRF   xBC
04D98:  CLRF   xBD
04D9A:  CLRF   xBE
04D9C:  CLRF   xBF
04D9E:  CLRF   xC0
04DA0:  CLRF   xC1
04DA2:  MOVWF  xC2
04DA4:  MOVWF  xC3
04DA6:  MOVWF  xC4
04DA8:  MOVWF  xC5
04DAA:  MOVWF  xC6
04DAC:  CLRF   xC7
04DAE:  CLRF   xC8
04DB0:  CLRF   xC9
04DB2:  CLRF   xCA
04DB4:  CLRF   xCB
04DB6:  CLRF   xCC
04DB8:  CLRF   xCD
04DBA:  CLRF   xCE
04DBC:  CLRF   xCF
04DBE:  CLRF   xD0
04DC0:  MOVWF  xD1
04DC2:  MOVWF  xD2
04DC4:  MOVWF  xD3
04DC6:  MOVWF  xD4
04DC8:  CLRF   xD5
04DCA:  CLRF   xD6
04DCC:  CLRF   xD7
04DCE:  CLRF   xD8
04DD0:  CLRF   xD9
04DD2:  CLRF   xDA
04DD4:  CLRF   xDB
04DD6:  CLRF   xDC
04DD8:  CLRF   xDD
04DDA:  CLRF   xDE
04DDC:  CLRF   xDF
04DDE:  MOVWF  xE0
04DE0:  MOVWF  xE1
04DE2:  MOVWF  xE2
04DE4:  MOVWF  xE3
04DE6:  CLRF   xE4
04DE8:  CLRF   xE5
04DEA:  CLRF   xE6
04DEC:  CLRF   xE7
04DEE:  CLRF   xE8
04DF0:  CLRF   xE9
04DF2:  CLRF   xEA
04DF4:  CLRF   xEB
04DF6:  CLRF   xEC
04DF8:  CLRF   xED
04DFA:  CLRF   xEE
04DFC:  MOVWF  xEF
04DFE:  MOVWF  xF0
04E00:  MOVWF  xF1
04E02:  MOVWF  xF2
04E04:  CLRF   xF3
04E06:  CLRF   xF4
04E08:  CLRF   xF5
04E0A:  CLRF   xF6
04E0C:  CLRF   xF7
04E0E:  CLRF   xF8
04E10:  CLRF   xF9
04E12:  CLRF   xFA
04E14:  CLRF   xFB
04E16:  CLRF   xFC
04E18:  MOVWF  xFD
04E1A:  MOVWF  xFE
04E1C:  MOVWF  xFF
04E1E:  MOVLB  6
04E20:  MOVWF  x00
04E22:  CLRF   x01
04E24:  CLRF   x02
04E26:  CLRF   x03
04E28:  CLRF   x04
04E2A:  CLRF   x05
04E2C:  CLRF   x06
04E2E:  CLRF   x07
04E30:  CLRF   x08
04E32:  CLRF   x09
04E34:  CLRF   x0A
04E36:  CLRF   x0B
04E38:  MOVWF  x0C
04E3A:  MOVWF  x0D
04E3C:  MOVWF  x0E
04E3E:  MOVWF  x0F
04E40:  CLRF   x10
04E42:  CLRF   x11
04E44:  CLRF   x12
04E46:  CLRF   x13
04E48:  CLRF   x14
04E4A:  CLRF   x15
04E4C:  CLRF   x16
04E4E:  CLRF   x17
04E50:  CLRF   x18
04E52:  CLRF   x19
04E54:  MOVWF  x1A
04E56:  MOVWF  x1B
04E58:  MOVWF  x1C
04E5A:  MOVWF  x1D
04E5C:  CLRF   x1E
04E5E:  CLRF   x1F
04E60:  CLRF   x20
04E62:  CLRF   x21
04E64:  CLRF   x22
04E66:  CLRF   x23
04E68:  CLRF   x24
04E6A:  CLRF   x25
04E6C:  CLRF   x26
04E6E:  CLRF   x27
04E70:  CLRF   x28
04E72:  MOVWF  x29
04E74:  MOVWF  x2A
04E76:  MOVWF  x2B
04E78:  MOVWF  x2C
04E7A:  CLRF   x2D
04E7C:  CLRF   x2E
04E7E:  CLRF   x2F
04E80:  CLRF   x30
04E82:  CLRF   x31
04E84:  CLRF   x32
04E86:  CLRF   x33
04E88:  CLRF   x34
04E8A:  CLRF   x35
04E8C:  CLRF   x36
04E8E:  CLRF   x37
04E90:  MOVWF  x38
04E92:  MOVWF  x39
04E94:  MOVWF  x3A
04E96:  MOVWF  x3B
04E98:  CLRF   x3C
04E9A:  CLRF   x3D
04E9C:  CLRF   x3E
04E9E:  CLRF   x3F
04EA0:  CLRF   x40
04EA2:  CLRF   x41
04EA4:  CLRF   x42
04EA6:  CLRF   x43
04EA8:  CLRF   x44
04EAA:  CLRF   x45
04EAC:  MOVWF  x46
04EAE:  MOVWF  x47
04EB0:  MOVWF  x48
04EB2:  MOVWF  x49
04EB4:  CLRF   x4A
04EB6:  CLRF   x4B
04EB8:  CLRF   x4C
04EBA:  CLRF   x4D
04EBC:  CLRF   x4E
04EBE:  CLRF   x4F
04EC0:  CLRF   x50
04EC2:  CLRF   x51
04EC4:  CLRF   x52
04EC6:  CLRF   x53
04EC8:  CLRF   x54
04ECA:  MOVWF  x55
04ECC:  MOVWF  x56
04ECE:  MOVWF  x57
04ED0:  MOVWF  x58
04ED2:  CLRF   x59
04ED4:  CLRF   x5A
04ED6:  CLRF   x5B
04ED8:  CLRF   x5C
04EDA:  CLRF   x5D
04EDC:  CLRF   x5E
04EDE:  CLRF   x5F
04EE0:  CLRF   x60
04EE2:  CLRF   x61
04EE4:  CLRF   x62
04EE6:  CLRF   x63
04EE8:  MOVWF  x64
04EEA:  MOVWF  x65
04EEC:  MOVWF  x66
04EEE:  MOVWF  x67
04EF0:  CLRF   x68
04EF2:  CLRF   x69
04EF4:  CLRF   x6A
04EF6:  CLRF   x6B
04EF8:  CLRF   x6C
04EFA:  CLRF   x6D
04EFC:  CLRF   x6E
04EFE:  CLRF   x6F
04F00:  CLRF   x70
04F02:  CLRF   x71
04F04:  MOVWF  x72
04F06:  MOVWF  x73
04F08:  MOVWF  x74
04F0A:  MOVWF  x75
04F0C:  CLRF   x76
04F0E:  CLRF   x77
04F10:  CLRF   x78
04F12:  CLRF   x79
04F14:  CLRF   x7A
04F16:  CLRF   x7B
04F18:  CLRF   x7C
04F1A:  CLRF   x7D
04F1C:  CLRF   x7E
04F1E:  CLRF   x7F
04F20:  CLRF   x80
04F22:  MOVWF  x81
04F24:  MOVWF  x82
04F26:  MOVWF  x83
04F28:  MOVWF  x84
04F2A:  CLRF   x85
04F2C:  CLRF   x86
04F2E:  CLRF   x87
04F30:  CLRF   x88
04F32:  CLRF   x89
04F34:  CLRF   x8A
04F36:  CLRF   x8B
04F38:  CLRF   x8C
04F3A:  CLRF   x8D
04F3C:  CLRF   x8E
04F3E:  CLRF   x8F
04F40:  MOVWF  x90
04F42:  MOVWF  x91
04F44:  MOVWF  x92
04F46:  MOVWF  x93
04F48:  CLRF   x94
04F4A:  CLRF   x95
04F4C:  CLRF   x96
04F4E:  CLRF   x97
04F50:  CLRF   x98
04F52:  CLRF   x99
04F54:  CLRF   x9A
04F56:  CLRF   x9B
04F58:  CLRF   x9C
04F5A:  CLRF   x9D
04F5C:  CLRF   x9E
04F5E:  MOVWF  x9F
04F60:  MOVWF  xA0
04F62:  MOVWF  xA1
04F64:  MOVWF  xA2
04F66:  CLRF   xA3
04F68:  CLRF   xA4
04F6A:  CLRF   xA5
04F6C:  CLRF   xA6
04F6E:  CLRF   xA7
04F70:  CLRF   xA8
04F72:  CLRF   xA9
04F74:  CLRF   xAA
04F76:  CLRF   xAB
04F78:  CLRF   xAC
04F7A:  CLRF   xAD
04F7C:  MOVWF  xAE
04F7E:  MOVWF  xAF
04F80:  MOVWF  xB0
04F82:  MOVWF  xB1
04F84:  CLRF   xB2
04F86:  CLRF   xB3
04F88:  CLRF   xB4
04F8A:  CLRF   xB5
04F8C:  CLRF   xB6
04F8E:  CLRF   xB7
04F90:  CLRF   xB8
04F92:  CLRF   xB9
04F94:  CLRF   xBA
04F96:  CLRF   xBB
04F98:  CLRF   xBC
04F9A:  MOVWF  xBD
04F9C:  MOVWF  xBE
04F9E:  MOVWF  xBF
04FA0:  MOVWF  xC0
04FA2:  CLRF   xC1
04FA4:  CLRF   xC2
04FA6:  CLRF   xC3
04FA8:  CLRF   xC4
04FAA:  CLRF   xC5
04FAC:  CLRF   xC6
04FAE:  CLRF   xC7
04FB0:  CLRF   xC8
04FB2:  CLRF   xC9
04FB4:  CLRF   xCA
04FB6:  CLRF   xCB
04FB8:  CLRF   xCC
04FBA:  CLRF   xCD
04FBC:  CLRF   xCE
04FBE:  CLRF   xCF
04FC0:  CLRF   xD0
04FC2:  CLRF   xD1
04FC4:  CLRF   xD2
04FC6:  CLRF   xD3
04FC8:  CLRF   xD4
04FCA:  CLRF   xD5
04FCC:  CLRF   xD6
....................     
....................     for(n=0; n<375; n++) //draw a block
04FCE:  MOVLB  5
04FD0:  CLRF   x5F
04FD2:  CLRF   x5E
04FD4:  MOVF   x5F,W
04FD6:  SUBLW  01
04FD8:  BNC   503C
04FDA:  BNZ   4FE2
04FDC:  MOVF   x5E,W
04FDE:  SUBLW  76
04FE0:  BNC   503C
....................     {
....................        if(Seven[n] == 1)
04FE2:  MOVLW  60
04FE4:  ADDWF  x5E,W
04FE6:  MOVWF  3FE9
04FE8:  MOVLW  05
04FEA:  ADDWFC x5F,W
04FEC:  MOVWF  3FEA
04FEE:  DECFSZ 3FEF,W
04FF0:  BRA    5014
....................        {
....................             Data_Out(0xFF);
04FF2:  MOVLB  8
04FF4:  SETF   x54
04FF6:  MOVLB  0
04FF8:  CALL   0636
....................             Data_Out(0xFF);
04FFC:  MOVLB  8
04FFE:  SETF   x54
05000:  MOVLB  0
05002:  CALL   0636
....................             Data_Out(0xFF);
05006:  MOVLB  8
05008:  SETF   x54
0500A:  MOVLB  0
0500C:  CALL   0636
....................        } else
05010:  BRA    5032
05012:  MOVLB  5
....................        {
....................             Data_Out(0x00);
05014:  MOVLB  8
05016:  CLRF   x54
05018:  MOVLB  0
0501A:  CALL   0636
....................             Data_Out(0x00);
0501E:  MOVLB  8
05020:  CLRF   x54
05022:  MOVLB  0
05024:  CALL   0636
....................             Data_Out(0x00);
05028:  MOVLB  8
0502A:  CLRF   x54
0502C:  MOVLB  0
0502E:  CALL   0636
....................        }
05032:  MOVLB  5
05034:  INCF   x5E,F
05036:  BTFSC  3FD8.2
05038:  INCF   x5F,F
0503A:  BRA    4FD4
....................        
....................     } 
0503C:  MOVLB  0
0503E:  GOTO   57E2 (RETURN)
.................... }
.................... 
.................... 
.................... /**
....................     Draw a 8 digit
.................... **/
.................... void    Draw_Eight(void)
.................... {
....................     uint16_t    n;
....................     uint8_t Eight[375]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
....................     1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,
....................     1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,
....................     1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,
....................     1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,
....................     0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,
....................     1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,
....................     1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,
....................     1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,
....................     1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,
....................     1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,
....................     1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,
....................     1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,0,0,0,0,0};
05042:  MOVLB  5
05044:  CLRF   x60
05046:  CLRF   x61
05048:  CLRF   x62
0504A:  CLRF   x63
0504C:  CLRF   x64
0504E:  CLRF   x65
05050:  CLRF   x66
05052:  CLRF   x67
05054:  CLRF   x68
05056:  CLRF   x69
05058:  CLRF   x6A
0505A:  CLRF   x6B
0505C:  CLRF   x6C
0505E:  CLRF   x6D
05060:  CLRF   x6E
05062:  CLRF   x6F
05064:  CLRF   x70
05066:  CLRF   x71
05068:  CLRF   x72
0506A:  CLRF   x73
0506C:  MOVLW  01
0506E:  MOVWF  x74
05070:  MOVWF  x75
05072:  MOVWF  x76
05074:  MOVWF  x77
05076:  MOVWF  x78
05078:  CLRF   x79
0507A:  CLRF   x7A
0507C:  CLRF   x7B
0507E:  CLRF   x7C
05080:  CLRF   x7D
05082:  CLRF   x7E
05084:  CLRF   x7F
05086:  CLRF   x80
05088:  MOVWF  x81
0508A:  MOVWF  x82
0508C:  MOVWF  x83
0508E:  MOVWF  x84
05090:  MOVWF  x85
05092:  MOVWF  x86
05094:  MOVWF  x87
05096:  MOVWF  x88
05098:  MOVWF  x89
0509A:  CLRF   x8A
0509C:  CLRF   x8B
0509E:  CLRF   x8C
050A0:  CLRF   x8D
050A2:  CLRF   x8E
050A4:  MOVWF  x8F
050A6:  MOVWF  x90
050A8:  MOVWF  x91
050AA:  MOVWF  x92
050AC:  MOVWF  x93
050AE:  MOVWF  x94
050B0:  MOVWF  x95
050B2:  MOVWF  x96
050B4:  MOVWF  x97
050B6:  MOVWF  x98
050B8:  MOVWF  x99
050BA:  CLRF   x9A
050BC:  CLRF   x9B
050BE:  CLRF   x9C
050C0:  MOVWF  x9D
050C2:  MOVWF  x9E
050C4:  MOVWF  x9F
050C6:  MOVWF  xA0
050C8:  MOVWF  xA1
050CA:  MOVWF  xA2
050CC:  MOVWF  xA3
050CE:  MOVWF  xA4
050D0:  MOVWF  xA5
050D2:  MOVWF  xA6
050D4:  MOVWF  xA7
050D6:  MOVWF  xA8
050D8:  MOVWF  xA9
050DA:  CLRF   xAA
050DC:  MOVWF  xAB
050DE:  MOVWF  xAC
050E0:  MOVWF  xAD
050E2:  MOVWF  xAE
050E4:  MOVWF  xAF
050E6:  MOVWF  xB0
050E8:  CLRF   xB1
050EA:  CLRF   xB2
050EC:  CLRF   xB3
050EE:  MOVWF  xB4
050F0:  MOVWF  xB5
050F2:  MOVWF  xB6
050F4:  MOVWF  xB7
050F6:  MOVWF  xB8
050F8:  CLRF   xB9
050FA:  MOVWF  xBA
050FC:  MOVWF  xBB
050FE:  MOVWF  xBC
05100:  MOVWF  xBD
05102:  MOVWF  xBE
05104:  CLRF   xBF
05106:  CLRF   xC0
05108:  CLRF   xC1
0510A:  CLRF   xC2
0510C:  CLRF   xC3
0510E:  MOVWF  xC4
05110:  MOVWF  xC5
05112:  MOVWF  xC6
05114:  MOVWF  xC7
05116:  CLRF   xC8
05118:  MOVWF  xC9
0511A:  MOVWF  xCA
0511C:  MOVWF  xCB
0511E:  MOVWF  xCC
05120:  MOVWF  xCD
05122:  CLRF   xCE
05124:  CLRF   xCF
05126:  CLRF   xD0
05128:  CLRF   xD1
0512A:  CLRF   xD2
0512C:  MOVWF  xD3
0512E:  MOVWF  xD4
05130:  MOVWF  xD5
05132:  MOVWF  xD6
05134:  CLRF   xD7
05136:  MOVWF  xD8
05138:  MOVWF  xD9
0513A:  MOVWF  xDA
0513C:  MOVWF  xDB
0513E:  MOVWF  xDC
05140:  CLRF   xDD
05142:  CLRF   xDE
05144:  CLRF   xDF
05146:  CLRF   xE0
05148:  CLRF   xE1
0514A:  MOVWF  xE2
0514C:  MOVWF  xE3
0514E:  MOVWF  xE4
05150:  MOVWF  xE5
05152:  CLRF   xE6
05154:  CLRF   xE7
05156:  MOVWF  xE8
05158:  MOVWF  xE9
0515A:  MOVWF  xEA
0515C:  MOVWF  xEB
0515E:  MOVWF  xEC
05160:  CLRF   xED
05162:  CLRF   xEE
05164:  CLRF   xEF
05166:  MOVWF  xF0
05168:  MOVWF  xF1
0516A:  MOVWF  xF2
0516C:  MOVWF  xF3
0516E:  MOVWF  xF4
05170:  CLRF   xF5
05172:  CLRF   xF6
05174:  CLRF   xF7
05176:  MOVWF  xF8
05178:  MOVWF  xF9
0517A:  MOVWF  xFA
0517C:  MOVWF  xFB
0517E:  MOVWF  xFC
05180:  MOVWF  xFD
05182:  MOVWF  xFE
05184:  MOVWF  xFF
05186:  MOVLB  6
05188:  MOVWF  x00
0518A:  MOVWF  x01
0518C:  MOVWF  x02
0518E:  CLRF   x03
05190:  CLRF   x04
05192:  CLRF   x05
05194:  CLRF   x06
05196:  CLRF   x07
05198:  MOVWF  x08
0519A:  MOVWF  x09
0519C:  MOVWF  x0A
0519E:  MOVWF  x0B
051A0:  MOVWF  x0C
051A2:  MOVWF  x0D
051A4:  MOVWF  x0E
051A6:  MOVWF  x0F
051A8:  MOVWF  x10
051AA:  CLRF   x11
051AC:  CLRF   x12
051AE:  CLRF   x13
051B0:  CLRF   x14
051B2:  MOVWF  x15
051B4:  MOVWF  x16
051B6:  MOVWF  x17
051B8:  MOVWF  x18
051BA:  MOVWF  x19
051BC:  MOVWF  x1A
051BE:  MOVWF  x1B
051C0:  MOVWF  x1C
051C2:  MOVWF  x1D
051C4:  MOVWF  x1E
051C6:  MOVWF  x1F
051C8:  MOVWF  x20
051CA:  CLRF   x21
051CC:  CLRF   x22
051CE:  CLRF   x23
051D0:  MOVWF  x24
051D2:  MOVWF  x25
051D4:  MOVWF  x26
051D6:  MOVWF  x27
051D8:  MOVWF  x28
051DA:  CLRF   x29
051DC:  CLRF   x2A
051DE:  CLRF   x2B
051E0:  MOVWF  x2C
051E2:  MOVWF  x2D
051E4:  MOVWF  x2E
051E6:  MOVWF  x2F
051E8:  MOVWF  x30
051EA:  CLRF   x31
051EC:  MOVWF  x32
051EE:  MOVWF  x33
051F0:  MOVWF  x34
051F2:  MOVWF  x35
051F4:  MOVWF  x36
051F6:  CLRF   x37
051F8:  CLRF   x38
051FA:  CLRF   x39
051FC:  CLRF   x3A
051FE:  CLRF   x3B
05200:  MOVWF  x3C
05202:  MOVWF  x3D
05204:  MOVWF  x3E
05206:  MOVWF  x3F
05208:  MOVWF  x40
0520A:  MOVWF  x41
0520C:  MOVWF  x42
0520E:  MOVWF  x43
05210:  MOVWF  x44
05212:  CLRF   x45
05214:  CLRF   x46
05216:  CLRF   x47
05218:  CLRF   x48
0521A:  CLRF   x49
0521C:  CLRF   x4A
0521E:  CLRF   x4B
05220:  MOVWF  x4C
05222:  MOVWF  x4D
05224:  MOVWF  x4E
05226:  MOVWF  x4F
05228:  MOVWF  x50
0522A:  MOVWF  x51
0522C:  MOVWF  x52
0522E:  MOVWF  x53
05230:  CLRF   x54
05232:  CLRF   x55
05234:  CLRF   x56
05236:  CLRF   x57
05238:  CLRF   x58
0523A:  CLRF   x59
0523C:  CLRF   x5A
0523E:  MOVWF  x5B
05240:  MOVWF  x5C
05242:  MOVWF  x5D
05244:  MOVWF  x5E
05246:  MOVWF  x5F
05248:  MOVWF  x60
0524A:  MOVWF  x61
0524C:  MOVWF  x62
0524E:  CLRF   x63
05250:  CLRF   x64
05252:  CLRF   x65
05254:  CLRF   x66
05256:  CLRF   x67
05258:  CLRF   x68
0525A:  CLRF   x69
0525C:  MOVWF  x6A
0525E:  MOVWF  x6B
05260:  MOVWF  x6C
05262:  MOVWF  x6D
05264:  MOVWF  x6E
05266:  MOVWF  x6F
05268:  MOVWF  x70
0526A:  MOVWF  x71
0526C:  CLRF   x72
0526E:  CLRF   x73
05270:  CLRF   x74
05272:  CLRF   x75
05274:  CLRF   x76
05276:  CLRF   x77
05278:  CLRF   x78
0527A:  MOVWF  x79
0527C:  MOVWF  x7A
0527E:  MOVWF  x7B
05280:  MOVWF  x7C
05282:  MOVWF  x7D
05284:  MOVWF  x7E
05286:  MOVWF  x7F
05288:  MOVWF  x80
0528A:  MOVWF  x81
0528C:  CLRF   x82
0528E:  CLRF   x83
05290:  CLRF   x84
05292:  CLRF   x85
05294:  CLRF   x86
05296:  MOVWF  x87
05298:  MOVWF  x88
0529A:  MOVWF  x89
0529C:  MOVWF  x8A
0529E:  MOVWF  x8B
052A0:  MOVWF  x8C
052A2:  MOVWF  x8D
052A4:  MOVWF  x8E
052A6:  MOVWF  x8F
052A8:  MOVWF  x90
052AA:  MOVWF  x91
052AC:  CLRF   x92
052AE:  CLRF   x93
052B0:  CLRF   x94
052B2:  CLRF   x95
052B4:  MOVWF  x96
052B6:  MOVWF  x97
052B8:  MOVWF  x98
052BA:  MOVWF  x99
052BC:  CLRF   x9A
052BE:  CLRF   x9B
052C0:  MOVWF  x9C
052C2:  MOVWF  x9D
052C4:  MOVWF  x9E
052C6:  MOVWF  x9F
052C8:  MOVWF  xA0
052CA:  MOVWF  xA1
052CC:  MOVWF  xA2
052CE:  MOVWF  xA3
052D0:  MOVWF  xA4
052D2:  MOVWF  xA5
052D4:  MOVWF  xA6
052D6:  MOVWF  xA7
052D8:  MOVWF  xA8
052DA:  CLRF   xA9
052DC:  CLRF   xAA
052DE:  CLRF   xAB
052E0:  MOVWF  xAC
052E2:  MOVWF  xAD
052E4:  MOVWF  xAE
052E6:  MOVWF  xAF
052E8:  MOVWF  xB0
052EA:  MOVWF  xB1
052EC:  MOVWF  xB2
052EE:  MOVWF  xB3
052F0:  MOVWF  xB4
052F2:  MOVWF  xB5
052F4:  MOVWF  xB6
052F6:  CLRF   xB7
052F8:  CLRF   xB8
052FA:  CLRF   xB9
052FC:  CLRF   xBA
052FE:  CLRF   xBB
05300:  MOVWF  xBC
05302:  MOVWF  xBD
05304:  MOVWF  xBE
05306:  MOVWF  xBF
05308:  MOVWF  xC0
0530A:  MOVWF  xC1
0530C:  MOVWF  xC2
0530E:  MOVWF  xC3
05310:  MOVWF  xC4
05312:  CLRF   xC5
05314:  CLRF   xC6
05316:  CLRF   xC7
05318:  CLRF   xC8
0531A:  CLRF   xC9
0531C:  CLRF   xCA
0531E:  CLRF   xCB
05320:  CLRF   xCC
05322:  MOVWF  xCD
05324:  MOVWF  xCE
05326:  MOVWF  xCF
05328:  MOVWF  xD0
0532A:  MOVWF  xD1
0532C:  CLRF   xD2
0532E:  CLRF   xD3
05330:  CLRF   xD4
05332:  CLRF   xD5
05334:  CLRF   xD6
....................     
....................     for(n=0; n<375; n++) //draw a block
05336:  MOVLB  5
05338:  CLRF   x5F
0533A:  CLRF   x5E
0533C:  MOVF   x5F,W
0533E:  SUBLW  01
05340:  BNC   53A4
05342:  BNZ   534A
05344:  MOVF   x5E,W
05346:  SUBLW  76
05348:  BNC   53A4
....................     {
....................        if(Eight[n] == 1)
0534A:  MOVLW  60
0534C:  ADDWF  x5E,W
0534E:  MOVWF  3FE9
05350:  MOVLW  05
05352:  ADDWFC x5F,W
05354:  MOVWF  3FEA
05356:  DECFSZ 3FEF,W
05358:  BRA    537C
....................        {
....................             Data_Out(0xFF);
0535A:  MOVLB  8
0535C:  SETF   x54
0535E:  MOVLB  0
05360:  CALL   0636
....................             Data_Out(0xFF);
05364:  MOVLB  8
05366:  SETF   x54
05368:  MOVLB  0
0536A:  CALL   0636
....................             Data_Out(0xFF);
0536E:  MOVLB  8
05370:  SETF   x54
05372:  MOVLB  0
05374:  CALL   0636
....................        } else
05378:  BRA    539A
0537A:  MOVLB  5
....................        {
....................             Data_Out(0x00);
0537C:  MOVLB  8
0537E:  CLRF   x54
05380:  MOVLB  0
05382:  CALL   0636
....................             Data_Out(0x00);
05386:  MOVLB  8
05388:  CLRF   x54
0538A:  MOVLB  0
0538C:  CALL   0636
....................             Data_Out(0x00);
05390:  MOVLB  8
05392:  CLRF   x54
05394:  MOVLB  0
05396:  CALL   0636
....................        }
0539A:  MOVLB  5
0539C:  INCF   x5E,F
0539E:  BTFSC  3FD8.2
053A0:  INCF   x5F,F
053A2:  BRA    533C
....................        
....................     } 
053A4:  MOVLB  0
053A6:  GOTO   57E8 (RETURN)
.................... }
.................... 
.................... 
.................... /**
....................     Draw a 9 digit
.................... **/
.................... void    Draw_Nine(void)
.................... {
....................     uint16_t    n;
....................     uint8_t Nine[375]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,
....................     1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,
....................     1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,
....................     1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,
....................     1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,
....................     1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,
....................     1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,
....................     1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
....................     0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,
....................     0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,
....................     0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
....................     0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
....................     1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,
....................     1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,
....................     0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
053AA:  MOVLB  5
053AC:  CLRF   x60
053AE:  CLRF   x61
053B0:  CLRF   x62
053B2:  CLRF   x63
053B4:  CLRF   x64
053B6:  CLRF   x65
053B8:  CLRF   x66
053BA:  CLRF   x67
053BC:  CLRF   x68
053BE:  CLRF   x69
053C0:  CLRF   x6A
053C2:  CLRF   x6B
053C4:  CLRF   x6C
053C6:  CLRF   x6D
053C8:  CLRF   x6E
053CA:  CLRF   x6F
053CC:  CLRF   x70
053CE:  CLRF   x71
053D0:  CLRF   x72
053D2:  MOVLW  01
053D4:  MOVWF  x73
053D6:  MOVWF  x74
053D8:  MOVWF  x75
053DA:  MOVWF  x76
053DC:  MOVWF  x77
053DE:  MOVWF  x78
053E0:  CLRF   x79
053E2:  CLRF   x7A
053E4:  CLRF   x7B
053E6:  CLRF   x7C
053E8:  CLRF   x7D
053EA:  CLRF   x7E
053EC:  CLRF   x7F
053EE:  MOVWF  x80
053F0:  MOVWF  x81
053F2:  MOVWF  x82
053F4:  MOVWF  x83
053F6:  MOVWF  x84
053F8:  MOVWF  x85
053FA:  MOVWF  x86
053FC:  MOVWF  x87
053FE:  MOVWF  x88
05400:  MOVWF  x89
05402:  CLRF   x8A
05404:  CLRF   x8B
05406:  CLRF   x8C
05408:  CLRF   x8D
0540A:  MOVWF  x8E
0540C:  MOVWF  x8F
0540E:  MOVWF  x90
05410:  MOVWF  x91
05412:  MOVWF  x92
05414:  MOVWF  x93
05416:  MOVWF  x94
05418:  MOVWF  x95
0541A:  MOVWF  x96
0541C:  MOVWF  x97
0541E:  MOVWF  x98
05420:  MOVWF  x99
05422:  CLRF   x9A
05424:  CLRF   x9B
05426:  CLRF   x9C
05428:  MOVWF  x9D
0542A:  MOVWF  x9E
0542C:  MOVWF  x9F
0542E:  MOVWF  xA0
05430:  MOVWF  xA1
05432:  CLRF   xA2
05434:  CLRF   xA3
05436:  CLRF   xA4
05438:  MOVWF  xA5
0543A:  MOVWF  xA6
0543C:  MOVWF  xA7
0543E:  MOVWF  xA8
05440:  MOVWF  xA9
05442:  CLRF   xAA
05444:  MOVWF  xAB
05446:  MOVWF  xAC
05448:  MOVWF  xAD
0544A:  MOVWF  xAE
0544C:  CLRF   xAF
0544E:  CLRF   xB0
05450:  CLRF   xB1
05452:  CLRF   xB2
05454:  CLRF   xB3
05456:  CLRF   xB4
05458:  MOVWF  xB5
0545A:  MOVWF  xB6
0545C:  MOVWF  xB7
0545E:  MOVWF  xB8
05460:  CLRF   xB9
05462:  MOVWF  xBA
05464:  MOVWF  xBB
05466:  MOVWF  xBC
05468:  MOVWF  xBD
0546A:  CLRF   xBE
0546C:  CLRF   xBF
0546E:  CLRF   xC0
05470:  CLRF   xC1
05472:  CLRF   xC2
05474:  CLRF   xC3
05476:  CLRF   xC4
05478:  MOVWF  xC5
0547A:  MOVWF  xC6
0547C:  MOVWF  xC7
0547E:  MOVWF  xC8
05480:  MOVWF  xC9
05482:  MOVWF  xCA
05484:  MOVWF  xCB
05486:  MOVWF  xCC
05488:  CLRF   xCD
0548A:  CLRF   xCE
0548C:  CLRF   xCF
0548E:  CLRF   xD0
05490:  CLRF   xD1
05492:  CLRF   xD2
05494:  CLRF   xD3
05496:  MOVWF  xD4
05498:  MOVWF  xD5
0549A:  MOVWF  xD6
0549C:  MOVWF  xD7
0549E:  MOVWF  xD8
054A0:  MOVWF  xD9
054A2:  MOVWF  xDA
054A4:  MOVWF  xDB
054A6:  CLRF   xDC
054A8:  CLRF   xDD
054AA:  CLRF   xDE
054AC:  CLRF   xDF
054AE:  CLRF   xE0
054B0:  CLRF   xE1
054B2:  CLRF   xE2
054B4:  MOVWF  xE3
054B6:  MOVWF  xE4
054B8:  MOVWF  xE5
054BA:  MOVWF  xE6
054BC:  MOVWF  xE7
054BE:  MOVWF  xE8
054C0:  MOVWF  xE9
054C2:  MOVWF  xEA
054C4:  CLRF   xEB
054C6:  CLRF   xEC
054C8:  CLRF   xED
054CA:  CLRF   xEE
054CC:  CLRF   xEF
054CE:  CLRF   xF0
054D0:  CLRF   xF1
054D2:  MOVWF  xF2
054D4:  MOVWF  xF3
054D6:  MOVWF  xF4
054D8:  MOVWF  xF5
054DA:  MOVWF  xF6
054DC:  MOVWF  xF7
054DE:  MOVWF  xF8
054E0:  MOVWF  xF9
054E2:  MOVWF  xFA
054E4:  CLRF   xFB
054E6:  CLRF   xFC
054E8:  CLRF   xFD
054EA:  CLRF   xFE
054EC:  CLRF   xFF
054EE:  MOVLB  6
054F0:  MOVWF  x00
054F2:  MOVWF  x01
054F4:  MOVWF  x02
054F6:  MOVWF  x03
054F8:  MOVWF  x04
054FA:  MOVWF  x05
054FC:  MOVWF  x06
054FE:  MOVWF  x07
05500:  MOVWF  x08
05502:  MOVWF  x09
05504:  MOVWF  x0A
05506:  CLRF   x0B
05508:  CLRF   x0C
0550A:  CLRF   x0D
0550C:  MOVWF  x0E
0550E:  MOVWF  x0F
05510:  MOVWF  x10
05512:  MOVWF  x11
05514:  MOVWF  x12
05516:  MOVWF  x13
05518:  CLRF   x14
0551A:  MOVWF  x15
0551C:  MOVWF  x16
0551E:  MOVWF  x17
05520:  MOVWF  x18
05522:  MOVWF  x19
05524:  MOVWF  x1A
05526:  MOVWF  x1B
05528:  MOVWF  x1C
0552A:  MOVWF  x1D
0552C:  MOVWF  x1E
0552E:  MOVWF  x1F
05530:  MOVWF  x20
05532:  MOVWF  x21
05534:  MOVWF  x22
05536:  CLRF   x23
05538:  CLRF   x24
0553A:  MOVWF  x25
0553C:  MOVWF  x26
0553E:  MOVWF  x27
05540:  MOVWF  x28
05542:  MOVWF  x29
05544:  MOVWF  x2A
05546:  MOVWF  x2B
05548:  MOVWF  x2C
0554A:  MOVWF  x2D
0554C:  MOVWF  x2E
0554E:  MOVWF  x2F
05550:  MOVWF  x30
05552:  MOVWF  x31
05554:  CLRF   x32
05556:  CLRF   x33
05558:  CLRF   x34
0555A:  MOVWF  x35
0555C:  MOVWF  x36
0555E:  MOVWF  x37
05560:  MOVWF  x38
05562:  MOVWF  x39
05564:  MOVWF  x3A
05566:  MOVWF  x3B
05568:  CLRF   x3C
0556A:  MOVWF  x3D
0556C:  MOVWF  x3E
0556E:  MOVWF  x3F
05570:  MOVWF  x40
05572:  CLRF   x41
05574:  CLRF   x42
05576:  CLRF   x43
05578:  CLRF   x44
0557A:  CLRF   x45
0557C:  CLRF   x46
0557E:  CLRF   x47
05580:  CLRF   x48
05582:  CLRF   x49
05584:  CLRF   x4A
05586:  CLRF   x4B
05588:  MOVWF  x4C
0558A:  MOVWF  x4D
0558C:  MOVWF  x4E
0558E:  MOVWF  x4F
05590:  CLRF   x50
05592:  CLRF   x51
05594:  CLRF   x52
05596:  CLRF   x53
05598:  CLRF   x54
0559A:  CLRF   x55
0559C:  CLRF   x56
0559E:  CLRF   x57
055A0:  CLRF   x58
055A2:  CLRF   x59
055A4:  CLRF   x5A
055A6:  MOVWF  x5B
055A8:  MOVWF  x5C
055AA:  MOVWF  x5D
055AC:  MOVWF  x5E
055AE:  MOVWF  x5F
055B0:  MOVWF  x60
055B2:  MOVWF  x61
055B4:  MOVWF  x62
055B6:  CLRF   x63
055B8:  CLRF   x64
055BA:  CLRF   x65
055BC:  CLRF   x66
055BE:  CLRF   x67
055C0:  CLRF   x68
055C2:  MOVWF  x69
055C4:  MOVWF  x6A
055C6:  MOVWF  x6B
055C8:  MOVWF  x6C
055CA:  MOVWF  x6D
055CC:  MOVWF  x6E
055CE:  MOVWF  x6F
055D0:  MOVWF  x70
055D2:  MOVWF  x71
055D4:  MOVWF  x72
055D6:  CLRF   x73
055D8:  CLRF   x74
055DA:  CLRF   x75
055DC:  CLRF   x76
055DE:  CLRF   x77
055E0:  MOVWF  x78
055E2:  MOVWF  x79
055E4:  MOVWF  x7A
055E6:  MOVWF  x7B
055E8:  CLRF   x7C
055EA:  CLRF   x7D
055EC:  MOVWF  x7E
055EE:  MOVWF  x7F
055F0:  MOVWF  x80
055F2:  MOVWF  x81
055F4:  MOVWF  x82
055F6:  CLRF   x83
055F8:  CLRF   x84
055FA:  MOVWF  x85
055FC:  MOVWF  x86
055FE:  MOVWF  x87
05600:  MOVWF  x88
05602:  MOVWF  x89
05604:  MOVWF  x8A
05606:  CLRF   x8B
05608:  CLRF   x8C
0560A:  MOVWF  x8D
0560C:  MOVWF  x8E
0560E:  MOVWF  x8F
05610:  MOVWF  x90
05612:  MOVWF  x91
05614:  MOVWF  x92
05616:  MOVWF  x93
05618:  MOVWF  x94
0561A:  MOVWF  x95
0561C:  MOVWF  x96
0561E:  MOVWF  x97
05620:  MOVWF  x98
05622:  CLRF   x99
05624:  CLRF   x9A
05626:  CLRF   x9B
05628:  CLRF   x9C
0562A:  MOVWF  x9D
0562C:  MOVWF  x9E
0562E:  MOVWF  x9F
05630:  MOVWF  xA0
05632:  MOVWF  xA1
05634:  MOVWF  xA2
05636:  MOVWF  xA3
05638:  MOVWF  xA4
0563A:  MOVWF  xA5
0563C:  MOVWF  xA6
0563E:  CLRF   xA7
05640:  CLRF   xA8
05642:  CLRF   xA9
05644:  CLRF   xAA
05646:  CLRF   xAB
05648:  CLRF   xAC
0564A:  MOVWF  xAD
0564C:  MOVWF  xAE
0564E:  MOVWF  xAF
05650:  MOVWF  xB0
05652:  MOVWF  xB1
05654:  MOVWF  xB2
05656:  MOVWF  xB3
05658:  MOVWF  xB4
0565A:  CLRF   xB5
0565C:  CLRF   xB6
0565E:  CLRF   xB7
05660:  CLRF   xB8
05662:  CLRF   xB9
05664:  CLRF   xBA
05666:  CLRF   xBB
05668:  CLRF   xBC
0566A:  CLRF   xBD
0566C:  MOVWF  xBE
0566E:  MOVWF  xBF
05670:  MOVWF  xC0
05672:  MOVWF  xC1
05674:  CLRF   xC2
05676:  CLRF   xC3
05678:  CLRF   xC4
0567A:  CLRF   xC5
0567C:  CLRF   xC6
0567E:  CLRF   xC7
05680:  CLRF   xC8
05682:  CLRF   xC9
05684:  CLRF   xCA
05686:  CLRF   xCB
05688:  CLRF   xCC
0568A:  CLRF   xCD
0568C:  CLRF   xCE
0568E:  CLRF   xCF
05690:  CLRF   xD0
05692:  CLRF   xD1
05694:  CLRF   xD2
05696:  CLRF   xD3
05698:  CLRF   xD4
0569A:  CLRF   xD5
0569C:  CLRF   xD6
....................     
....................     for(n=0; n<375; n++) //draw a block
0569E:  MOVLB  5
056A0:  CLRF   x5F
056A2:  CLRF   x5E
056A4:  MOVF   x5F,W
056A6:  SUBLW  01
056A8:  BNC   570C
056AA:  BNZ   56B2
056AC:  MOVF   x5E,W
056AE:  SUBLW  76
056B0:  BNC   570C
....................     {
....................        if(Nine[n] == 1)
056B2:  MOVLW  60
056B4:  ADDWF  x5E,W
056B6:  MOVWF  3FE9
056B8:  MOVLW  05
056BA:  ADDWFC x5F,W
056BC:  MOVWF  3FEA
056BE:  DECFSZ 3FEF,W
056C0:  BRA    56E4
....................        {
....................             Data_Out(0xFF);
056C2:  MOVLB  8
056C4:  SETF   x54
056C6:  MOVLB  0
056C8:  CALL   0636
....................             Data_Out(0xFF);
056CC:  MOVLB  8
056CE:  SETF   x54
056D0:  MOVLB  0
056D2:  CALL   0636
....................             Data_Out(0xFF);
056D6:  MOVLB  8
056D8:  SETF   x54
056DA:  MOVLB  0
056DC:  CALL   0636
....................        } else
056E0:  BRA    5702
056E2:  MOVLB  5
....................        {
....................             Data_Out(0x00);
056E4:  MOVLB  8
056E6:  CLRF   x54
056E8:  MOVLB  0
056EA:  CALL   0636
....................             Data_Out(0x00);
056EE:  MOVLB  8
056F0:  CLRF   x54
056F2:  MOVLB  0
056F4:  CALL   0636
....................             Data_Out(0x00);
056F8:  MOVLB  8
056FA:  CLRF   x54
056FC:  MOVLB  0
056FE:  CALL   0636
....................        }
05702:  MOVLB  5
05704:  INCF   x5E,F
05706:  BTFSC  3FD8.2
05708:  INCF   x5F,F
0570A:  BRA    56A4
....................        
....................     } 
0570C:  MOVLB  0
0570E:  GOTO   57EE (RETURN)
.................... }
.................... 
.................... 
.................... /**
....................     Draw BLE logo
.................... **/
.................... void    Draw_BLE(void)
.................... {
....................     uint16_t    n;
....................     uint8_t x,y;
....................    
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................     
....................     x=  X_CENTER -40;
*
0592E:  MOVLW  18
05930:  MOVLB  5
05932:  MOVWF  x58
....................     y = Y_CENTER + 80;
05934:  MOVLW  8C
05936:  MOVWF  x59
....................       
....................     Set_Column_Address(0,(x-14),0,(x+13)); //X coordinate
05938:  MOVLW  0E
0593A:  SUBWF  x58,W
0593C:  MOVLB  8
0593E:  MOVWF  x4E
05940:  MOVLW  0D
05942:  MOVLB  5
05944:  ADDWF  x58,W
05946:  MOVLB  8
05948:  MOVWF  x4F
0594A:  CLRF   x50
0594C:  MOVFF  84E,851
05950:  CLRF   x52
05952:  MOVWF  x53
05954:  MOVLB  0
05956:  CALL   0D50
....................     Set_Page_Address(0,(y-13),0,(y+13));    //y coordinate
0595A:  MOVLW  0D
0595C:  MOVLB  5
0595E:  SUBWF  x59,W
05960:  MOVLB  8
05962:  MOVWF  x4E
05964:  MOVLW  0D
05966:  MOVLB  5
05968:  ADDWF  x59,W
0596A:  MOVLB  8
0596C:  MOVWF  x4F
0596E:  CLRF   x50
05970:  MOVFF  84E,851
05974:  CLRF   x52
05976:  MOVWF  x53
05978:  MOVLB  0
0597A:  CALL   0D74
....................     Write_Memory_Start();
0597E:  CALL   0D98
....................     
....................     uint8_t BLE[756]= {
....................     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,2,2,2,2,2,1,2,2,2,2,2,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,0,0,0,0,0,0,
....................     0,0,0,0,0,0,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,0,0,0,0,0,
....................     0,0,0,0,0,2,2,2,2,2,2,2,2,2,1,2,1,1,2,2,2,2,2,2,0,0,0,0,   
....................     0,0,0,0,2,2,2,2,2,2,2,2,2,2,1,2,2,1,1,2,2,2,2,2,2,0,0,0,
....................     0,0,0,0,2,2,2,2,1,2,2,2,2,2,1,2,2,2,1,1,2,2,2,2,2,0,0,0,
....................     0,0,0,2,2,2,2,2,1,1,2,2,2,2,1,2,2,2,2,1,1,2,2,2,2,0,0,0,
....................     0,0,2,2,2,2,2,2,2,1,1,2,2,2,1,2,2,2,1,1,2,2,2,2,2,2,0,0,
....................     0,0,2,2,2,2,2,2,2,2,1,1,2,2,1,2,2,1,1,2,2,2,2,2,2,2,0,0,
....................     0,0,2,2,2,2,2,2,2,2,2,1,1,2,1,2,1,1,2,2,2,2,2,2,2,2,0,0,
....................     0,0,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,0,0,
....................     0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,0,0,
....................     0,0,2,2,2,2,2,2,2,2,2,2,1,1,1,2,1,1,2,2,2,2,2,2,2,2,0,0,
....................     0,0,2,2,2,2,2,2,2,2,2,1,1,2,1,2,2,1,1,2,2,2,2,2,2,2,0,0,
....................     0,0,2,2,2,2,2,2,2,2,1,1,2,2,1,2,2,2,1,1,2,2,2,2,2,2,0,0,
....................     0,0,0,2,2,2,2,2,2,1,1,2,2,2,1,2,2,2,2,1,1,2,2,2,2,0,0,0,
....................     0,0,0,2,2,2,2,2,1,1,2,2,2,2,1,2,2,2,1,1,2,2,2,2,2,0,0,0,
....................     0,0,0,0,2,2,2,2,1,2,2,2,2,2,1,2,2,1,1,2,2,2,2,2,0,0,0,0,
....................     0,0,0,0,2,2,2,2,2,2,2,2,2,2,1,2,1,1,2,2,2,2,2,2,0,0,0,0,
....................     0,0,0,0,0,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,0,0,0,0,0,0,
....................     0,0,0,0,0,0,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,2,2,2,2,2,2,2,1,2,2,2,2,2,2,0,0,0,0,0,0,0,   
....................     0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0};
05982:  MOVLB  5
05984:  CLRF   x5A
05986:  CLRF   x5B
05988:  CLRF   x5C
0598A:  CLRF   x5D
0598C:  CLRF   x5E
0598E:  CLRF   x5F
05990:  CLRF   x60
05992:  CLRF   x61
05994:  CLRF   x62
05996:  CLRF   x63
05998:  CLRF   x64
0599A:  CLRF   x65
0599C:  CLRF   x66
0599E:  CLRF   x67
059A0:  CLRF   x68
059A2:  CLRF   x69
059A4:  CLRF   x6A
059A6:  CLRF   x6B
059A8:  CLRF   x6C
059AA:  CLRF   x6D
059AC:  CLRF   x6E
059AE:  CLRF   x6F
059B0:  CLRF   x70
059B2:  CLRF   x71
059B4:  CLRF   x72
059B6:  CLRF   x73
059B8:  CLRF   x74
059BA:  CLRF   x75
059BC:  CLRF   x76
059BE:  CLRF   x77
059C0:  CLRF   x78
059C2:  CLRF   x79
059C4:  CLRF   x7A
059C6:  CLRF   x7B
059C8:  CLRF   x7C
059CA:  CLRF   x7D
059CC:  CLRF   x7E
059CE:  CLRF   x7F
059D0:  CLRF   x80
059D2:  MOVLW  02
059D4:  MOVWF  x81
059D6:  MOVWF  x82
059D8:  MOVWF  x83
059DA:  MOVWF  x84
059DC:  MOVWF  x85
059DE:  MOVWF  x86
059E0:  MOVWF  x87
059E2:  CLRF   x88
059E4:  CLRF   x89
059E6:  CLRF   x8A
059E8:  CLRF   x8B
059EA:  CLRF   x8C
059EC:  CLRF   x8D
059EE:  CLRF   x8E
059F0:  CLRF   x8F
059F2:  CLRF   x90
059F4:  CLRF   x91
059F6:  CLRF   x92
059F8:  CLRF   x93
059FA:  CLRF   x94
059FC:  CLRF   x95
059FE:  CLRF   x96
05A00:  CLRF   x97
05A02:  CLRF   x98
05A04:  CLRF   x99
05A06:  CLRF   x9A
05A08:  MOVWF  x9B
05A0A:  MOVWF  x9C
05A0C:  MOVWF  x9D
05A0E:  MOVWF  x9E
05A10:  MOVWF  x9F
05A12:  MOVLW  01
05A14:  MOVWF  xA0
05A16:  MOVLW  02
05A18:  MOVWF  xA1
05A1A:  MOVWF  xA2
05A1C:  MOVWF  xA3
05A1E:  MOVWF  xA4
05A20:  MOVWF  xA5
05A22:  CLRF   xA6
05A24:  CLRF   xA7
05A26:  CLRF   xA8
05A28:  CLRF   xA9
05A2A:  CLRF   xAA
05A2C:  CLRF   xAB
05A2E:  CLRF   xAC
05A30:  CLRF   xAD
05A32:  CLRF   xAE
05A34:  CLRF   xAF
05A36:  CLRF   xB0
05A38:  CLRF   xB1
05A3A:  CLRF   xB2
05A3C:  CLRF   xB3
05A3E:  CLRF   xB4
05A40:  MOVWF  xB5
05A42:  MOVWF  xB6
05A44:  MOVWF  xB7
05A46:  MOVWF  xB8
05A48:  MOVWF  xB9
05A4A:  MOVWF  xBA
05A4C:  MOVWF  xBB
05A4E:  MOVLW  01
05A50:  MOVWF  xBC
05A52:  MOVWF  xBD
05A54:  MOVLW  02
05A56:  MOVWF  xBE
05A58:  MOVWF  xBF
05A5A:  MOVWF  xC0
05A5C:  MOVWF  xC1
05A5E:  MOVWF  xC2
05A60:  MOVWF  xC3
05A62:  CLRF   xC4
05A64:  CLRF   xC5
05A66:  CLRF   xC6
05A68:  CLRF   xC7
05A6A:  CLRF   xC8
05A6C:  CLRF   xC9
05A6E:  CLRF   xCA
05A70:  CLRF   xCB
05A72:  CLRF   xCC
05A74:  CLRF   xCD
05A76:  CLRF   xCE
05A78:  CLRF   xCF
05A7A:  MOVWF  xD0
05A7C:  MOVWF  xD1
05A7E:  MOVWF  xD2
05A80:  MOVWF  xD3
05A82:  MOVWF  xD4
05A84:  MOVWF  xD5
05A86:  MOVWF  xD6
05A88:  MOVWF  xD7
05A8A:  MOVLW  01
05A8C:  MOVWF  xD8
05A8E:  MOVWF  xD9
05A90:  MOVWF  xDA
05A92:  MOVLW  02
05A94:  MOVWF  xDB
05A96:  MOVWF  xDC
05A98:  MOVWF  xDD
05A9A:  MOVWF  xDE
05A9C:  MOVWF  xDF
05A9E:  MOVWF  xE0
05AA0:  CLRF   xE1
05AA2:  CLRF   xE2
05AA4:  CLRF   xE3
05AA6:  CLRF   xE4
05AA8:  CLRF   xE5
05AAA:  CLRF   xE6
05AAC:  CLRF   xE7
05AAE:  CLRF   xE8
05AB0:  CLRF   xE9
05AB2:  CLRF   xEA
05AB4:  MOVWF  xEB
05AB6:  MOVWF  xEC
05AB8:  MOVWF  xED
05ABA:  MOVWF  xEE
05ABC:  MOVWF  xEF
05ABE:  MOVWF  xF0
05AC0:  MOVWF  xF1
05AC2:  MOVWF  xF2
05AC4:  MOVWF  xF3
05AC6:  MOVLW  01
05AC8:  MOVWF  xF4
05ACA:  MOVLW  02
05ACC:  MOVWF  xF5
05ACE:  MOVLW  01
05AD0:  MOVWF  xF6
05AD2:  MOVWF  xF7
05AD4:  MOVLW  02
05AD6:  MOVWF  xF8
05AD8:  MOVWF  xF9
05ADA:  MOVWF  xFA
05ADC:  MOVWF  xFB
05ADE:  MOVWF  xFC
05AE0:  MOVWF  xFD
05AE2:  CLRF   xFE
05AE4:  CLRF   xFF
05AE6:  MOVLB  6
05AE8:  CLRF   x00
05AEA:  CLRF   x01
05AEC:  CLRF   x02
05AEE:  CLRF   x03
05AF0:  CLRF   x04
05AF2:  CLRF   x05
05AF4:  MOVWF  x06
05AF6:  MOVWF  x07
05AF8:  MOVWF  x08
05AFA:  MOVWF  x09
05AFC:  MOVWF  x0A
05AFE:  MOVWF  x0B
05B00:  MOVWF  x0C
05B02:  MOVWF  x0D
05B04:  MOVWF  x0E
05B06:  MOVWF  x0F
05B08:  MOVLW  01
05B0A:  MOVWF  x10
05B0C:  MOVLW  02
05B0E:  MOVWF  x11
05B10:  MOVWF  x12
05B12:  MOVLW  01
05B14:  MOVWF  x13
05B16:  MOVWF  x14
05B18:  MOVLW  02
05B1A:  MOVWF  x15
05B1C:  MOVWF  x16
05B1E:  MOVWF  x17
05B20:  MOVWF  x18
05B22:  MOVWF  x19
05B24:  MOVWF  x1A
05B26:  CLRF   x1B
05B28:  CLRF   x1C
05B2A:  CLRF   x1D
05B2C:  CLRF   x1E
05B2E:  CLRF   x1F
05B30:  CLRF   x20
05B32:  CLRF   x21
05B34:  MOVWF  x22
05B36:  MOVWF  x23
05B38:  MOVWF  x24
05B3A:  MOVWF  x25
05B3C:  MOVLW  01
05B3E:  MOVWF  x26
05B40:  MOVLW  02
05B42:  MOVWF  x27
05B44:  MOVWF  x28
05B46:  MOVWF  x29
05B48:  MOVWF  x2A
05B4A:  MOVWF  x2B
05B4C:  MOVLW  01
05B4E:  MOVWF  x2C
05B50:  MOVLW  02
05B52:  MOVWF  x2D
05B54:  MOVWF  x2E
05B56:  MOVWF  x2F
05B58:  MOVLW  01
05B5A:  MOVWF  x30
05B5C:  MOVWF  x31
05B5E:  MOVLW  02
05B60:  MOVWF  x32
05B62:  MOVWF  x33
05B64:  MOVWF  x34
05B66:  MOVWF  x35
05B68:  MOVWF  x36
05B6A:  CLRF   x37
05B6C:  CLRF   x38
05B6E:  CLRF   x39
05B70:  CLRF   x3A
05B72:  CLRF   x3B
05B74:  CLRF   x3C
05B76:  MOVWF  x3D
05B78:  MOVWF  x3E
05B7A:  MOVWF  x3F
05B7C:  MOVWF  x40
05B7E:  MOVWF  x41
05B80:  MOVLW  01
05B82:  MOVWF  x42
05B84:  MOVWF  x43
05B86:  MOVLW  02
05B88:  MOVWF  x44
05B8A:  MOVWF  x45
05B8C:  MOVWF  x46
05B8E:  MOVWF  x47
05B90:  MOVLW  01
05B92:  MOVWF  x48
05B94:  MOVLW  02
05B96:  MOVWF  x49
05B98:  MOVWF  x4A
05B9A:  MOVWF  x4B
05B9C:  MOVWF  x4C
05B9E:  MOVLW  01
05BA0:  MOVWF  x4D
05BA2:  MOVWF  x4E
05BA4:  MOVLW  02
05BA6:  MOVWF  x4F
05BA8:  MOVWF  x50
05BAA:  MOVWF  x51
05BAC:  MOVWF  x52
05BAE:  CLRF   x53
05BB0:  CLRF   x54
05BB2:  CLRF   x55
05BB4:  CLRF   x56
05BB6:  CLRF   x57
05BB8:  MOVWF  x58
05BBA:  MOVWF  x59
05BBC:  MOVWF  x5A
05BBE:  MOVWF  x5B
05BC0:  MOVWF  x5C
05BC2:  MOVWF  x5D
05BC4:  MOVWF  x5E
05BC6:  MOVLW  01
05BC8:  MOVWF  x5F
05BCA:  MOVWF  x60
05BCC:  MOVLW  02
05BCE:  MOVWF  x61
05BD0:  MOVWF  x62
05BD2:  MOVWF  x63
05BD4:  MOVLW  01
05BD6:  MOVWF  x64
05BD8:  MOVLW  02
05BDA:  MOVWF  x65
05BDC:  MOVWF  x66
05BDE:  MOVWF  x67
05BE0:  MOVLW  01
05BE2:  MOVWF  x68
05BE4:  MOVWF  x69
05BE6:  MOVLW  02
05BE8:  MOVWF  x6A
05BEA:  MOVWF  x6B
05BEC:  MOVWF  x6C
05BEE:  MOVWF  x6D
05BF0:  MOVWF  x6E
05BF2:  MOVWF  x6F
05BF4:  CLRF   x70
05BF6:  CLRF   x71
05BF8:  CLRF   x72
05BFA:  CLRF   x73
05BFC:  MOVWF  x74
05BFE:  MOVWF  x75
05C00:  MOVWF  x76
05C02:  MOVWF  x77
05C04:  MOVWF  x78
05C06:  MOVWF  x79
05C08:  MOVWF  x7A
05C0A:  MOVWF  x7B
05C0C:  MOVLW  01
05C0E:  MOVWF  x7C
05C10:  MOVWF  x7D
05C12:  MOVLW  02
05C14:  MOVWF  x7E
05C16:  MOVWF  x7F
05C18:  MOVLW  01
05C1A:  MOVWF  x80
05C1C:  MOVLW  02
05C1E:  MOVWF  x81
05C20:  MOVWF  x82
05C22:  MOVLW  01
05C24:  MOVWF  x83
05C26:  MOVWF  x84
05C28:  MOVLW  02
05C2A:  MOVWF  x85
05C2C:  MOVWF  x86
05C2E:  MOVWF  x87
05C30:  MOVWF  x88
05C32:  MOVWF  x89
05C34:  MOVWF  x8A
05C36:  MOVWF  x8B
05C38:  CLRF   x8C
05C3A:  CLRF   x8D
05C3C:  CLRF   x8E
05C3E:  CLRF   x8F
05C40:  MOVWF  x90
05C42:  MOVWF  x91
05C44:  MOVWF  x92
05C46:  MOVWF  x93
05C48:  MOVWF  x94
05C4A:  MOVWF  x95
05C4C:  MOVWF  x96
05C4E:  MOVWF  x97
05C50:  MOVWF  x98
05C52:  MOVLW  01
05C54:  MOVWF  x99
05C56:  MOVWF  x9A
05C58:  MOVLW  02
05C5A:  MOVWF  x9B
05C5C:  MOVLW  01
05C5E:  MOVWF  x9C
05C60:  MOVLW  02
05C62:  MOVWF  x9D
05C64:  MOVLW  01
05C66:  MOVWF  x9E
05C68:  MOVWF  x9F
05C6A:  MOVLW  02
05C6C:  MOVWF  xA0
05C6E:  MOVWF  xA1
05C70:  MOVWF  xA2
05C72:  MOVWF  xA3
05C74:  MOVWF  xA4
05C76:  MOVWF  xA5
05C78:  MOVWF  xA6
05C7A:  MOVWF  xA7
05C7C:  CLRF   xA8
05C7E:  CLRF   xA9
05C80:  CLRF   xAA
05C82:  CLRF   xAB
05C84:  MOVWF  xAC
05C86:  MOVWF  xAD
05C88:  MOVWF  xAE
05C8A:  MOVWF  xAF
05C8C:  MOVWF  xB0
05C8E:  MOVWF  xB1
05C90:  MOVWF  xB2
05C92:  MOVWF  xB3
05C94:  MOVWF  xB4
05C96:  MOVWF  xB5
05C98:  MOVLW  01
05C9A:  MOVWF  xB6
05C9C:  MOVWF  xB7
05C9E:  MOVWF  xB8
05CA0:  MOVWF  xB9
05CA2:  MOVWF  xBA
05CA4:  MOVLW  02
05CA6:  MOVWF  xBB
05CA8:  MOVWF  xBC
05CAA:  MOVWF  xBD
05CAC:  MOVWF  xBE
05CAE:  MOVWF  xBF
05CB0:  MOVWF  xC0
05CB2:  MOVWF  xC1
05CB4:  MOVWF  xC2
05CB6:  MOVWF  xC3
05CB8:  CLRF   xC4
05CBA:  CLRF   xC5
05CBC:  CLRF   xC6
05CBE:  CLRF   xC7
05CC0:  MOVWF  xC8
05CC2:  MOVWF  xC9
05CC4:  MOVWF  xCA
05CC6:  MOVWF  xCB
05CC8:  MOVWF  xCC
05CCA:  MOVWF  xCD
05CCC:  MOVWF  xCE
05CCE:  MOVWF  xCF
05CD0:  MOVWF  xD0
05CD2:  MOVWF  xD1
05CD4:  MOVWF  xD2
05CD6:  MOVLW  01
05CD8:  MOVWF  xD3
05CDA:  MOVWF  xD4
05CDC:  MOVWF  xD5
05CDE:  MOVWF  xD6
05CE0:  MOVLW  02
05CE2:  MOVWF  xD7
05CE4:  MOVWF  xD8
05CE6:  MOVWF  xD9
05CE8:  MOVWF  xDA
05CEA:  MOVWF  xDB
05CEC:  MOVWF  xDC
05CEE:  MOVWF  xDD
05CF0:  MOVWF  xDE
05CF2:  MOVWF  xDF
05CF4:  CLRF   xE0
05CF6:  CLRF   xE1
05CF8:  CLRF   xE2
05CFA:  CLRF   xE3
05CFC:  MOVWF  xE4
05CFE:  MOVWF  xE5
05D00:  MOVWF  xE6
05D02:  MOVWF  xE7
05D04:  MOVWF  xE8
05D06:  MOVWF  xE9
05D08:  MOVWF  xEA
05D0A:  MOVWF  xEB
05D0C:  MOVWF  xEC
05D0E:  MOVWF  xED
05D10:  MOVLW  01
05D12:  MOVWF  xEE
05D14:  MOVWF  xEF
05D16:  MOVWF  xF0
05D18:  MOVLW  02
05D1A:  MOVWF  xF1
05D1C:  MOVLW  01
05D1E:  MOVWF  xF2
05D20:  MOVWF  xF3
05D22:  MOVLW  02
05D24:  MOVWF  xF4
05D26:  MOVWF  xF5
05D28:  MOVWF  xF6
05D2A:  MOVWF  xF7
05D2C:  MOVWF  xF8
05D2E:  MOVWF  xF9
05D30:  MOVWF  xFA
05D32:  MOVWF  xFB
05D34:  CLRF   xFC
05D36:  CLRF   xFD
05D38:  CLRF   xFE
05D3A:  CLRF   xFF
05D3C:  MOVLB  7
05D3E:  MOVWF  x00
05D40:  MOVWF  x01
05D42:  MOVWF  x02
05D44:  MOVWF  x03
05D46:  MOVWF  x04
05D48:  MOVWF  x05
05D4A:  MOVWF  x06
05D4C:  MOVWF  x07
05D4E:  MOVWF  x08
05D50:  MOVLW  01
05D52:  MOVWF  x09
05D54:  MOVWF  x0A
05D56:  MOVLW  02
05D58:  MOVWF  x0B
05D5A:  MOVLW  01
05D5C:  MOVWF  x0C
05D5E:  MOVLW  02
05D60:  MOVWF  x0D
05D62:  MOVWF  x0E
05D64:  MOVLW  01
05D66:  MOVWF  x0F
05D68:  MOVWF  x10
05D6A:  MOVLW  02
05D6C:  MOVWF  x11
05D6E:  MOVWF  x12
05D70:  MOVWF  x13
05D72:  MOVWF  x14
05D74:  MOVWF  x15
05D76:  MOVWF  x16
05D78:  MOVWF  x17
05D7A:  CLRF   x18
05D7C:  CLRF   x19
05D7E:  CLRF   x1A
05D80:  CLRF   x1B
05D82:  MOVWF  x1C
05D84:  MOVWF  x1D
05D86:  MOVWF  x1E
05D88:  MOVWF  x1F
05D8A:  MOVWF  x20
05D8C:  MOVWF  x21
05D8E:  MOVWF  x22
05D90:  MOVWF  x23
05D92:  MOVLW  01
05D94:  MOVWF  x24
05D96:  MOVWF  x25
05D98:  MOVLW  02
05D9A:  MOVWF  x26
05D9C:  MOVWF  x27
05D9E:  MOVLW  01
05DA0:  MOVWF  x28
05DA2:  MOVLW  02
05DA4:  MOVWF  x29
05DA6:  MOVWF  x2A
05DA8:  MOVWF  x2B
05DAA:  MOVLW  01
05DAC:  MOVWF  x2C
05DAE:  MOVWF  x2D
05DB0:  MOVLW  02
05DB2:  MOVWF  x2E
05DB4:  MOVWF  x2F
05DB6:  MOVWF  x30
05DB8:  MOVWF  x31
05DBA:  MOVWF  x32
05DBC:  MOVWF  x33
05DBE:  CLRF   x34
05DC0:  CLRF   x35
05DC2:  CLRF   x36
05DC4:  CLRF   x37
05DC6:  CLRF   x38
05DC8:  MOVWF  x39
05DCA:  MOVWF  x3A
05DCC:  MOVWF  x3B
05DCE:  MOVWF  x3C
05DD0:  MOVWF  x3D
05DD2:  MOVWF  x3E
05DD4:  MOVLW  01
05DD6:  MOVWF  x3F
05DD8:  MOVWF  x40
05DDA:  MOVLW  02
05DDC:  MOVWF  x41
05DDE:  MOVWF  x42
05DE0:  MOVWF  x43
05DE2:  MOVLW  01
05DE4:  MOVWF  x44
05DE6:  MOVLW  02
05DE8:  MOVWF  x45
05DEA:  MOVWF  x46
05DEC:  MOVWF  x47
05DEE:  MOVWF  x48
05DF0:  MOVLW  01
05DF2:  MOVWF  x49
05DF4:  MOVWF  x4A
05DF6:  MOVLW  02
05DF8:  MOVWF  x4B
05DFA:  MOVWF  x4C
05DFC:  MOVWF  x4D
05DFE:  MOVWF  x4E
05E00:  CLRF   x4F
05E02:  CLRF   x50
05E04:  CLRF   x51
05E06:  CLRF   x52
05E08:  CLRF   x53
05E0A:  CLRF   x54
05E0C:  MOVWF  x55
05E0E:  MOVWF  x56
05E10:  MOVWF  x57
05E12:  MOVWF  x58
05E14:  MOVWF  x59
05E16:  MOVLW  01
05E18:  MOVWF  x5A
05E1A:  MOVWF  x5B
05E1C:  MOVLW  02
05E1E:  MOVWF  x5C
05E20:  MOVWF  x5D
05E22:  MOVWF  x5E
05E24:  MOVWF  x5F
05E26:  MOVLW  01
05E28:  MOVWF  x60
05E2A:  MOVLW  02
05E2C:  MOVWF  x61
05E2E:  MOVWF  x62
05E30:  MOVWF  x63
05E32:  MOVLW  01
05E34:  MOVWF  x64
05E36:  MOVWF  x65
05E38:  MOVLW  02
05E3A:  MOVWF  x66
05E3C:  MOVWF  x67
05E3E:  MOVWF  x68
05E40:  MOVWF  x69
05E42:  MOVWF  x6A
05E44:  CLRF   x6B
05E46:  CLRF   x6C
05E48:  CLRF   x6D
05E4A:  CLRF   x6E
05E4C:  CLRF   x6F
05E4E:  CLRF   x70
05E50:  CLRF   x71
05E52:  MOVWF  x72
05E54:  MOVWF  x73
05E56:  MOVWF  x74
05E58:  MOVWF  x75
05E5A:  MOVLW  01
05E5C:  MOVWF  x76
05E5E:  MOVLW  02
05E60:  MOVWF  x77
05E62:  MOVWF  x78
05E64:  MOVWF  x79
05E66:  MOVWF  x7A
05E68:  MOVWF  x7B
05E6A:  MOVLW  01
05E6C:  MOVWF  x7C
05E6E:  MOVLW  02
05E70:  MOVWF  x7D
05E72:  MOVWF  x7E
05E74:  MOVLW  01
05E76:  MOVWF  x7F
05E78:  MOVWF  x80
05E7A:  MOVLW  02
05E7C:  MOVWF  x81
05E7E:  MOVWF  x82
05E80:  MOVWF  x83
05E82:  MOVWF  x84
05E84:  MOVWF  x85
05E86:  CLRF   x86
05E88:  CLRF   x87
05E8A:  CLRF   x88
05E8C:  CLRF   x89
05E8E:  CLRF   x8A
05E90:  CLRF   x8B
05E92:  CLRF   x8C
05E94:  CLRF   x8D
05E96:  MOVWF  x8E
05E98:  MOVWF  x8F
05E9A:  MOVWF  x90
05E9C:  MOVWF  x91
05E9E:  MOVWF  x92
05EA0:  MOVWF  x93
05EA2:  MOVWF  x94
05EA4:  MOVWF  x95
05EA6:  MOVWF  x96
05EA8:  MOVWF  x97
05EAA:  MOVLW  01
05EAC:  MOVWF  x98
05EAE:  MOVLW  02
05EB0:  MOVWF  x99
05EB2:  MOVLW  01
05EB4:  MOVWF  x9A
05EB6:  MOVWF  x9B
05EB8:  MOVLW  02
05EBA:  MOVWF  x9C
05EBC:  MOVWF  x9D
05EBE:  MOVWF  x9E
05EC0:  MOVWF  x9F
05EC2:  MOVWF  xA0
05EC4:  MOVWF  xA1
05EC6:  CLRF   xA2
05EC8:  CLRF   xA3
05ECA:  CLRF   xA4
05ECC:  CLRF   xA5
05ECE:  CLRF   xA6
05ED0:  CLRF   xA7
05ED2:  CLRF   xA8
05ED4:  CLRF   xA9
05ED6:  CLRF   xAA
05ED8:  MOVWF  xAB
05EDA:  MOVWF  xAC
05EDC:  MOVWF  xAD
05EDE:  MOVWF  xAE
05EE0:  MOVWF  xAF
05EE2:  MOVWF  xB0
05EE4:  MOVWF  xB1
05EE6:  MOVWF  xB2
05EE8:  MOVWF  xB3
05EEA:  MOVLW  01
05EEC:  MOVWF  xB4
05EEE:  MOVWF  xB5
05EF0:  MOVWF  xB6
05EF2:  MOVLW  02
05EF4:  MOVWF  xB7
05EF6:  MOVWF  xB8
05EF8:  MOVWF  xB9
05EFA:  MOVWF  xBA
05EFC:  MOVWF  xBB
05EFE:  CLRF   xBC
05F00:  CLRF   xBD
05F02:  CLRF   xBE
05F04:  CLRF   xBF
05F06:  CLRF   xC0
05F08:  CLRF   xC1
05F0A:  CLRF   xC2
05F0C:  CLRF   xC3
05F0E:  CLRF   xC4
05F10:  CLRF   xC5
05F12:  CLRF   xC6
05F14:  CLRF   xC7
05F16:  MOVWF  xC8
05F18:  MOVWF  xC9
05F1A:  MOVWF  xCA
05F1C:  MOVWF  xCB
05F1E:  MOVWF  xCC
05F20:  MOVWF  xCD
05F22:  MOVWF  xCE
05F24:  MOVWF  xCF
05F26:  MOVLW  01
05F28:  MOVWF  xD0
05F2A:  MOVWF  xD1
05F2C:  MOVLW  02
05F2E:  MOVWF  xD2
05F30:  MOVWF  xD3
05F32:  MOVWF  xD4
05F34:  MOVWF  xD5
05F36:  MOVWF  xD6
05F38:  MOVWF  xD7
05F3A:  CLRF   xD8
05F3C:  CLRF   xD9
05F3E:  CLRF   xDA
05F40:  CLRF   xDB
05F42:  CLRF   xDC
05F44:  CLRF   xDD
05F46:  CLRF   xDE
05F48:  CLRF   xDF
05F4A:  CLRF   xE0
05F4C:  CLRF   xE1
05F4E:  CLRF   xE2
05F50:  CLRF   xE3
05F52:  CLRF   xE4
05F54:  MOVWF  xE5
05F56:  MOVWF  xE6
05F58:  MOVWF  xE7
05F5A:  MOVWF  xE8
05F5C:  MOVWF  xE9
05F5E:  MOVWF  xEA
05F60:  MOVWF  xEB
05F62:  MOVLW  01
05F64:  MOVWF  xEC
05F66:  MOVLW  02
05F68:  MOVWF  xED
05F6A:  MOVWF  xEE
05F6C:  MOVWF  xEF
05F6E:  MOVWF  xF0
05F70:  MOVWF  xF1
05F72:  MOVWF  xF2
05F74:  CLRF   xF3
05F76:  CLRF   xF4
05F78:  CLRF   xF5
05F7A:  CLRF   xF6
05F7C:  CLRF   xF7
05F7E:  CLRF   xF8
05F80:  CLRF   xF9
05F82:  CLRF   xFA
05F84:  CLRF   xFB
05F86:  CLRF   xFC
05F88:  CLRF   xFD
05F8A:  CLRF   xFE
05F8C:  CLRF   xFF
05F8E:  MOVLB  8
05F90:  CLRF   x00
05F92:  CLRF   x01
05F94:  CLRF   x02
05F96:  MOVWF  x03
05F98:  MOVWF  x04
05F9A:  MOVWF  x05
05F9C:  MOVWF  x06
05F9E:  MOVWF  x07
05FA0:  MOVWF  x08
05FA2:  MOVWF  x09
05FA4:  MOVWF  x0A
05FA6:  MOVWF  x0B
05FA8:  MOVWF  x0C
05FAA:  MOVWF  x0D
05FAC:  CLRF   x0E
05FAE:  CLRF   x0F
05FB0:  CLRF   x10
05FB2:  CLRF   x11
05FB4:  CLRF   x12
05FB6:  CLRF   x13
05FB8:  CLRF   x14
05FBA:  CLRF   x15
05FBC:  CLRF   x16
05FBE:  CLRF   x17
05FC0:  CLRF   x18
05FC2:  CLRF   x19
05FC4:  CLRF   x1A
05FC6:  CLRF   x1B
05FC8:  CLRF   x1C
05FCA:  CLRF   x1D
05FCC:  CLRF   x1E
05FCE:  CLRF   x1F
05FD0:  CLRF   x20
05FD2:  MOVWF  x21
05FD4:  MOVWF  x22
05FD6:  MOVWF  x23
05FD8:  MOVWF  x24
05FDA:  MOVWF  x25
05FDC:  MOVWF  x26
05FDE:  CLRF   x27
05FE0:  CLRF   x28
05FE2:  CLRF   x29
05FE4:  CLRF   x2A
05FE6:  CLRF   x2B
05FE8:  CLRF   x2C
05FEA:  CLRF   x2D
05FEC:  CLRF   x2E
05FEE:  CLRF   x2F
05FF0:  CLRF   x30
05FF2:  CLRF   x31
05FF4:  CLRF   x32
05FF6:  CLRF   x33
05FF8:  CLRF   x34
05FFA:  CLRF   x35
05FFC:  CLRF   x36
05FFE:  CLRF   x37
06000:  CLRF   x38
06002:  CLRF   x39
06004:  CLRF   x3A
06006:  CLRF   x3B
06008:  CLRF   x3C
0600A:  CLRF   x3D
0600C:  CLRF   x3E
0600E:  CLRF   x3F
06010:  CLRF   x40
06012:  CLRF   x41
06014:  CLRF   x42
06016:  CLRF   x43
06018:  CLRF   x44
0601A:  CLRF   x45
0601C:  CLRF   x46
0601E:  CLRF   x47
06020:  CLRF   x48
06022:  CLRF   x49
06024:  CLRF   x4A
06026:  CLRF   x4B
06028:  CLRF   x4C
0602A:  CLRF   x4D
....................      
....................     for(n=0; n<=756; n++) //draw a block 28 across by 27 down
0602C:  MOVLB  5
0602E:  CLRF   x57
06030:  CLRF   x56
06032:  MOVF   x57,W
06034:  SUBLW  02
06036:  BNC   6100
06038:  BNZ   6040
0603A:  MOVF   x56,W
0603C:  SUBLW  F4
0603E:  BNC   6100
....................     {
....................         if(!g_BLE_Logo)  //turn BLE logo off  
06040:  MOVF   x10,F
06042:  BNZ   6066
....................         {
....................             Data_Out(0x00);
06044:  MOVLB  8
06046:  CLRF   x54
06048:  MOVLB  0
0604A:  CALL   0636
....................             Data_Out(0x00);
0604E:  MOVLB  8
06050:  CLRF   x54
06052:  MOVLB  0
06054:  CALL   0636
....................             Data_Out(0x00);
06058:  MOVLB  8
0605A:  CLRF   x54
0605C:  MOVLB  0
0605E:  CALL   0636
....................         }  
06062:  BRA    60F6
06064:  MOVLB  5
....................         else    //turn BLE logo on
....................         {
....................            if(BLE[n] == 1)  //white
06066:  MOVLW  5A
06068:  ADDWF  x56,W
0606A:  MOVWF  3FE9
0606C:  MOVLW  05
0606E:  ADDWFC x57,W
06070:  MOVWF  3FEA
06072:  DECFSZ 3FEF,W
06074:  BRA    6096
....................            {
....................                 Data_Out(0xFF);
06076:  MOVLB  8
06078:  SETF   x54
0607A:  MOVLB  0
0607C:  CALL   0636
....................                 Data_Out(0xFF);
06080:  MOVLB  8
06082:  SETF   x54
06084:  MOVLB  0
06086:  CALL   0636
....................                 Data_Out(0xFF);
0608A:  MOVLB  8
0608C:  SETF   x54
0608E:  MOVLB  0
06090:  CALL   0636
06094:  MOVLB  5
....................            } 
....................            
....................            if(BLE[n] == 0)  //black
06096:  MOVLW  5A
06098:  ADDWF  x56,W
0609A:  MOVWF  3FE9
0609C:  MOVLW  05
0609E:  ADDWFC x57,W
060A0:  MOVWF  3FEA
060A2:  MOVF   3FEF,F
060A4:  BNZ   60C6
....................            {
....................                 Data_Out(0x00);
060A6:  MOVLB  8
060A8:  CLRF   x54
060AA:  MOVLB  0
060AC:  CALL   0636
....................                 Data_Out(0x00);
060B0:  MOVLB  8
060B2:  CLRF   x54
060B4:  MOVLB  0
060B6:  CALL   0636
....................                 Data_Out(0x00);
060BA:  MOVLB  8
060BC:  CLRF   x54
060BE:  MOVLB  0
060C0:  CALL   0636
060C4:  MOVLB  5
....................            }
....................      
....................            if(BLE[n] == 2)  //blue
060C6:  MOVLW  5A
060C8:  ADDWF  x56,W
060CA:  MOVWF  3FE9
060CC:  MOVLW  05
060CE:  ADDWFC x57,W
060D0:  MOVWF  3FEA
060D2:  MOVF   3FEF,W
060D4:  SUBLW  02
060D6:  BNZ   60F8
....................            {
....................                 Data_Out(0x00);
060D8:  MOVLB  8
060DA:  CLRF   x54
060DC:  MOVLB  0
060DE:  CALL   0636
....................                 Data_Out(0x00);
060E2:  MOVLB  8
060E4:  CLRF   x54
060E6:  MOVLB  0
060E8:  CALL   0636
....................                 Data_Out(0xFF);
060EC:  MOVLB  8
060EE:  SETF   x54
060F0:  MOVLB  0
060F2:  CALL   0636
060F6:  MOVLB  5
....................            }
....................    
....................        } 
060F8:  INCF   x56,F
060FA:  BTFSC  3FD8.2
060FC:  INCF   x57,F
060FE:  BRA    6032
....................     }
06100:  MOVLB  0
06102:  GOTO   611C (RETURN)
....................    // fprintf(DEBUG,"\n\r %u, %u", g_BLE_Logo, g_Paired);
.................... }
.................... 
.................... 
.................... /**
....................     Draw Battery_Full,
.................... 
.................... **/
.................... void    Draw_Full_Battery(uint8_t Batt_Id)
.................... {
....................     uint16_t    n;
....................     uint8_t x,y;
....................    
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................       
....................     if(Batt_ID == HEAD)
*
018DC:  MOVLB  5
018DE:  MOVF   x56,F
018E0:  BNZ   18EC
....................     {   y = Y_CENTER +30;
018E2:  MOVLW  5A
018E4:  MOVWF  x5A
....................         x=  X_CENTER;
018E6:  MOVLW  40
018E8:  MOVWF  x59
....................     }  
018EA:  BRA    18F4
....................     else    //for the handset
....................      {
....................         y = Y_CENTER + 80;
018EC:  MOVLW  8C
018EE:  MOVWF  x5A
....................         x=  X_CENTER ;
018F0:  MOVLW  40
018F2:  MOVWF  x59
....................      }       
....................       
....................     Set_Column_Address(0,(x-14),0,(x+14)); //X coordinate
018F4:  MOVLW  0E
018F6:  SUBWF  x59,W
018F8:  MOVLB  6
018FA:  MOVWF  x9A
018FC:  MOVLW  0E
018FE:  MOVLB  5
01900:  ADDWF  x59,W
01902:  MOVLB  6
01904:  MOVWF  x9B
01906:  MOVLB  8
01908:  CLRF   x50
0190A:  MOVFF  69A,851
0190E:  CLRF   x52
01910:  MOVWF  x53
01912:  MOVLB  0
01914:  CALL   0D50
....................     Set_Page_Address(0,(y-5),0,(y+5));    //y coordinate
01918:  MOVLW  05
0191A:  MOVLB  5
0191C:  SUBWF  x5A,W
0191E:  MOVLB  6
01920:  MOVWF  x9A
01922:  MOVLW  05
01924:  MOVLB  5
01926:  ADDWF  x5A,W
01928:  MOVLB  6
0192A:  MOVWF  x9B
0192C:  MOVLB  8
0192E:  CLRF   x50
01930:  MOVFF  69A,851
01934:  CLRF   x52
01936:  MOVWF  x53
01938:  MOVLB  0
0193A:  CALL   0D74
....................     Write_Memory_Start();
0193E:  CALL   0D98
....................     
....................     uint8_t Full_Batt[319]= {
....................     
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1, 
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0};
01942:  MOVLW  01
01944:  MOVLB  5
01946:  MOVWF  x5B
01948:  MOVWF  x5C
0194A:  MOVWF  x5D
0194C:  MOVWF  x5E
0194E:  MOVWF  x5F
01950:  MOVWF  x60
01952:  MOVWF  x61
01954:  MOVWF  x62
01956:  MOVWF  x63
01958:  MOVWF  x64
0195A:  MOVWF  x65
0195C:  MOVWF  x66
0195E:  MOVWF  x67
01960:  MOVWF  x68
01962:  MOVWF  x69
01964:  MOVWF  x6A
01966:  MOVWF  x6B
01968:  MOVWF  x6C
0196A:  MOVWF  x6D
0196C:  MOVWF  x6E
0196E:  MOVWF  x6F
01970:  MOVWF  x70
01972:  MOVWF  x71
01974:  MOVWF  x72
01976:  MOVWF  x73
01978:  MOVWF  x74
0197A:  MOVWF  x75
0197C:  CLRF   x76
0197E:  CLRF   x77
01980:  MOVWF  x78
01982:  MOVLW  03
01984:  MOVWF  x79
01986:  MOVWF  x7A
01988:  MOVWF  x7B
0198A:  MOVWF  x7C
0198C:  MOVWF  x7D
0198E:  MOVWF  x7E
01990:  MOVWF  x7F
01992:  MOVWF  x80
01994:  MOVWF  x81
01996:  MOVWF  x82
01998:  MOVWF  x83
0199A:  MOVWF  x84
0199C:  MOVWF  x85
0199E:  MOVWF  x86
019A0:  MOVWF  x87
019A2:  MOVWF  x88
019A4:  MOVWF  x89
019A6:  MOVWF  x8A
019A8:  MOVWF  x8B
019AA:  MOVWF  x8C
019AC:  MOVWF  x8D
019AE:  MOVWF  x8E
019B0:  MOVWF  x8F
019B2:  MOVWF  x90
019B4:  MOVWF  x91
019B6:  MOVLW  01
019B8:  MOVWF  x92
019BA:  CLRF   x93
019BC:  CLRF   x94
019BE:  MOVWF  x95
019C0:  MOVLW  03
019C2:  MOVWF  x96
019C4:  MOVWF  x97
019C6:  MOVWF  x98
019C8:  MOVWF  x99
019CA:  MOVWF  x9A
019CC:  MOVWF  x9B
019CE:  MOVWF  x9C
019D0:  MOVWF  x9D
019D2:  MOVWF  x9E
019D4:  MOVWF  x9F
019D6:  MOVWF  xA0
019D8:  MOVWF  xA1
019DA:  MOVWF  xA2
019DC:  MOVWF  xA3
019DE:  MOVWF  xA4
019E0:  MOVWF  xA5
019E2:  MOVWF  xA6
019E4:  MOVWF  xA7
019E6:  MOVWF  xA8
019E8:  MOVWF  xA9
019EA:  MOVWF  xAA
019EC:  MOVWF  xAB
019EE:  MOVWF  xAC
019F0:  MOVWF  xAD
019F2:  MOVWF  xAE
019F4:  MOVLW  01
019F6:  MOVWF  xAF
019F8:  CLRF   xB0
019FA:  CLRF   xB1
019FC:  MOVWF  xB2
019FE:  MOVLW  03
01A00:  MOVWF  xB3
01A02:  MOVWF  xB4
01A04:  MOVWF  xB5
01A06:  MOVWF  xB6
01A08:  MOVWF  xB7
01A0A:  MOVWF  xB8
01A0C:  MOVWF  xB9
01A0E:  MOVWF  xBA
01A10:  MOVWF  xBB
01A12:  MOVWF  xBC
01A14:  MOVWF  xBD
01A16:  MOVWF  xBE
01A18:  MOVWF  xBF
01A1A:  MOVWF  xC0
01A1C:  MOVWF  xC1
01A1E:  MOVWF  xC2
01A20:  MOVWF  xC3
01A22:  MOVWF  xC4
01A24:  MOVWF  xC5
01A26:  MOVWF  xC6
01A28:  MOVWF  xC7
01A2A:  MOVWF  xC8
01A2C:  MOVWF  xC9
01A2E:  MOVWF  xCA
01A30:  MOVWF  xCB
01A32:  MOVLW  01
01A34:  MOVWF  xCC
01A36:  MOVWF  xCD
01A38:  MOVWF  xCE
01A3A:  MOVWF  xCF
01A3C:  MOVLW  03
01A3E:  MOVWF  xD0
01A40:  MOVWF  xD1
01A42:  MOVWF  xD2
01A44:  MOVWF  xD3
01A46:  MOVWF  xD4
01A48:  MOVWF  xD5
01A4A:  MOVWF  xD6
01A4C:  MOVWF  xD7
01A4E:  MOVWF  xD8
01A50:  MOVWF  xD9
01A52:  MOVWF  xDA
01A54:  MOVWF  xDB
01A56:  MOVWF  xDC
01A58:  MOVWF  xDD
01A5A:  MOVWF  xDE
01A5C:  MOVWF  xDF
01A5E:  MOVWF  xE0
01A60:  MOVWF  xE1
01A62:  MOVWF  xE2
01A64:  MOVWF  xE3
01A66:  MOVWF  xE4
01A68:  MOVWF  xE5
01A6A:  MOVWF  xE6
01A6C:  MOVWF  xE7
01A6E:  MOVWF  xE8
01A70:  MOVLW  01
01A72:  MOVWF  xE9
01A74:  MOVWF  xEA
01A76:  MOVWF  xEB
01A78:  MOVWF  xEC
01A7A:  MOVLW  03
01A7C:  MOVWF  xED
01A7E:  MOVWF  xEE
01A80:  MOVWF  xEF
01A82:  MOVWF  xF0
01A84:  MOVWF  xF1
01A86:  MOVWF  xF2
01A88:  MOVWF  xF3
01A8A:  MOVWF  xF4
01A8C:  MOVWF  xF5
01A8E:  MOVWF  xF6
01A90:  MOVWF  xF7
01A92:  MOVWF  xF8
01A94:  MOVWF  xF9
01A96:  MOVWF  xFA
01A98:  MOVWF  xFB
01A9A:  MOVWF  xFC
01A9C:  MOVWF  xFD
01A9E:  MOVWF  xFE
01AA0:  MOVWF  xFF
01AA2:  MOVLB  6
01AA4:  MOVWF  x00
01AA6:  MOVWF  x01
01AA8:  MOVWF  x02
01AAA:  MOVWF  x03
01AAC:  MOVWF  x04
01AAE:  MOVWF  x05
01AB0:  MOVLW  01
01AB2:  MOVWF  x06
01AB4:  MOVWF  x07
01AB6:  MOVWF  x08
01AB8:  MOVWF  x09
01ABA:  MOVLW  03
01ABC:  MOVWF  x0A
01ABE:  MOVWF  x0B
01AC0:  MOVWF  x0C
01AC2:  MOVWF  x0D
01AC4:  MOVWF  x0E
01AC6:  MOVWF  x0F
01AC8:  MOVWF  x10
01ACA:  MOVWF  x11
01ACC:  MOVWF  x12
01ACE:  MOVWF  x13
01AD0:  MOVWF  x14
01AD2:  MOVWF  x15
01AD4:  MOVWF  x16
01AD6:  MOVWF  x17
01AD8:  MOVWF  x18
01ADA:  MOVWF  x19
01ADC:  MOVWF  x1A
01ADE:  MOVWF  x1B
01AE0:  MOVWF  x1C
01AE2:  MOVWF  x1D
01AE4:  MOVWF  x1E
01AE6:  MOVWF  x1F
01AE8:  MOVWF  x20
01AEA:  MOVWF  x21
01AEC:  MOVWF  x22
01AEE:  MOVLW  01
01AF0:  MOVWF  x23
01AF2:  MOVWF  x24
01AF4:  MOVWF  x25
01AF6:  MOVWF  x26
01AF8:  MOVLW  03
01AFA:  MOVWF  x27
01AFC:  MOVWF  x28
01AFE:  MOVWF  x29
01B00:  MOVWF  x2A
01B02:  MOVWF  x2B
01B04:  MOVWF  x2C
01B06:  MOVWF  x2D
01B08:  MOVWF  x2E
01B0A:  MOVWF  x2F
01B0C:  MOVWF  x30
01B0E:  MOVWF  x31
01B10:  MOVWF  x32
01B12:  MOVWF  x33
01B14:  MOVWF  x34
01B16:  MOVWF  x35
01B18:  MOVWF  x36
01B1A:  MOVWF  x37
01B1C:  MOVWF  x38
01B1E:  MOVWF  x39
01B20:  MOVWF  x3A
01B22:  MOVWF  x3B
01B24:  MOVWF  x3C
01B26:  MOVWF  x3D
01B28:  MOVWF  x3E
01B2A:  MOVWF  x3F
01B2C:  MOVLW  01
01B2E:  MOVWF  x40
01B30:  MOVWF  x41
01B32:  MOVWF  x42
01B34:  MOVWF  x43
01B36:  MOVLW  03
01B38:  MOVWF  x44
01B3A:  MOVWF  x45
01B3C:  MOVWF  x46
01B3E:  MOVWF  x47
01B40:  MOVWF  x48
01B42:  MOVWF  x49
01B44:  MOVWF  x4A
01B46:  MOVWF  x4B
01B48:  MOVWF  x4C
01B4A:  MOVWF  x4D
01B4C:  MOVWF  x4E
01B4E:  MOVWF  x4F
01B50:  MOVWF  x50
01B52:  MOVWF  x51
01B54:  MOVWF  x52
01B56:  MOVWF  x53
01B58:  MOVWF  x54
01B5A:  MOVWF  x55
01B5C:  MOVWF  x56
01B5E:  MOVWF  x57
01B60:  MOVWF  x58
01B62:  MOVWF  x59
01B64:  MOVWF  x5A
01B66:  MOVWF  x5B
01B68:  MOVWF  x5C
01B6A:  MOVLW  01
01B6C:  MOVWF  x5D
01B6E:  CLRF   x5E
01B70:  CLRF   x5F
01B72:  MOVWF  x60
01B74:  MOVLW  03
01B76:  MOVWF  x61
01B78:  MOVWF  x62
01B7A:  MOVWF  x63
01B7C:  MOVWF  x64
01B7E:  MOVWF  x65
01B80:  MOVWF  x66
01B82:  MOVWF  x67
01B84:  MOVWF  x68
01B86:  MOVWF  x69
01B88:  MOVWF  x6A
01B8A:  MOVWF  x6B
01B8C:  MOVWF  x6C
01B8E:  MOVWF  x6D
01B90:  MOVWF  x6E
01B92:  MOVWF  x6F
01B94:  MOVWF  x70
01B96:  MOVWF  x71
01B98:  MOVWF  x72
01B9A:  MOVWF  x73
01B9C:  MOVWF  x74
01B9E:  MOVWF  x75
01BA0:  MOVWF  x76
01BA2:  MOVWF  x77
01BA4:  MOVWF  x78
01BA6:  MOVWF  x79
01BA8:  MOVLW  01
01BAA:  MOVWF  x7A
01BAC:  CLRF   x7B
01BAE:  CLRF   x7C
01BB0:  MOVWF  x7D
01BB2:  MOVWF  x7E
01BB4:  MOVWF  x7F
01BB6:  MOVWF  x80
01BB8:  MOVWF  x81
01BBA:  MOVWF  x82
01BBC:  MOVWF  x83
01BBE:  MOVWF  x84
01BC0:  MOVWF  x85
01BC2:  MOVWF  x86
01BC4:  MOVWF  x87
01BC6:  MOVWF  x88
01BC8:  MOVWF  x89
01BCA:  MOVWF  x8A
01BCC:  MOVWF  x8B
01BCE:  MOVWF  x8C
01BD0:  MOVWF  x8D
01BD2:  MOVWF  x8E
01BD4:  MOVWF  x8F
01BD6:  MOVWF  x90
01BD8:  MOVWF  x91
01BDA:  MOVWF  x92
01BDC:  MOVWF  x93
01BDE:  MOVWF  x94
01BE0:  MOVWF  x95
01BE2:  MOVWF  x96
01BE4:  MOVWF  x97
01BE6:  CLRF   x98
01BE8:  CLRF   x99
....................       
....................     for(n=0; n<=319; n++) //draw a block 31 across by 11 down
01BEA:  MOVLB  5
01BEC:  CLRF   x58
01BEE:  CLRF   x57
01BF0:  MOVF   x58,W
01BF2:  SUBLW  01
01BF4:  BNC   1C9E
01BF6:  BNZ   1BFE
01BF8:  MOVF   x57,W
01BFA:  SUBLW  3F
01BFC:  BNC   1C9E
....................     {
....................        if(Full_Batt[n] == 1)  //white
01BFE:  MOVLW  5B
01C00:  ADDWF  x57,W
01C02:  MOVWF  3FE9
01C04:  MOVLW  05
01C06:  ADDWFC x58,W
01C08:  MOVWF  3FEA
01C0A:  DECFSZ 3FEF,W
01C0C:  BRA    1C2E
....................        {
....................             Data_Out(0xFF);
01C0E:  MOVLB  8
01C10:  SETF   x54
01C12:  MOVLB  0
01C14:  CALL   0636
....................             Data_Out(0xFF);
01C18:  MOVLB  8
01C1A:  SETF   x54
01C1C:  MOVLB  0
01C1E:  CALL   0636
....................             Data_Out(0xFF);
01C22:  MOVLB  8
01C24:  SETF   x54
01C26:  MOVLB  0
01C28:  CALL   0636
01C2C:  MOVLB  5
....................        } 
....................        
....................        if(Full_Batt[n] == 0)  //black
01C2E:  MOVLW  5B
01C30:  ADDWF  x57,W
01C32:  MOVWF  3FE9
01C34:  MOVLW  05
01C36:  ADDWFC x58,W
01C38:  MOVWF  3FEA
01C3A:  MOVF   3FEF,F
01C3C:  BNZ   1C5E
....................        {
....................             Data_Out(0x00);
01C3E:  MOVLB  8
01C40:  CLRF   x54
01C42:  MOVLB  0
01C44:  CALL   0636
....................             Data_Out(0x00);
01C48:  MOVLB  8
01C4A:  CLRF   x54
01C4C:  MOVLB  0
01C4E:  CALL   0636
....................             Data_Out(0x00);
01C52:  MOVLB  8
01C54:  CLRF   x54
01C56:  MOVLB  0
01C58:  CALL   0636
01C5C:  MOVLB  5
....................        }
....................  
....................        if(Full_Batt[n] == 3)  //grey
01C5E:  MOVLW  5B
01C60:  ADDWF  x57,W
01C62:  MOVWF  3FE9
01C64:  MOVLW  05
01C66:  ADDWFC x58,W
01C68:  MOVWF  3FEA
01C6A:  MOVF   3FEF,W
01C6C:  SUBLW  03
01C6E:  BNZ   1C96
....................        {
....................             Data_Out(0x60);
01C70:  MOVLW  60
01C72:  MOVLB  8
01C74:  MOVWF  x54
01C76:  MOVLB  0
01C78:  CALL   0636
....................             Data_Out(0x60);
01C7C:  MOVLW  60
01C7E:  MOVLB  8
01C80:  MOVWF  x54
01C82:  MOVLB  0
01C84:  CALL   0636
....................             Data_Out(0x60);
01C88:  MOVLW  60
01C8A:  MOVLB  8
01C8C:  MOVWF  x54
01C8E:  MOVLB  0
01C90:  CALL   0636
01C94:  MOVLB  5
....................        }
01C96:  INCF   x57,F
01C98:  BTFSC  3FD8.2
01C9A:  INCF   x58,F
01C9C:  BRA    1BF0
.................... 
....................     }
01C9E:  MOVLB  0
01CA0:  RETURN 0
....................     //fprintf(DEBUG,"\n\r %u, %u", g_BLE_Logo, g_Paired);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... /**
....................     Draw 3_4_Battery,
.................... 
.................... **/
.................... void    Draw_Three_Quart_Battery(uint8_t Batt_Id)
.................... {
....................     uint16_t    n;
....................     uint8_t x,y;
....................    
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................     
....................      x=  X_CENTER;
*
0151C:  MOVLW  40
0151E:  MOVLB  5
01520:  MOVWF  x59
....................     
....................     if(Batt_ID== HEAD)
01522:  MOVF   x56,F
01524:  BNZ   152C
....................         y = Y_CENTER +30;
01526:  MOVLW  5A
01528:  MOVWF  x5A
0152A:  BRA    1530
....................     else
....................         y = Y_CENTER + 80;    
0152C:  MOVLW  8C
0152E:  MOVWF  x5A
....................       
....................     Set_Column_Address(0,(x-14),0,(x+14)); //X coordinate
01530:  MOVLW  0E
01532:  SUBWF  x59,W
01534:  MOVLB  6
01536:  MOVWF  x9A
01538:  MOVLW  0E
0153A:  MOVLB  5
0153C:  ADDWF  x59,W
0153E:  MOVLB  6
01540:  MOVWF  x9B
01542:  MOVLB  8
01544:  CLRF   x50
01546:  MOVFF  69A,851
0154A:  CLRF   x52
0154C:  MOVWF  x53
0154E:  MOVLB  0
01550:  CALL   0D50
....................     Set_Page_Address(0,(y-5),0,(y+5));    //y coordinate
01554:  MOVLW  05
01556:  MOVLB  5
01558:  SUBWF  x5A,W
0155A:  MOVLB  6
0155C:  MOVWF  x9A
0155E:  MOVLW  05
01560:  MOVLB  5
01562:  ADDWF  x5A,W
01564:  MOVLB  6
01566:  MOVWF  x9B
01568:  MOVLB  8
0156A:  CLRF   x50
0156C:  MOVFF  69A,851
01570:  CLRF   x52
01572:  MOVWF  x53
01574:  MOVLB  0
01576:  CALL   0D74
....................     Write_Memory_Start();
0157A:  RCALL  0D98
....................     
....................     uint8_t Three_Quart_Batt[319]= {
....................     
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,1,1,1, 
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,1,0,0,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0};
0157C:  MOVLW  01
0157E:  MOVLB  5
01580:  MOVWF  x5B
01582:  MOVWF  x5C
01584:  MOVWF  x5D
01586:  MOVWF  x5E
01588:  MOVWF  x5F
0158A:  MOVWF  x60
0158C:  MOVWF  x61
0158E:  MOVWF  x62
01590:  MOVWF  x63
01592:  MOVWF  x64
01594:  MOVWF  x65
01596:  MOVWF  x66
01598:  MOVWF  x67
0159A:  MOVWF  x68
0159C:  MOVWF  x69
0159E:  MOVWF  x6A
015A0:  MOVWF  x6B
015A2:  MOVWF  x6C
015A4:  MOVWF  x6D
015A6:  MOVWF  x6E
015A8:  MOVWF  x6F
015AA:  MOVWF  x70
015AC:  MOVWF  x71
015AE:  MOVWF  x72
015B0:  MOVWF  x73
015B2:  MOVWF  x74
015B4:  MOVWF  x75
015B6:  CLRF   x76
015B8:  CLRF   x77
015BA:  MOVWF  x78
015BC:  MOVLW  03
015BE:  MOVWF  x79
015C0:  MOVWF  x7A
015C2:  MOVWF  x7B
015C4:  MOVWF  x7C
015C6:  MOVWF  x7D
015C8:  MOVWF  x7E
015CA:  MOVWF  x7F
015CC:  MOVWF  x80
015CE:  MOVWF  x81
015D0:  MOVWF  x82
015D2:  MOVWF  x83
015D4:  MOVWF  x84
015D6:  MOVWF  x85
015D8:  MOVWF  x86
015DA:  MOVWF  x87
015DC:  MOVWF  x88
015DE:  MOVWF  x89
015E0:  MOVWF  x8A
015E2:  MOVWF  x8B
015E4:  MOVWF  x8C
015E6:  CLRF   x8D
015E8:  CLRF   x8E
015EA:  CLRF   x8F
015EC:  CLRF   x90
015EE:  CLRF   x91
015F0:  MOVLW  01
015F2:  MOVWF  x92
015F4:  CLRF   x93
015F6:  CLRF   x94
015F8:  MOVWF  x95
015FA:  MOVLW  03
015FC:  MOVWF  x96
015FE:  MOVWF  x97
01600:  MOVWF  x98
01602:  MOVWF  x99
01604:  MOVWF  x9A
01606:  MOVWF  x9B
01608:  MOVWF  x9C
0160A:  MOVWF  x9D
0160C:  MOVWF  x9E
0160E:  MOVWF  x9F
01610:  MOVWF  xA0
01612:  MOVWF  xA1
01614:  MOVWF  xA2
01616:  MOVWF  xA3
01618:  MOVWF  xA4
0161A:  MOVWF  xA5
0161C:  MOVWF  xA6
0161E:  MOVWF  xA7
01620:  MOVWF  xA8
01622:  MOVWF  xA9
01624:  CLRF   xAA
01626:  CLRF   xAB
01628:  CLRF   xAC
0162A:  CLRF   xAD
0162C:  CLRF   xAE
0162E:  MOVLW  01
01630:  MOVWF  xAF
01632:  CLRF   xB0
01634:  CLRF   xB1
01636:  MOVWF  xB2
01638:  MOVLW  03
0163A:  MOVWF  xB3
0163C:  MOVWF  xB4
0163E:  MOVWF  xB5
01640:  MOVWF  xB6
01642:  MOVWF  xB7
01644:  MOVWF  xB8
01646:  MOVWF  xB9
01648:  MOVWF  xBA
0164A:  MOVWF  xBB
0164C:  MOVWF  xBC
0164E:  MOVWF  xBD
01650:  MOVWF  xBE
01652:  MOVWF  xBF
01654:  MOVWF  xC0
01656:  MOVWF  xC1
01658:  MOVWF  xC2
0165A:  MOVWF  xC3
0165C:  MOVWF  xC4
0165E:  MOVWF  xC5
01660:  MOVWF  xC6
01662:  CLRF   xC7
01664:  CLRF   xC8
01666:  CLRF   xC9
01668:  CLRF   xCA
0166A:  CLRF   xCB
0166C:  MOVLW  01
0166E:  MOVWF  xCC
01670:  MOVWF  xCD
01672:  MOVWF  xCE
01674:  MOVWF  xCF
01676:  MOVLW  03
01678:  MOVWF  xD0
0167A:  MOVWF  xD1
0167C:  MOVWF  xD2
0167E:  MOVWF  xD3
01680:  MOVWF  xD4
01682:  MOVWF  xD5
01684:  MOVWF  xD6
01686:  MOVWF  xD7
01688:  MOVWF  xD8
0168A:  MOVWF  xD9
0168C:  MOVWF  xDA
0168E:  MOVWF  xDB
01690:  MOVWF  xDC
01692:  MOVWF  xDD
01694:  MOVWF  xDE
01696:  MOVWF  xDF
01698:  MOVWF  xE0
0169A:  MOVWF  xE1
0169C:  MOVWF  xE2
0169E:  MOVWF  xE3
016A0:  CLRF   xE4
016A2:  CLRF   xE5
016A4:  CLRF   xE6
016A6:  CLRF   xE7
016A8:  CLRF   xE8
016AA:  MOVLW  01
016AC:  MOVWF  xE9
016AE:  MOVWF  xEA
016B0:  MOVWF  xEB
016B2:  MOVWF  xEC
016B4:  MOVLW  03
016B6:  MOVWF  xED
016B8:  MOVWF  xEE
016BA:  MOVWF  xEF
016BC:  MOVWF  xF0
016BE:  MOVWF  xF1
016C0:  MOVWF  xF2
016C2:  MOVWF  xF3
016C4:  MOVWF  xF4
016C6:  MOVWF  xF5
016C8:  MOVWF  xF6
016CA:  MOVWF  xF7
016CC:  MOVWF  xF8
016CE:  MOVWF  xF9
016D0:  MOVWF  xFA
016D2:  MOVWF  xFB
016D4:  MOVWF  xFC
016D6:  MOVWF  xFD
016D8:  MOVWF  xFE
016DA:  MOVWF  xFF
016DC:  MOVLB  6
016DE:  MOVWF  x00
016E0:  CLRF   x01
016E2:  CLRF   x02
016E4:  CLRF   x03
016E6:  CLRF   x04
016E8:  CLRF   x05
016EA:  MOVLW  01
016EC:  MOVWF  x06
016EE:  MOVWF  x07
016F0:  MOVWF  x08
016F2:  MOVWF  x09
016F4:  MOVLW  03
016F6:  MOVWF  x0A
016F8:  MOVWF  x0B
016FA:  MOVWF  x0C
016FC:  MOVWF  x0D
016FE:  MOVWF  x0E
01700:  MOVWF  x0F
01702:  MOVWF  x10
01704:  MOVWF  x11
01706:  MOVWF  x12
01708:  MOVWF  x13
0170A:  MOVWF  x14
0170C:  MOVWF  x15
0170E:  MOVWF  x16
01710:  MOVWF  x17
01712:  MOVWF  x18
01714:  MOVWF  x19
01716:  MOVWF  x1A
01718:  MOVWF  x1B
0171A:  MOVWF  x1C
0171C:  MOVWF  x1D
0171E:  CLRF   x1E
01720:  CLRF   x1F
01722:  CLRF   x20
01724:  CLRF   x21
01726:  CLRF   x22
01728:  MOVLW  01
0172A:  MOVWF  x23
0172C:  MOVWF  x24
0172E:  MOVWF  x25
01730:  MOVWF  x26
01732:  MOVLW  03
01734:  MOVWF  x27
01736:  MOVWF  x28
01738:  MOVWF  x29
0173A:  MOVWF  x2A
0173C:  MOVWF  x2B
0173E:  MOVWF  x2C
01740:  MOVWF  x2D
01742:  MOVWF  x2E
01744:  MOVWF  x2F
01746:  MOVWF  x30
01748:  MOVWF  x31
0174A:  MOVWF  x32
0174C:  MOVWF  x33
0174E:  MOVWF  x34
01750:  MOVWF  x35
01752:  MOVWF  x36
01754:  MOVWF  x37
01756:  MOVWF  x38
01758:  MOVWF  x39
0175A:  MOVWF  x3A
0175C:  CLRF   x3B
0175E:  CLRF   x3C
01760:  CLRF   x3D
01762:  CLRF   x3E
01764:  CLRF   x3F
01766:  MOVLW  01
01768:  MOVWF  x40
0176A:  MOVWF  x41
0176C:  MOVWF  x42
0176E:  MOVWF  x43
01770:  MOVLW  03
01772:  MOVWF  x44
01774:  MOVWF  x45
01776:  MOVWF  x46
01778:  MOVWF  x47
0177A:  MOVWF  x48
0177C:  MOVWF  x49
0177E:  MOVWF  x4A
01780:  MOVWF  x4B
01782:  MOVWF  x4C
01784:  MOVWF  x4D
01786:  MOVWF  x4E
01788:  MOVWF  x4F
0178A:  MOVWF  x50
0178C:  MOVWF  x51
0178E:  MOVWF  x52
01790:  MOVWF  x53
01792:  MOVWF  x54
01794:  MOVWF  x55
01796:  MOVWF  x56
01798:  MOVWF  x57
0179A:  CLRF   x58
0179C:  CLRF   x59
0179E:  CLRF   x5A
017A0:  CLRF   x5B
017A2:  CLRF   x5C
017A4:  MOVLW  01
017A6:  MOVWF  x5D
017A8:  CLRF   x5E
017AA:  CLRF   x5F
017AC:  MOVWF  x60
017AE:  MOVLW  03
017B0:  MOVWF  x61
017B2:  MOVWF  x62
017B4:  MOVWF  x63
017B6:  MOVWF  x64
017B8:  MOVWF  x65
017BA:  MOVWF  x66
017BC:  MOVWF  x67
017BE:  MOVWF  x68
017C0:  MOVWF  x69
017C2:  MOVWF  x6A
017C4:  MOVWF  x6B
017C6:  MOVWF  x6C
017C8:  MOVWF  x6D
017CA:  MOVWF  x6E
017CC:  MOVWF  x6F
017CE:  MOVWF  x70
017D0:  MOVWF  x71
017D2:  MOVWF  x72
017D4:  MOVWF  x73
017D6:  CLRF   x74
017D8:  CLRF   x75
017DA:  CLRF   x76
017DC:  CLRF   x77
017DE:  CLRF   x78
017E0:  CLRF   x79
017E2:  MOVLW  01
017E4:  MOVWF  x7A
017E6:  CLRF   x7B
017E8:  CLRF   x7C
017EA:  MOVWF  x7D
017EC:  MOVWF  x7E
017EE:  MOVWF  x7F
017F0:  MOVWF  x80
017F2:  MOVWF  x81
017F4:  MOVWF  x82
017F6:  MOVWF  x83
017F8:  MOVWF  x84
017FA:  MOVWF  x85
017FC:  MOVWF  x86
017FE:  MOVWF  x87
01800:  MOVWF  x88
01802:  MOVWF  x89
01804:  MOVWF  x8A
01806:  MOVWF  x8B
01808:  MOVWF  x8C
0180A:  MOVWF  x8D
0180C:  MOVWF  x8E
0180E:  MOVWF  x8F
01810:  MOVWF  x90
01812:  MOVWF  x91
01814:  MOVWF  x92
01816:  MOVWF  x93
01818:  MOVWF  x94
0181A:  MOVWF  x95
0181C:  MOVWF  x96
0181E:  MOVWF  x97
01820:  CLRF   x98
01822:  CLRF   x99
....................       
....................     for(n=0; n<=319; n++) //draw a block 31 across by 11 down
01824:  MOVLB  5
01826:  CLRF   x58
01828:  CLRF   x57
0182A:  MOVF   x58,W
0182C:  SUBLW  01
0182E:  BNC   18D8
01830:  BNZ   1838
01832:  MOVF   x57,W
01834:  SUBLW  3F
01836:  BNC   18D8
....................     {
....................        if(Three_Quart_Batt[n] == 1)  //white
01838:  MOVLW  5B
0183A:  ADDWF  x57,W
0183C:  MOVWF  3FE9
0183E:  MOVLW  05
01840:  ADDWFC x58,W
01842:  MOVWF  3FEA
01844:  DECFSZ 3FEF,W
01846:  BRA    1868
....................        {
....................             Data_Out(0xFF);
01848:  MOVLB  8
0184A:  SETF   x54
0184C:  MOVLB  0
0184E:  CALL   0636
....................             Data_Out(0xFF);
01852:  MOVLB  8
01854:  SETF   x54
01856:  MOVLB  0
01858:  CALL   0636
....................             Data_Out(0xFF);
0185C:  MOVLB  8
0185E:  SETF   x54
01860:  MOVLB  0
01862:  CALL   0636
01866:  MOVLB  5
....................        } 
....................        
....................        if(Three_Quart_Batt[n] == 0)  //black
01868:  MOVLW  5B
0186A:  ADDWF  x57,W
0186C:  MOVWF  3FE9
0186E:  MOVLW  05
01870:  ADDWFC x58,W
01872:  MOVWF  3FEA
01874:  MOVF   3FEF,F
01876:  BNZ   1898
....................        {
....................             Data_Out(0x00);
01878:  MOVLB  8
0187A:  CLRF   x54
0187C:  MOVLB  0
0187E:  CALL   0636
....................             Data_Out(0x00);
01882:  MOVLB  8
01884:  CLRF   x54
01886:  MOVLB  0
01888:  CALL   0636
....................             Data_Out(0x00);
0188C:  MOVLB  8
0188E:  CLRF   x54
01890:  MOVLB  0
01892:  CALL   0636
01896:  MOVLB  5
....................        }
....................  
....................        if(Three_Quart_Batt[n] == 3)  //green
01898:  MOVLW  5B
0189A:  ADDWF  x57,W
0189C:  MOVWF  3FE9
0189E:  MOVLW  05
018A0:  ADDWFC x58,W
018A2:  MOVWF  3FEA
018A4:  MOVF   3FEF,W
018A6:  SUBLW  03
018A8:  BNZ   18D0
....................        {
....................             Data_Out(0x60);
018AA:  MOVLW  60
018AC:  MOVLB  8
018AE:  MOVWF  x54
018B0:  MOVLB  0
018B2:  CALL   0636
....................             Data_Out(0x60);
018B6:  MOVLW  60
018B8:  MOVLB  8
018BA:  MOVWF  x54
018BC:  MOVLB  0
018BE:  CALL   0636
....................             Data_Out(0x60);
018C2:  MOVLW  60
018C4:  MOVLB  8
018C6:  MOVWF  x54
018C8:  MOVLB  0
018CA:  CALL   0636
018CE:  MOVLB  5
....................        }
018D0:  INCF   x57,F
018D2:  BTFSC  3FD8.2
018D4:  INCF   x58,F
018D6:  BRA    182A
.................... 
....................     }
018D8:  MOVLB  0
018DA:  RETURN 0
....................     //fprintf(DEBUG,"\n\r %u, %u", g_BLE_Logo, g_Paired);
.................... }
.................... 
.................... 
.................... 
.................... /**
....................     Draw Battery_Half Full
.................... 
.................... **/
.................... void    Draw_Half_Battery(uint8_t Batt_Id)
.................... {
....................     uint16_t    n;
....................     uint8_t x,y;
....................    
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................     
....................     x=  X_CENTER ;
*
01160:  MOVLW  40
01162:  MOVLB  5
01164:  MOVWF  x59
....................     
....................     if(Batt_ID== HEAD)
01166:  MOVF   x56,F
01168:  BNZ   1170
....................         y = Y_CENTER +30;
0116A:  MOVLW  5A
0116C:  MOVWF  x5A
0116E:  BRA    1174
....................     else
....................         y = Y_CENTER + 80;    
01170:  MOVLW  8C
01172:  MOVWF  x5A
....................             
....................       
....................     Set_Column_Address(0,(x-14),0,(x+14)); //X coordinate
01174:  MOVLW  0E
01176:  SUBWF  x59,W
01178:  MOVLB  6
0117A:  MOVWF  x9A
0117C:  MOVLW  0E
0117E:  MOVLB  5
01180:  ADDWF  x59,W
01182:  MOVLB  6
01184:  MOVWF  x9B
01186:  MOVLB  8
01188:  CLRF   x50
0118A:  MOVFF  69A,851
0118E:  CLRF   x52
01190:  MOVWF  x53
01192:  MOVLB  0
01194:  RCALL  0D50
....................     Set_Page_Address(0,(y-5),0,(y+5));    //y coordinate
01196:  MOVLW  05
01198:  MOVLB  5
0119A:  SUBWF  x5A,W
0119C:  MOVLB  6
0119E:  MOVWF  x9A
011A0:  MOVLW  05
011A2:  MOVLB  5
011A4:  ADDWF  x5A,W
011A6:  MOVLB  6
011A8:  MOVWF  x9B
011AA:  MOVLB  8
011AC:  CLRF   x50
011AE:  MOVFF  69A,851
011B2:  CLRF   x52
011B4:  MOVWF  x53
011B6:  MOVLB  0
011B8:  RCALL  0D74
....................     Write_Memory_Start();
011BA:  RCALL  0D98
....................     
....................     uint8_t Half_Batt[319]= {
....................     
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1, 
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0};
011BC:  MOVLW  01
011BE:  MOVLB  5
011C0:  MOVWF  x5B
011C2:  MOVWF  x5C
011C4:  MOVWF  x5D
011C6:  MOVWF  x5E
011C8:  MOVWF  x5F
011CA:  MOVWF  x60
011CC:  MOVWF  x61
011CE:  MOVWF  x62
011D0:  MOVWF  x63
011D2:  MOVWF  x64
011D4:  MOVWF  x65
011D6:  MOVWF  x66
011D8:  MOVWF  x67
011DA:  MOVWF  x68
011DC:  MOVWF  x69
011DE:  MOVWF  x6A
011E0:  MOVWF  x6B
011E2:  MOVWF  x6C
011E4:  MOVWF  x6D
011E6:  MOVWF  x6E
011E8:  MOVWF  x6F
011EA:  MOVWF  x70
011EC:  MOVWF  x71
011EE:  MOVWF  x72
011F0:  MOVWF  x73
011F2:  MOVWF  x74
011F4:  MOVWF  x75
011F6:  CLRF   x76
011F8:  CLRF   x77
011FA:  MOVWF  x78
011FC:  MOVLW  03
011FE:  MOVWF  x79
01200:  MOVWF  x7A
01202:  MOVWF  x7B
01204:  MOVWF  x7C
01206:  MOVWF  x7D
01208:  MOVWF  x7E
0120A:  MOVWF  x7F
0120C:  MOVWF  x80
0120E:  MOVWF  x81
01210:  MOVWF  x82
01212:  MOVWF  x83
01214:  MOVWF  x84
01216:  MOVWF  x85
01218:  CLRF   x86
0121A:  CLRF   x87
0121C:  CLRF   x88
0121E:  CLRF   x89
01220:  CLRF   x8A
01222:  CLRF   x8B
01224:  CLRF   x8C
01226:  CLRF   x8D
01228:  CLRF   x8E
0122A:  CLRF   x8F
0122C:  CLRF   x90
0122E:  CLRF   x91
01230:  MOVLW  01
01232:  MOVWF  x92
01234:  CLRF   x93
01236:  CLRF   x94
01238:  MOVWF  x95
0123A:  MOVLW  03
0123C:  MOVWF  x96
0123E:  MOVWF  x97
01240:  MOVWF  x98
01242:  MOVWF  x99
01244:  MOVWF  x9A
01246:  MOVWF  x9B
01248:  MOVWF  x9C
0124A:  MOVWF  x9D
0124C:  MOVWF  x9E
0124E:  MOVWF  x9F
01250:  MOVWF  xA0
01252:  MOVWF  xA1
01254:  MOVWF  xA2
01256:  CLRF   xA3
01258:  CLRF   xA4
0125A:  CLRF   xA5
0125C:  CLRF   xA6
0125E:  CLRF   xA7
01260:  CLRF   xA8
01262:  CLRF   xA9
01264:  CLRF   xAA
01266:  CLRF   xAB
01268:  CLRF   xAC
0126A:  CLRF   xAD
0126C:  CLRF   xAE
0126E:  MOVLW  01
01270:  MOVWF  xAF
01272:  CLRF   xB0
01274:  CLRF   xB1
01276:  MOVWF  xB2
01278:  MOVLW  03
0127A:  MOVWF  xB3
0127C:  MOVWF  xB4
0127E:  MOVWF  xB5
01280:  MOVWF  xB6
01282:  MOVWF  xB7
01284:  MOVWF  xB8
01286:  MOVWF  xB9
01288:  MOVWF  xBA
0128A:  MOVWF  xBB
0128C:  MOVWF  xBC
0128E:  MOVWF  xBD
01290:  MOVWF  xBE
01292:  MOVWF  xBF
01294:  CLRF   xC0
01296:  CLRF   xC1
01298:  CLRF   xC2
0129A:  CLRF   xC3
0129C:  CLRF   xC4
0129E:  CLRF   xC5
012A0:  CLRF   xC6
012A2:  CLRF   xC7
012A4:  CLRF   xC8
012A6:  CLRF   xC9
012A8:  CLRF   xCA
012AA:  CLRF   xCB
012AC:  MOVLW  01
012AE:  MOVWF  xCC
012B0:  MOVWF  xCD
012B2:  MOVWF  xCE
012B4:  MOVWF  xCF
012B6:  MOVLW  03
012B8:  MOVWF  xD0
012BA:  MOVWF  xD1
012BC:  MOVWF  xD2
012BE:  MOVWF  xD3
012C0:  MOVWF  xD4
012C2:  MOVWF  xD5
012C4:  MOVWF  xD6
012C6:  MOVWF  xD7
012C8:  MOVWF  xD8
012CA:  MOVWF  xD9
012CC:  MOVWF  xDA
012CE:  MOVWF  xDB
012D0:  MOVWF  xDC
012D2:  CLRF   xDD
012D4:  CLRF   xDE
012D6:  CLRF   xDF
012D8:  CLRF   xE0
012DA:  CLRF   xE1
012DC:  CLRF   xE2
012DE:  CLRF   xE3
012E0:  CLRF   xE4
012E2:  CLRF   xE5
012E4:  CLRF   xE6
012E6:  CLRF   xE7
012E8:  CLRF   xE8
012EA:  MOVLW  01
012EC:  MOVWF  xE9
012EE:  MOVWF  xEA
012F0:  MOVWF  xEB
012F2:  MOVWF  xEC
012F4:  MOVLW  03
012F6:  MOVWF  xED
012F8:  MOVWF  xEE
012FA:  MOVWF  xEF
012FC:  MOVWF  xF0
012FE:  MOVWF  xF1
01300:  MOVWF  xF2
01302:  MOVWF  xF3
01304:  MOVWF  xF4
01306:  MOVWF  xF5
01308:  MOVWF  xF6
0130A:  MOVWF  xF7
0130C:  MOVWF  xF8
0130E:  MOVWF  xF9
01310:  CLRF   xFA
01312:  CLRF   xFB
01314:  CLRF   xFC
01316:  CLRF   xFD
01318:  CLRF   xFE
0131A:  CLRF   xFF
0131C:  MOVLB  6
0131E:  CLRF   x00
01320:  CLRF   x01
01322:  CLRF   x02
01324:  CLRF   x03
01326:  CLRF   x04
01328:  CLRF   x05
0132A:  MOVLW  01
0132C:  MOVWF  x06
0132E:  MOVWF  x07
01330:  MOVWF  x08
01332:  MOVWF  x09
01334:  MOVLW  03
01336:  MOVWF  x0A
01338:  MOVWF  x0B
0133A:  MOVWF  x0C
0133C:  MOVWF  x0D
0133E:  MOVWF  x0E
01340:  MOVWF  x0F
01342:  MOVWF  x10
01344:  MOVWF  x11
01346:  MOVWF  x12
01348:  MOVWF  x13
0134A:  MOVWF  x14
0134C:  MOVWF  x15
0134E:  MOVWF  x16
01350:  CLRF   x17
01352:  CLRF   x18
01354:  CLRF   x19
01356:  CLRF   x1A
01358:  CLRF   x1B
0135A:  CLRF   x1C
0135C:  CLRF   x1D
0135E:  CLRF   x1E
01360:  CLRF   x1F
01362:  CLRF   x20
01364:  CLRF   x21
01366:  CLRF   x22
01368:  MOVLW  01
0136A:  MOVWF  x23
0136C:  MOVWF  x24
0136E:  MOVWF  x25
01370:  MOVWF  x26
01372:  MOVLW  03
01374:  MOVWF  x27
01376:  MOVWF  x28
01378:  MOVWF  x29
0137A:  MOVWF  x2A
0137C:  MOVWF  x2B
0137E:  MOVWF  x2C
01380:  MOVWF  x2D
01382:  MOVWF  x2E
01384:  MOVWF  x2F
01386:  MOVWF  x30
01388:  MOVWF  x31
0138A:  MOVWF  x32
0138C:  MOVWF  x33
0138E:  CLRF   x34
01390:  CLRF   x35
01392:  CLRF   x36
01394:  CLRF   x37
01396:  CLRF   x38
01398:  CLRF   x39
0139A:  CLRF   x3A
0139C:  CLRF   x3B
0139E:  CLRF   x3C
013A0:  CLRF   x3D
013A2:  CLRF   x3E
013A4:  CLRF   x3F
013A6:  MOVLW  01
013A8:  MOVWF  x40
013AA:  MOVWF  x41
013AC:  MOVWF  x42
013AE:  MOVWF  x43
013B0:  MOVLW  03
013B2:  MOVWF  x44
013B4:  MOVWF  x45
013B6:  MOVWF  x46
013B8:  MOVWF  x47
013BA:  MOVWF  x48
013BC:  MOVWF  x49
013BE:  MOVWF  x4A
013C0:  MOVWF  x4B
013C2:  MOVWF  x4C
013C4:  MOVWF  x4D
013C6:  MOVWF  x4E
013C8:  MOVWF  x4F
013CA:  MOVWF  x50
013CC:  CLRF   x51
013CE:  CLRF   x52
013D0:  CLRF   x53
013D2:  CLRF   x54
013D4:  CLRF   x55
013D6:  CLRF   x56
013D8:  CLRF   x57
013DA:  CLRF   x58
013DC:  CLRF   x59
013DE:  CLRF   x5A
013E0:  CLRF   x5B
013E2:  CLRF   x5C
013E4:  MOVLW  01
013E6:  MOVWF  x5D
013E8:  CLRF   x5E
013EA:  CLRF   x5F
013EC:  MOVWF  x60
013EE:  MOVLW  03
013F0:  MOVWF  x61
013F2:  MOVWF  x62
013F4:  MOVWF  x63
013F6:  MOVWF  x64
013F8:  MOVWF  x65
013FA:  MOVWF  x66
013FC:  MOVWF  x67
013FE:  MOVWF  x68
01400:  MOVWF  x69
01402:  MOVWF  x6A
01404:  MOVWF  x6B
01406:  MOVWF  x6C
01408:  MOVWF  x6D
0140A:  CLRF   x6E
0140C:  CLRF   x6F
0140E:  CLRF   x70
01410:  CLRF   x71
01412:  CLRF   x72
01414:  CLRF   x73
01416:  CLRF   x74
01418:  CLRF   x75
0141A:  CLRF   x76
0141C:  CLRF   x77
0141E:  CLRF   x78
01420:  CLRF   x79
01422:  MOVLW  01
01424:  MOVWF  x7A
01426:  CLRF   x7B
01428:  CLRF   x7C
0142A:  MOVWF  x7D
0142C:  MOVWF  x7E
0142E:  MOVWF  x7F
01430:  MOVWF  x80
01432:  MOVWF  x81
01434:  MOVWF  x82
01436:  MOVWF  x83
01438:  MOVWF  x84
0143A:  MOVWF  x85
0143C:  MOVWF  x86
0143E:  MOVWF  x87
01440:  MOVWF  x88
01442:  MOVWF  x89
01444:  MOVWF  x8A
01446:  MOVWF  x8B
01448:  MOVWF  x8C
0144A:  MOVWF  x8D
0144C:  MOVWF  x8E
0144E:  MOVWF  x8F
01450:  MOVWF  x90
01452:  MOVWF  x91
01454:  MOVWF  x92
01456:  MOVWF  x93
01458:  MOVWF  x94
0145A:  MOVWF  x95
0145C:  MOVWF  x96
0145E:  MOVWF  x97
01460:  CLRF   x98
01462:  CLRF   x99
....................       
....................     for(n=0; n<=319; n++) //draw a block 31 across by 11 down
01464:  MOVLB  5
01466:  CLRF   x58
01468:  CLRF   x57
0146A:  MOVF   x58,W
0146C:  SUBLW  01
0146E:  BNC   1518
01470:  BNZ   1478
01472:  MOVF   x57,W
01474:  SUBLW  3F
01476:  BNC   1518
....................     {
....................        if(Half_Batt[n] == 1)  //white
01478:  MOVLW  5B
0147A:  ADDWF  x57,W
0147C:  MOVWF  3FE9
0147E:  MOVLW  05
01480:  ADDWFC x58,W
01482:  MOVWF  3FEA
01484:  DECFSZ 3FEF,W
01486:  BRA    14A8
....................        {
....................             Data_Out(0xFF);
01488:  MOVLB  8
0148A:  SETF   x54
0148C:  MOVLB  0
0148E:  CALL   0636
....................             Data_Out(0xFF);
01492:  MOVLB  8
01494:  SETF   x54
01496:  MOVLB  0
01498:  CALL   0636
....................             Data_Out(0xFF);
0149C:  MOVLB  8
0149E:  SETF   x54
014A0:  MOVLB  0
014A2:  CALL   0636
014A6:  MOVLB  5
....................        } 
....................        
....................        if(Half_Batt[n] == 0)  //black
014A8:  MOVLW  5B
014AA:  ADDWF  x57,W
014AC:  MOVWF  3FE9
014AE:  MOVLW  05
014B0:  ADDWFC x58,W
014B2:  MOVWF  3FEA
014B4:  MOVF   3FEF,F
014B6:  BNZ   14D8
....................        {
....................             Data_Out(0x00);
014B8:  MOVLB  8
014BA:  CLRF   x54
014BC:  MOVLB  0
014BE:  CALL   0636
....................             Data_Out(0x00);
014C2:  MOVLB  8
014C4:  CLRF   x54
014C6:  MOVLB  0
014C8:  CALL   0636
....................             Data_Out(0x00);
014CC:  MOVLB  8
014CE:  CLRF   x54
014D0:  MOVLB  0
014D2:  CALL   0636
014D6:  MOVLB  5
....................        }
....................  
....................        if(Half_Batt[n] == 3)  //grey
014D8:  MOVLW  5B
014DA:  ADDWF  x57,W
014DC:  MOVWF  3FE9
014DE:  MOVLW  05
014E0:  ADDWFC x58,W
014E2:  MOVWF  3FEA
014E4:  MOVF   3FEF,W
014E6:  SUBLW  03
014E8:  BNZ   1510
....................        {
....................             Data_Out(0x60);
014EA:  MOVLW  60
014EC:  MOVLB  8
014EE:  MOVWF  x54
014F0:  MOVLB  0
014F2:  CALL   0636
....................             Data_Out(0x60);
014F6:  MOVLW  60
014F8:  MOVLB  8
014FA:  MOVWF  x54
014FC:  MOVLB  0
014FE:  CALL   0636
....................             Data_Out(0x60);
01502:  MOVLW  60
01504:  MOVLB  8
01506:  MOVWF  x54
01508:  MOVLB  0
0150A:  CALL   0636
0150E:  MOVLB  5
....................        }
01510:  INCF   x57,F
01512:  BTFSC  3FD8.2
01514:  INCF   x58,F
01516:  BRA    146A
.................... 
....................     }
01518:  MOVLB  0
0151A:  RETURN 0
....................     //fprintf(DEBUG,"\n\r %u, %u", g_BLE_Logo, g_Paired);
.................... }
.................... 
.................... 
.................... 
.................... /**
....................     Draw Battery_Quarter Full
.................... 
.................... **/
.................... void    Draw_Quart_Battery(uint8_t Batt_Id)
.................... {
....................     uint16_t    n;
....................     uint8_t x,y;
....................    
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................     
....................     x=  X_CENTER;
*
00DA4:  MOVLW  40
00DA6:  MOVLB  5
00DA8:  MOVWF  x59
....................     
....................     if(Batt_ID== HEAD)
00DAA:  MOVF   x56,F
00DAC:  BNZ   0DB4
....................         y = Y_CENTER +30;
00DAE:  MOVLW  5A
00DB0:  MOVWF  x5A
00DB2:  BRA    0DB8
....................     else
....................         y = Y_CENTER + 80;    
00DB4:  MOVLW  8C
00DB6:  MOVWF  x5A
....................             
....................       
....................     Set_Column_Address(0,(x-14),0,(x+14)); //X coordinate
00DB8:  MOVLW  0E
00DBA:  SUBWF  x59,W
00DBC:  MOVLB  6
00DBE:  MOVWF  x9A
00DC0:  MOVLW  0E
00DC2:  MOVLB  5
00DC4:  ADDWF  x59,W
00DC6:  MOVLB  6
00DC8:  MOVWF  x9B
00DCA:  MOVLB  8
00DCC:  CLRF   x50
00DCE:  MOVFF  69A,851
00DD2:  CLRF   x52
00DD4:  MOVWF  x53
00DD6:  MOVLB  0
00DD8:  RCALL  0D50
....................     Set_Page_Address(0,(y-5),0,(y+5));    //y coordinate
00DDA:  MOVLW  05
00DDC:  MOVLB  5
00DDE:  SUBWF  x5A,W
00DE0:  MOVLB  6
00DE2:  MOVWF  x9A
00DE4:  MOVLW  05
00DE6:  MOVLB  5
00DE8:  ADDWF  x5A,W
00DEA:  MOVLB  6
00DEC:  MOVWF  x9B
00DEE:  MOVLB  8
00DF0:  CLRF   x50
00DF2:  MOVFF  69A,851
00DF6:  CLRF   x52
00DF8:  MOVWF  x53
00DFA:  MOVLB  0
00DFC:  RCALL  0D74
....................     Write_Memory_Start();
00DFE:  RCALL  0D98
....................     
....................     uint8_t Quart_Batt[319]= {
....................     
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1, 
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0};
00E00:  MOVLW  01
00E02:  MOVLB  5
00E04:  MOVWF  x5B
00E06:  MOVWF  x5C
00E08:  MOVWF  x5D
00E0A:  MOVWF  x5E
00E0C:  MOVWF  x5F
00E0E:  MOVWF  x60
00E10:  MOVWF  x61
00E12:  MOVWF  x62
00E14:  MOVWF  x63
00E16:  MOVWF  x64
00E18:  MOVWF  x65
00E1A:  MOVWF  x66
00E1C:  MOVWF  x67
00E1E:  MOVWF  x68
00E20:  MOVWF  x69
00E22:  MOVWF  x6A
00E24:  MOVWF  x6B
00E26:  MOVWF  x6C
00E28:  MOVWF  x6D
00E2A:  MOVWF  x6E
00E2C:  MOVWF  x6F
00E2E:  MOVWF  x70
00E30:  MOVWF  x71
00E32:  MOVWF  x72
00E34:  MOVWF  x73
00E36:  MOVWF  x74
00E38:  MOVWF  x75
00E3A:  CLRF   x76
00E3C:  CLRF   x77
00E3E:  MOVWF  x78
00E40:  MOVLW  03
00E42:  MOVWF  x79
00E44:  MOVWF  x7A
00E46:  MOVWF  x7B
00E48:  MOVWF  x7C
00E4A:  MOVWF  x7D
00E4C:  MOVWF  x7E
00E4E:  CLRF   x7F
00E50:  CLRF   x80
00E52:  CLRF   x81
00E54:  CLRF   x82
00E56:  CLRF   x83
00E58:  CLRF   x84
00E5A:  CLRF   x85
00E5C:  CLRF   x86
00E5E:  CLRF   x87
00E60:  CLRF   x88
00E62:  CLRF   x89
00E64:  CLRF   x8A
00E66:  CLRF   x8B
00E68:  CLRF   x8C
00E6A:  CLRF   x8D
00E6C:  CLRF   x8E
00E6E:  CLRF   x8F
00E70:  CLRF   x90
00E72:  CLRF   x91
00E74:  MOVLW  01
00E76:  MOVWF  x92
00E78:  CLRF   x93
00E7A:  CLRF   x94
00E7C:  MOVWF  x95
00E7E:  MOVLW  03
00E80:  MOVWF  x96
00E82:  MOVWF  x97
00E84:  MOVWF  x98
00E86:  MOVWF  x99
00E88:  MOVWF  x9A
00E8A:  MOVWF  x9B
00E8C:  CLRF   x9C
00E8E:  CLRF   x9D
00E90:  CLRF   x9E
00E92:  CLRF   x9F
00E94:  CLRF   xA0
00E96:  CLRF   xA1
00E98:  CLRF   xA2
00E9A:  CLRF   xA3
00E9C:  CLRF   xA4
00E9E:  CLRF   xA5
00EA0:  CLRF   xA6
00EA2:  CLRF   xA7
00EA4:  CLRF   xA8
00EA6:  CLRF   xA9
00EA8:  CLRF   xAA
00EAA:  CLRF   xAB
00EAC:  CLRF   xAC
00EAE:  CLRF   xAD
00EB0:  CLRF   xAE
00EB2:  MOVLW  01
00EB4:  MOVWF  xAF
00EB6:  CLRF   xB0
00EB8:  CLRF   xB1
00EBA:  MOVWF  xB2
00EBC:  MOVLW  03
00EBE:  MOVWF  xB3
00EC0:  MOVWF  xB4
00EC2:  MOVWF  xB5
00EC4:  MOVWF  xB6
00EC6:  MOVWF  xB7
00EC8:  MOVWF  xB8
00ECA:  CLRF   xB9
00ECC:  CLRF   xBA
00ECE:  CLRF   xBB
00ED0:  CLRF   xBC
00ED2:  CLRF   xBD
00ED4:  CLRF   xBE
00ED6:  CLRF   xBF
00ED8:  CLRF   xC0
00EDA:  CLRF   xC1
00EDC:  CLRF   xC2
00EDE:  CLRF   xC3
00EE0:  CLRF   xC4
00EE2:  CLRF   xC5
00EE4:  CLRF   xC6
00EE6:  CLRF   xC7
00EE8:  CLRF   xC8
00EEA:  CLRF   xC9
00EEC:  CLRF   xCA
00EEE:  CLRF   xCB
00EF0:  MOVLW  01
00EF2:  MOVWF  xCC
00EF4:  MOVWF  xCD
00EF6:  MOVWF  xCE
00EF8:  MOVWF  xCF
00EFA:  MOVLW  03
00EFC:  MOVWF  xD0
00EFE:  MOVWF  xD1
00F00:  MOVWF  xD2
00F02:  MOVWF  xD3
00F04:  MOVWF  xD4
00F06:  MOVWF  xD5
00F08:  CLRF   xD6
00F0A:  CLRF   xD7
00F0C:  CLRF   xD8
00F0E:  CLRF   xD9
00F10:  CLRF   xDA
00F12:  CLRF   xDB
00F14:  CLRF   xDC
00F16:  CLRF   xDD
00F18:  CLRF   xDE
00F1A:  CLRF   xDF
00F1C:  CLRF   xE0
00F1E:  CLRF   xE1
00F20:  CLRF   xE2
00F22:  CLRF   xE3
00F24:  CLRF   xE4
00F26:  CLRF   xE5
00F28:  CLRF   xE6
00F2A:  CLRF   xE7
00F2C:  CLRF   xE8
00F2E:  MOVLW  01
00F30:  MOVWF  xE9
00F32:  MOVWF  xEA
00F34:  MOVWF  xEB
00F36:  MOVWF  xEC
00F38:  MOVLW  03
00F3A:  MOVWF  xED
00F3C:  MOVWF  xEE
00F3E:  MOVWF  xEF
00F40:  MOVWF  xF0
00F42:  MOVWF  xF1
00F44:  MOVWF  xF2
00F46:  CLRF   xF3
00F48:  CLRF   xF4
00F4A:  CLRF   xF5
00F4C:  CLRF   xF6
00F4E:  CLRF   xF7
00F50:  CLRF   xF8
00F52:  CLRF   xF9
00F54:  CLRF   xFA
00F56:  CLRF   xFB
00F58:  CLRF   xFC
00F5A:  CLRF   xFD
00F5C:  CLRF   xFE
00F5E:  CLRF   xFF
00F60:  MOVLB  6
00F62:  CLRF   x00
00F64:  CLRF   x01
00F66:  CLRF   x02
00F68:  CLRF   x03
00F6A:  CLRF   x04
00F6C:  CLRF   x05
00F6E:  MOVLW  01
00F70:  MOVWF  x06
00F72:  MOVWF  x07
00F74:  MOVWF  x08
00F76:  MOVWF  x09
00F78:  MOVLW  03
00F7A:  MOVWF  x0A
00F7C:  MOVWF  x0B
00F7E:  MOVWF  x0C
00F80:  MOVWF  x0D
00F82:  MOVWF  x0E
00F84:  MOVWF  x0F
00F86:  CLRF   x10
00F88:  CLRF   x11
00F8A:  CLRF   x12
00F8C:  CLRF   x13
00F8E:  CLRF   x14
00F90:  CLRF   x15
00F92:  CLRF   x16
00F94:  CLRF   x17
00F96:  CLRF   x18
00F98:  CLRF   x19
00F9A:  CLRF   x1A
00F9C:  CLRF   x1B
00F9E:  CLRF   x1C
00FA0:  CLRF   x1D
00FA2:  CLRF   x1E
00FA4:  CLRF   x1F
00FA6:  CLRF   x20
00FA8:  CLRF   x21
00FAA:  CLRF   x22
00FAC:  MOVLW  01
00FAE:  MOVWF  x23
00FB0:  MOVWF  x24
00FB2:  MOVWF  x25
00FB4:  MOVWF  x26
00FB6:  MOVLW  03
00FB8:  MOVWF  x27
00FBA:  MOVWF  x28
00FBC:  MOVWF  x29
00FBE:  MOVWF  x2A
00FC0:  MOVWF  x2B
00FC2:  MOVWF  x2C
00FC4:  CLRF   x2D
00FC6:  CLRF   x2E
00FC8:  CLRF   x2F
00FCA:  CLRF   x30
00FCC:  CLRF   x31
00FCE:  CLRF   x32
00FD0:  CLRF   x33
00FD2:  CLRF   x34
00FD4:  CLRF   x35
00FD6:  CLRF   x36
00FD8:  CLRF   x37
00FDA:  CLRF   x38
00FDC:  CLRF   x39
00FDE:  CLRF   x3A
00FE0:  CLRF   x3B
00FE2:  CLRF   x3C
00FE4:  CLRF   x3D
00FE6:  CLRF   x3E
00FE8:  CLRF   x3F
00FEA:  MOVLW  01
00FEC:  MOVWF  x40
00FEE:  MOVWF  x41
00FF0:  MOVWF  x42
00FF2:  MOVWF  x43
00FF4:  MOVLW  03
00FF6:  MOVWF  x44
00FF8:  MOVWF  x45
00FFA:  MOVWF  x46
00FFC:  MOVWF  x47
00FFE:  MOVWF  x48
01000:  MOVWF  x49
01002:  CLRF   x4A
01004:  CLRF   x4B
01006:  CLRF   x4C
01008:  CLRF   x4D
0100A:  CLRF   x4E
0100C:  CLRF   x4F
0100E:  CLRF   x50
01010:  CLRF   x51
01012:  CLRF   x52
01014:  CLRF   x53
01016:  CLRF   x54
01018:  CLRF   x55
0101A:  CLRF   x56
0101C:  CLRF   x57
0101E:  CLRF   x58
01020:  CLRF   x59
01022:  CLRF   x5A
01024:  CLRF   x5B
01026:  CLRF   x5C
01028:  MOVLW  01
0102A:  MOVWF  x5D
0102C:  CLRF   x5E
0102E:  CLRF   x5F
01030:  MOVWF  x60
01032:  MOVLW  03
01034:  MOVWF  x61
01036:  MOVWF  x62
01038:  MOVWF  x63
0103A:  MOVWF  x64
0103C:  MOVWF  x65
0103E:  MOVWF  x66
01040:  CLRF   x67
01042:  CLRF   x68
01044:  CLRF   x69
01046:  CLRF   x6A
01048:  CLRF   x6B
0104A:  CLRF   x6C
0104C:  CLRF   x6D
0104E:  CLRF   x6E
01050:  CLRF   x6F
01052:  CLRF   x70
01054:  CLRF   x71
01056:  CLRF   x72
01058:  CLRF   x73
0105A:  CLRF   x74
0105C:  CLRF   x75
0105E:  CLRF   x76
01060:  CLRF   x77
01062:  CLRF   x78
01064:  CLRF   x79
01066:  MOVLW  01
01068:  MOVWF  x7A
0106A:  CLRF   x7B
0106C:  CLRF   x7C
0106E:  MOVWF  x7D
01070:  MOVWF  x7E
01072:  MOVWF  x7F
01074:  MOVWF  x80
01076:  MOVWF  x81
01078:  MOVWF  x82
0107A:  MOVWF  x83
0107C:  MOVWF  x84
0107E:  MOVWF  x85
01080:  MOVWF  x86
01082:  MOVWF  x87
01084:  MOVWF  x88
01086:  MOVWF  x89
01088:  MOVWF  x8A
0108A:  MOVWF  x8B
0108C:  MOVWF  x8C
0108E:  MOVWF  x8D
01090:  MOVWF  x8E
01092:  MOVWF  x8F
01094:  MOVWF  x90
01096:  MOVWF  x91
01098:  MOVWF  x92
0109A:  MOVWF  x93
0109C:  MOVWF  x94
0109E:  MOVWF  x95
010A0:  MOVWF  x96
010A2:  MOVWF  x97
010A4:  CLRF   x98
010A6:  CLRF   x99
....................       
....................     for(n=0; n<=319; n++) //draw a block 31 across by 11 down
010A8:  MOVLB  5
010AA:  CLRF   x58
010AC:  CLRF   x57
010AE:  MOVF   x58,W
010B0:  SUBLW  01
010B2:  BNC   115C
010B4:  BNZ   10BC
010B6:  MOVF   x57,W
010B8:  SUBLW  3F
010BA:  BNC   115C
....................     {
....................        if(Quart_Batt[n] == 1)  //white
010BC:  MOVLW  5B
010BE:  ADDWF  x57,W
010C0:  MOVWF  3FE9
010C2:  MOVLW  05
010C4:  ADDWFC x58,W
010C6:  MOVWF  3FEA
010C8:  DECFSZ 3FEF,W
010CA:  BRA    10EC
....................        {
....................             Data_Out(0xFF);
010CC:  MOVLB  8
010CE:  SETF   x54
010D0:  MOVLB  0
010D2:  CALL   0636
....................             Data_Out(0xFF);
010D6:  MOVLB  8
010D8:  SETF   x54
010DA:  MOVLB  0
010DC:  CALL   0636
....................             Data_Out(0xFF);
010E0:  MOVLB  8
010E2:  SETF   x54
010E4:  MOVLB  0
010E6:  CALL   0636
010EA:  MOVLB  5
....................        } 
....................        
....................        if(Quart_Batt[n] == 0)  //black
010EC:  MOVLW  5B
010EE:  ADDWF  x57,W
010F0:  MOVWF  3FE9
010F2:  MOVLW  05
010F4:  ADDWFC x58,W
010F6:  MOVWF  3FEA
010F8:  MOVF   3FEF,F
010FA:  BNZ   111C
....................        {
....................             Data_Out(0x00);
010FC:  MOVLB  8
010FE:  CLRF   x54
01100:  MOVLB  0
01102:  CALL   0636
....................             Data_Out(0x00);
01106:  MOVLB  8
01108:  CLRF   x54
0110A:  MOVLB  0
0110C:  CALL   0636
....................             Data_Out(0x00);
01110:  MOVLB  8
01112:  CLRF   x54
01114:  MOVLB  0
01116:  CALL   0636
0111A:  MOVLB  5
....................        }
....................  
....................        if(Quart_Batt[n] == 3)  //grey
0111C:  MOVLW  5B
0111E:  ADDWF  x57,W
01120:  MOVWF  3FE9
01122:  MOVLW  05
01124:  ADDWFC x58,W
01126:  MOVWF  3FEA
01128:  MOVF   3FEF,W
0112A:  SUBLW  03
0112C:  BNZ   1154
....................        {
....................             Data_Out(0x60);
0112E:  MOVLW  60
01130:  MOVLB  8
01132:  MOVWF  x54
01134:  MOVLB  0
01136:  CALL   0636
....................             Data_Out(0x60);
0113A:  MOVLW  60
0113C:  MOVLB  8
0113E:  MOVWF  x54
01140:  MOVLB  0
01142:  CALL   0636
....................             Data_Out(0x60);
01146:  MOVLW  60
01148:  MOVLB  8
0114A:  MOVWF  x54
0114C:  MOVLB  0
0114E:  CALL   0636
01152:  MOVLB  5
....................        }
01154:  INCF   x57,F
01156:  BTFSC  3FD8.2
01158:  INCF   x58,F
0115A:  BRA    10AE
.................... 
....................     }
0115C:  MOVLB  0
0115E:  RETURN 0
....................     //fprintf(DEBUG,"\n\r %u, %u", g_BLE_Logo, g_Paired);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... /**
....................     Draw Battery_Empty
.................... **/
.................... void    Draw_Empty_Battery(uint8_t Batt_ID)
.................... {
....................     uint16_t    n;
....................     uint8_t x,y;
....................    
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................     
....................     x=  X_CENTER ;
*
029FA:  MOVLW  40
029FC:  MOVLB  5
029FE:  MOVWF  x59
....................    
....................     if(Batt_ID== HEAD)
02A00:  MOVF   x56,F
02A02:  BNZ   2A0A
....................         y = Y_CENTER +30;
02A04:  MOVLW  5A
02A06:  MOVWF  x5A
02A08:  BRA    2A0E
....................     else
....................         y = Y_CENTER + 80;    
02A0A:  MOVLW  8C
02A0C:  MOVWF  x5A
....................             
....................       
....................     Set_Column_Address(0,(x-14),0,(x+14)); //X coordinate
02A0E:  MOVLW  0E
02A10:  SUBWF  x59,W
02A12:  MOVLB  6
02A14:  MOVWF  x9A
02A16:  MOVLW  0E
02A18:  MOVLB  5
02A1A:  ADDWF  x59,W
02A1C:  MOVLB  6
02A1E:  MOVWF  x9B
02A20:  MOVLB  8
02A22:  CLRF   x50
02A24:  MOVFF  69A,851
02A28:  CLRF   x52
02A2A:  MOVWF  x53
02A2C:  MOVLB  0
02A2E:  CALL   0D50
....................     Set_Page_Address(0,(y-5),0,(y+5));    //y coordinate
02A32:  MOVLW  05
02A34:  MOVLB  5
02A36:  SUBWF  x5A,W
02A38:  MOVLB  6
02A3A:  MOVWF  x9A
02A3C:  MOVLW  05
02A3E:  MOVLB  5
02A40:  ADDWF  x5A,W
02A42:  MOVLB  6
02A44:  MOVWF  x9B
02A46:  MOVLB  8
02A48:  CLRF   x50
02A4A:  MOVFF  69A,851
02A4E:  CLRF   x52
02A50:  MOVWF  x53
02A52:  MOVLB  0
02A54:  CALL   0D74
....................     Write_Memory_Start();
02A58:  CALL   0D98
....................     
....................     uint8_t Empty_Batt[319]= {
....................     
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1, 
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0};
02A5C:  MOVLW  01
02A5E:  MOVLB  5
02A60:  MOVWF  x5B
02A62:  MOVWF  x5C
02A64:  MOVWF  x5D
02A66:  MOVWF  x5E
02A68:  MOVWF  x5F
02A6A:  MOVWF  x60
02A6C:  MOVWF  x61
02A6E:  MOVWF  x62
02A70:  MOVWF  x63
02A72:  MOVWF  x64
02A74:  MOVWF  x65
02A76:  MOVWF  x66
02A78:  MOVWF  x67
02A7A:  MOVWF  x68
02A7C:  MOVWF  x69
02A7E:  MOVWF  x6A
02A80:  MOVWF  x6B
02A82:  MOVWF  x6C
02A84:  MOVWF  x6D
02A86:  MOVWF  x6E
02A88:  MOVWF  x6F
02A8A:  MOVWF  x70
02A8C:  MOVWF  x71
02A8E:  MOVWF  x72
02A90:  MOVWF  x73
02A92:  MOVWF  x74
02A94:  MOVWF  x75
02A96:  CLRF   x76
02A98:  CLRF   x77
02A9A:  MOVWF  x78
02A9C:  MOVLW  03
02A9E:  MOVWF  x79
02AA0:  MOVWF  x7A
02AA2:  MOVWF  x7B
02AA4:  MOVWF  x7C
02AA6:  MOVWF  x7D
02AA8:  MOVWF  x7E
02AAA:  CLRF   x7F
02AAC:  CLRF   x80
02AAE:  CLRF   x81
02AB0:  CLRF   x82
02AB2:  CLRF   x83
02AB4:  CLRF   x84
02AB6:  CLRF   x85
02AB8:  CLRF   x86
02ABA:  CLRF   x87
02ABC:  CLRF   x88
02ABE:  CLRF   x89
02AC0:  CLRF   x8A
02AC2:  CLRF   x8B
02AC4:  CLRF   x8C
02AC6:  CLRF   x8D
02AC8:  CLRF   x8E
02ACA:  CLRF   x8F
02ACC:  CLRF   x90
02ACE:  CLRF   x91
02AD0:  MOVLW  01
02AD2:  MOVWF  x92
02AD4:  CLRF   x93
02AD6:  CLRF   x94
02AD8:  MOVWF  x95
02ADA:  MOVLW  03
02ADC:  MOVWF  x96
02ADE:  MOVWF  x97
02AE0:  MOVWF  x98
02AE2:  MOVWF  x99
02AE4:  MOVWF  x9A
02AE6:  MOVWF  x9B
02AE8:  CLRF   x9C
02AEA:  CLRF   x9D
02AEC:  CLRF   x9E
02AEE:  CLRF   x9F
02AF0:  CLRF   xA0
02AF2:  CLRF   xA1
02AF4:  CLRF   xA2
02AF6:  CLRF   xA3
02AF8:  CLRF   xA4
02AFA:  CLRF   xA5
02AFC:  CLRF   xA6
02AFE:  CLRF   xA7
02B00:  CLRF   xA8
02B02:  CLRF   xA9
02B04:  CLRF   xAA
02B06:  CLRF   xAB
02B08:  CLRF   xAC
02B0A:  CLRF   xAD
02B0C:  CLRF   xAE
02B0E:  MOVLW  01
02B10:  MOVWF  xAF
02B12:  CLRF   xB0
02B14:  CLRF   xB1
02B16:  MOVWF  xB2
02B18:  MOVLW  03
02B1A:  MOVWF  xB3
02B1C:  MOVWF  xB4
02B1E:  MOVWF  xB5
02B20:  MOVWF  xB6
02B22:  MOVWF  xB7
02B24:  MOVWF  xB8
02B26:  CLRF   xB9
02B28:  CLRF   xBA
02B2A:  CLRF   xBB
02B2C:  CLRF   xBC
02B2E:  CLRF   xBD
02B30:  CLRF   xBE
02B32:  CLRF   xBF
02B34:  CLRF   xC0
02B36:  CLRF   xC1
02B38:  CLRF   xC2
02B3A:  CLRF   xC3
02B3C:  CLRF   xC4
02B3E:  CLRF   xC5
02B40:  CLRF   xC6
02B42:  CLRF   xC7
02B44:  CLRF   xC8
02B46:  CLRF   xC9
02B48:  CLRF   xCA
02B4A:  CLRF   xCB
02B4C:  MOVLW  01
02B4E:  MOVWF  xCC
02B50:  MOVWF  xCD
02B52:  MOVWF  xCE
02B54:  MOVWF  xCF
02B56:  MOVLW  03
02B58:  MOVWF  xD0
02B5A:  MOVWF  xD1
02B5C:  MOVWF  xD2
02B5E:  MOVWF  xD3
02B60:  MOVWF  xD4
02B62:  MOVWF  xD5
02B64:  CLRF   xD6
02B66:  CLRF   xD7
02B68:  CLRF   xD8
02B6A:  CLRF   xD9
02B6C:  CLRF   xDA
02B6E:  CLRF   xDB
02B70:  CLRF   xDC
02B72:  CLRF   xDD
02B74:  CLRF   xDE
02B76:  CLRF   xDF
02B78:  CLRF   xE0
02B7A:  CLRF   xE1
02B7C:  CLRF   xE2
02B7E:  CLRF   xE3
02B80:  CLRF   xE4
02B82:  CLRF   xE5
02B84:  CLRF   xE6
02B86:  CLRF   xE7
02B88:  CLRF   xE8
02B8A:  MOVLW  01
02B8C:  MOVWF  xE9
02B8E:  MOVWF  xEA
02B90:  MOVWF  xEB
02B92:  MOVWF  xEC
02B94:  MOVLW  03
02B96:  MOVWF  xED
02B98:  MOVWF  xEE
02B9A:  MOVWF  xEF
02B9C:  MOVWF  xF0
02B9E:  MOVWF  xF1
02BA0:  MOVWF  xF2
02BA2:  CLRF   xF3
02BA4:  CLRF   xF4
02BA6:  CLRF   xF5
02BA8:  CLRF   xF6
02BAA:  CLRF   xF7
02BAC:  CLRF   xF8
02BAE:  CLRF   xF9
02BB0:  CLRF   xFA
02BB2:  CLRF   xFB
02BB4:  CLRF   xFC
02BB6:  CLRF   xFD
02BB8:  CLRF   xFE
02BBA:  CLRF   xFF
02BBC:  MOVLB  6
02BBE:  CLRF   x00
02BC0:  CLRF   x01
02BC2:  CLRF   x02
02BC4:  CLRF   x03
02BC6:  CLRF   x04
02BC8:  CLRF   x05
02BCA:  MOVLW  01
02BCC:  MOVWF  x06
02BCE:  MOVWF  x07
02BD0:  MOVWF  x08
02BD2:  MOVWF  x09
02BD4:  MOVLW  03
02BD6:  MOVWF  x0A
02BD8:  MOVWF  x0B
02BDA:  MOVWF  x0C
02BDC:  MOVWF  x0D
02BDE:  MOVWF  x0E
02BE0:  MOVWF  x0F
02BE2:  CLRF   x10
02BE4:  CLRF   x11
02BE6:  CLRF   x12
02BE8:  CLRF   x13
02BEA:  CLRF   x14
02BEC:  CLRF   x15
02BEE:  CLRF   x16
02BF0:  CLRF   x17
02BF2:  CLRF   x18
02BF4:  CLRF   x19
02BF6:  CLRF   x1A
02BF8:  CLRF   x1B
02BFA:  CLRF   x1C
02BFC:  CLRF   x1D
02BFE:  CLRF   x1E
02C00:  CLRF   x1F
02C02:  CLRF   x20
02C04:  CLRF   x21
02C06:  CLRF   x22
02C08:  MOVLW  01
02C0A:  MOVWF  x23
02C0C:  MOVWF  x24
02C0E:  MOVWF  x25
02C10:  MOVWF  x26
02C12:  MOVLW  03
02C14:  MOVWF  x27
02C16:  MOVWF  x28
02C18:  MOVWF  x29
02C1A:  MOVWF  x2A
02C1C:  MOVWF  x2B
02C1E:  MOVWF  x2C
02C20:  CLRF   x2D
02C22:  CLRF   x2E
02C24:  CLRF   x2F
02C26:  CLRF   x30
02C28:  CLRF   x31
02C2A:  CLRF   x32
02C2C:  CLRF   x33
02C2E:  CLRF   x34
02C30:  CLRF   x35
02C32:  CLRF   x36
02C34:  CLRF   x37
02C36:  CLRF   x38
02C38:  CLRF   x39
02C3A:  CLRF   x3A
02C3C:  CLRF   x3B
02C3E:  CLRF   x3C
02C40:  CLRF   x3D
02C42:  CLRF   x3E
02C44:  CLRF   x3F
02C46:  MOVLW  01
02C48:  MOVWF  x40
02C4A:  MOVWF  x41
02C4C:  MOVWF  x42
02C4E:  MOVWF  x43
02C50:  MOVLW  03
02C52:  MOVWF  x44
02C54:  MOVWF  x45
02C56:  MOVWF  x46
02C58:  MOVWF  x47
02C5A:  MOVWF  x48
02C5C:  MOVWF  x49
02C5E:  CLRF   x4A
02C60:  CLRF   x4B
02C62:  CLRF   x4C
02C64:  CLRF   x4D
02C66:  CLRF   x4E
02C68:  CLRF   x4F
02C6A:  CLRF   x50
02C6C:  CLRF   x51
02C6E:  CLRF   x52
02C70:  CLRF   x53
02C72:  CLRF   x54
02C74:  CLRF   x55
02C76:  CLRF   x56
02C78:  CLRF   x57
02C7A:  CLRF   x58
02C7C:  CLRF   x59
02C7E:  CLRF   x5A
02C80:  CLRF   x5B
02C82:  CLRF   x5C
02C84:  MOVLW  01
02C86:  MOVWF  x5D
02C88:  CLRF   x5E
02C8A:  CLRF   x5F
02C8C:  MOVWF  x60
02C8E:  MOVLW  03
02C90:  MOVWF  x61
02C92:  MOVWF  x62
02C94:  MOVWF  x63
02C96:  MOVWF  x64
02C98:  MOVWF  x65
02C9A:  MOVWF  x66
02C9C:  CLRF   x67
02C9E:  CLRF   x68
02CA0:  CLRF   x69
02CA2:  CLRF   x6A
02CA4:  CLRF   x6B
02CA6:  CLRF   x6C
02CA8:  CLRF   x6D
02CAA:  CLRF   x6E
02CAC:  CLRF   x6F
02CAE:  CLRF   x70
02CB0:  CLRF   x71
02CB2:  CLRF   x72
02CB4:  CLRF   x73
02CB6:  CLRF   x74
02CB8:  CLRF   x75
02CBA:  CLRF   x76
02CBC:  CLRF   x77
02CBE:  CLRF   x78
02CC0:  CLRF   x79
02CC2:  MOVLW  01
02CC4:  MOVWF  x7A
02CC6:  CLRF   x7B
02CC8:  CLRF   x7C
02CCA:  MOVWF  x7D
02CCC:  MOVWF  x7E
02CCE:  MOVWF  x7F
02CD0:  MOVWF  x80
02CD2:  MOVWF  x81
02CD4:  MOVWF  x82
02CD6:  MOVWF  x83
02CD8:  MOVWF  x84
02CDA:  MOVWF  x85
02CDC:  MOVWF  x86
02CDE:  MOVWF  x87
02CE0:  MOVWF  x88
02CE2:  MOVWF  x89
02CE4:  MOVWF  x8A
02CE6:  MOVWF  x8B
02CE8:  MOVWF  x8C
02CEA:  MOVWF  x8D
02CEC:  MOVWF  x8E
02CEE:  MOVWF  x8F
02CF0:  MOVWF  x90
02CF2:  MOVWF  x91
02CF4:  MOVWF  x92
02CF6:  MOVWF  x93
02CF8:  MOVWF  x94
02CFA:  MOVWF  x95
02CFC:  MOVWF  x96
02CFE:  MOVWF  x97
02D00:  CLRF   x98
02D02:  CLRF   x99
....................       
....................     for(n=0; n<=319; n++) //draw a block 31 across by 11 down
02D04:  MOVLB  5
02D06:  CLRF   x58
02D08:  CLRF   x57
02D0A:  MOVF   x58,W
02D0C:  SUBLW  01
02D0E:  BNC   2DB2
02D10:  BNZ   2D18
02D12:  MOVF   x57,W
02D14:  SUBLW  3F
02D16:  BNC   2DB2
....................     {
....................        if(Empty_Batt[n] == 1)  //white
02D18:  MOVLW  5B
02D1A:  ADDWF  x57,W
02D1C:  MOVWF  3FE9
02D1E:  MOVLW  05
02D20:  ADDWFC x58,W
02D22:  MOVWF  3FEA
02D24:  DECFSZ 3FEF,W
02D26:  BRA    2D48
....................        {
....................             Data_Out(0xFF);
02D28:  MOVLB  8
02D2A:  SETF   x54
02D2C:  MOVLB  0
02D2E:  CALL   0636
....................             Data_Out(0xFF);
02D32:  MOVLB  8
02D34:  SETF   x54
02D36:  MOVLB  0
02D38:  CALL   0636
....................             Data_Out(0xFF);
02D3C:  MOVLB  8
02D3E:  SETF   x54
02D40:  MOVLB  0
02D42:  CALL   0636
02D46:  MOVLB  5
....................        } 
....................        
....................        if(Empty_Batt[n] == 0)  //black
02D48:  MOVLW  5B
02D4A:  ADDWF  x57,W
02D4C:  MOVWF  3FE9
02D4E:  MOVLW  05
02D50:  ADDWFC x58,W
02D52:  MOVWF  3FEA
02D54:  MOVF   3FEF,F
02D56:  BNZ   2D78
....................        {
....................             Data_Out(0x00);
02D58:  MOVLB  8
02D5A:  CLRF   x54
02D5C:  MOVLB  0
02D5E:  CALL   0636
....................             Data_Out(0x00);
02D62:  MOVLB  8
02D64:  CLRF   x54
02D66:  MOVLB  0
02D68:  CALL   0636
....................             Data_Out(0x00);
02D6C:  MOVLB  8
02D6E:  CLRF   x54
02D70:  MOVLB  0
02D72:  CALL   0636
02D76:  MOVLB  5
....................        }
....................  
....................        if(Empty_Batt[n] == 3)  //red
02D78:  MOVLW  5B
02D7A:  ADDWF  x57,W
02D7C:  MOVWF  3FE9
02D7E:  MOVLW  05
02D80:  ADDWFC x58,W
02D82:  MOVWF  3FEA
02D84:  MOVF   3FEF,W
02D86:  SUBLW  03
02D88:  BNZ   2DAA
....................        {
....................             Data_Out(0xFF);
02D8A:  MOVLB  8
02D8C:  SETF   x54
02D8E:  MOVLB  0
02D90:  CALL   0636
....................             Data_Out(0x00);
02D94:  MOVLB  8
02D96:  CLRF   x54
02D98:  MOVLB  0
02D9A:  CALL   0636
....................             Data_Out(0x00);
02D9E:  MOVLB  8
02DA0:  CLRF   x54
02DA2:  MOVLB  0
02DA4:  CALL   0636
02DA8:  MOVLB  5
....................        }
02DAA:  INCF   x57,F
02DAC:  BTFSC  3FD8.2
02DAE:  INCF   x58,F
02DB0:  BRA    2D0A
.................... 
....................     }
02DB2:  MOVLB  0
02DB4:  RETURN 0
....................     //fprintf(DEBUG,"\n\r %u, %u", g_BLE_Logo, g_Paired);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... /**
....................     Draw Alert(void)
.................... **/
.................... void    Draw_Alert(int8_t Display)
.................... {
....................     uint16_t    n;
....................     uint8_t x,y;
....................    
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................     
....................     x=  X_CENTER + 40;
*
02ED2:  MOVLW  68
02ED4:  MOVLB  5
02ED6:  MOVWF  x59
....................     y = Y_CENTER + 80;    
02ED8:  MOVLW  8C
02EDA:  MOVWF  x5A
....................             
....................       
....................     Set_Column_Address(0,(x-12),0,(x+12)); //X coordinate
02EDC:  MOVLW  0C
02EDE:  SUBWF  x59,W
02EE0:  MOVLB  7
02EE2:  MOVWF  xCC
02EE4:  MOVLW  0C
02EE6:  MOVLB  5
02EE8:  ADDWF  x59,W
02EEA:  MOVLB  7
02EEC:  MOVWF  xCD
02EEE:  MOVLB  8
02EF0:  CLRF   x50
02EF2:  MOVFF  7CC,851
02EF6:  CLRF   x52
02EF8:  MOVWF  x53
02EFA:  MOVLB  0
02EFC:  CALL   0D50
....................     Set_Page_Address(0,(y-12),0,(y+12));    //y coordinate
02F00:  MOVLW  0C
02F02:  MOVLB  5
02F04:  SUBWF  x5A,W
02F06:  MOVLB  7
02F08:  MOVWF  xCC
02F0A:  MOVLW  0C
02F0C:  MOVLB  5
02F0E:  ADDWF  x5A,W
02F10:  MOVLB  7
02F12:  MOVWF  xCD
02F14:  MOVLB  8
02F16:  CLRF   x50
02F18:  MOVFF  7CC,851
02F1C:  CLRF   x52
02F1E:  MOVWF  x53
02F20:  MOVLB  0
02F22:  CALL   0D74
....................     Write_Memory_Start();
02F26:  CALL   0D98
....................     
....................     uint8_t Alert[625]= {
....................     
....................     0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,
....................     0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,
....................     0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,
....................     0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,   
....................     0,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,
....................     0,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,
....................     0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,   
....................     0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,
....................     0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,
....................     0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,
....................     0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,   
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};       
02F2A:  MOVLB  5
02F2C:  CLRF   x5B
02F2E:  CLRF   x5C
02F30:  CLRF   x5D
02F32:  CLRF   x5E
02F34:  CLRF   x5F
02F36:  CLRF   x60
02F38:  CLRF   x61
02F3A:  CLRF   x62
02F3C:  CLRF   x63
02F3E:  CLRF   x64
02F40:  CLRF   x65
02F42:  CLRF   x66
02F44:  MOVLW  01
02F46:  MOVWF  x67
02F48:  CLRF   x68
02F4A:  CLRF   x69
02F4C:  CLRF   x6A
02F4E:  CLRF   x6B
02F50:  CLRF   x6C
02F52:  CLRF   x6D
02F54:  CLRF   x6E
02F56:  CLRF   x6F
02F58:  CLRF   x70
02F5A:  CLRF   x71
02F5C:  CLRF   x72
02F5E:  CLRF   x73
02F60:  CLRF   x74
02F62:  CLRF   x75
02F64:  CLRF   x76
02F66:  CLRF   x77
02F68:  CLRF   x78
02F6A:  CLRF   x79
02F6C:  CLRF   x7A
02F6E:  CLRF   x7B
02F70:  CLRF   x7C
02F72:  CLRF   x7D
02F74:  CLRF   x7E
02F76:  CLRF   x7F
02F78:  MOVWF  x80
02F7A:  CLRF   x81
02F7C:  CLRF   x82
02F7E:  CLRF   x83
02F80:  CLRF   x84
02F82:  CLRF   x85
02F84:  CLRF   x86
02F86:  CLRF   x87
02F88:  CLRF   x88
02F8A:  CLRF   x89
02F8C:  CLRF   x8A
02F8E:  CLRF   x8B
02F90:  CLRF   x8C
02F92:  CLRF   x8D
02F94:  CLRF   x8E
02F96:  CLRF   x8F
02F98:  CLRF   x90
02F9A:  CLRF   x91
02F9C:  CLRF   x92
02F9E:  CLRF   x93
02FA0:  CLRF   x94
02FA2:  CLRF   x95
02FA4:  CLRF   x96
02FA6:  CLRF   x97
02FA8:  MOVWF  x98
02FAA:  MOVWF  x99
02FAC:  MOVWF  x9A
02FAE:  CLRF   x9B
02FB0:  CLRF   x9C
02FB2:  CLRF   x9D
02FB4:  CLRF   x9E
02FB6:  CLRF   x9F
02FB8:  CLRF   xA0
02FBA:  CLRF   xA1
02FBC:  CLRF   xA2
02FBE:  CLRF   xA3
02FC0:  CLRF   xA4
02FC2:  CLRF   xA5
02FC4:  CLRF   xA6
02FC6:  CLRF   xA7
02FC8:  CLRF   xA8
02FCA:  CLRF   xA9
02FCC:  CLRF   xAA
02FCE:  CLRF   xAB
02FD0:  CLRF   xAC
02FD2:  CLRF   xAD
02FD4:  CLRF   xAE
02FD6:  CLRF   xAF
02FD8:  CLRF   xB0
02FDA:  MOVWF  xB1
02FDC:  MOVWF  xB2
02FDE:  MOVWF  xB3
02FE0:  CLRF   xB4
02FE2:  CLRF   xB5
02FE4:  CLRF   xB6
02FE6:  CLRF   xB7
02FE8:  CLRF   xB8
02FEA:  CLRF   xB9
02FEC:  CLRF   xBA
02FEE:  CLRF   xBB
02FF0:  CLRF   xBC
02FF2:  CLRF   xBD
02FF4:  CLRF   xBE
02FF6:  CLRF   xBF
02FF8:  CLRF   xC0
02FFA:  CLRF   xC1
02FFC:  CLRF   xC2
02FFE:  CLRF   xC3
03000:  CLRF   xC4
03002:  CLRF   xC5
03004:  CLRF   xC6
03006:  CLRF   xC7
03008:  CLRF   xC8
0300A:  MOVWF  xC9
0300C:  MOVWF  xCA
0300E:  MOVWF  xCB
03010:  MOVWF  xCC
03012:  MOVWF  xCD
03014:  CLRF   xCE
03016:  CLRF   xCF
03018:  CLRF   xD0
0301A:  CLRF   xD1
0301C:  CLRF   xD2
0301E:  CLRF   xD3
03020:  CLRF   xD4
03022:  CLRF   xD5
03024:  CLRF   xD6
03026:  CLRF   xD7
03028:  CLRF   xD8
0302A:  CLRF   xD9
0302C:  CLRF   xDA
0302E:  CLRF   xDB
03030:  CLRF   xDC
03032:  CLRF   xDD
03034:  CLRF   xDE
03036:  CLRF   xDF
03038:  CLRF   xE0
0303A:  CLRF   xE1
0303C:  MOVWF  xE2
0303E:  MOVWF  xE3
03040:  MOVWF  xE4
03042:  MOVWF  xE5
03044:  MOVWF  xE6
03046:  CLRF   xE7
03048:  CLRF   xE8
0304A:  CLRF   xE9
0304C:  CLRF   xEA
0304E:  CLRF   xEB
03050:  CLRF   xEC
03052:  CLRF   xED
03054:  CLRF   xEE
03056:  CLRF   xEF
03058:  CLRF   xF0
0305A:  CLRF   xF1
0305C:  CLRF   xF2
0305E:  CLRF   xF3
03060:  CLRF   xF4
03062:  CLRF   xF5
03064:  CLRF   xF6
03066:  CLRF   xF7
03068:  CLRF   xF8
0306A:  CLRF   xF9
0306C:  MOVWF  xFA
0306E:  MOVWF  xFB
03070:  MOVWF  xFC
03072:  MOVWF  xFD
03074:  MOVWF  xFE
03076:  MOVWF  xFF
03078:  MOVLB  6
0307A:  MOVWF  x00
0307C:  CLRF   x01
0307E:  CLRF   x02
03080:  CLRF   x03
03082:  CLRF   x04
03084:  CLRF   x05
03086:  CLRF   x06
03088:  CLRF   x07
0308A:  CLRF   x08
0308C:  CLRF   x09
0308E:  CLRF   x0A
03090:  CLRF   x0B
03092:  CLRF   x0C
03094:  CLRF   x0D
03096:  CLRF   x0E
03098:  CLRF   x0F
0309A:  CLRF   x10
0309C:  CLRF   x11
0309E:  CLRF   x12
030A0:  MOVWF  x13
030A2:  MOVWF  x14
030A4:  MOVWF  x15
030A6:  MOVWF  x16
030A8:  MOVWF  x17
030AA:  MOVWF  x18
030AC:  MOVWF  x19
030AE:  CLRF   x1A
030B0:  CLRF   x1B
030B2:  CLRF   x1C
030B4:  CLRF   x1D
030B6:  CLRF   x1E
030B8:  CLRF   x1F
030BA:  CLRF   x20
030BC:  CLRF   x21
030BE:  CLRF   x22
030C0:  CLRF   x23
030C2:  CLRF   x24
030C4:  CLRF   x25
030C6:  CLRF   x26
030C8:  CLRF   x27
030CA:  CLRF   x28
030CC:  CLRF   x29
030CE:  CLRF   x2A
030D0:  MOVWF  x2B
030D2:  MOVWF  x2C
030D4:  MOVWF  x2D
030D6:  CLRF   x2E
030D8:  CLRF   x2F
030DA:  CLRF   x30
030DC:  MOVWF  x31
030DE:  MOVWF  x32
030E0:  MOVWF  x33
030E2:  CLRF   x34
030E4:  CLRF   x35
030E6:  CLRF   x36
030E8:  CLRF   x37
030EA:  CLRF   x38
030EC:  CLRF   x39
030EE:  CLRF   x3A
030F0:  CLRF   x3B
030F2:  CLRF   x3C
030F4:  CLRF   x3D
030F6:  CLRF   x3E
030F8:  CLRF   x3F
030FA:  CLRF   x40
030FC:  CLRF   x41
030FE:  CLRF   x42
03100:  CLRF   x43
03102:  MOVWF  x44
03104:  MOVWF  x45
03106:  MOVWF  x46
03108:  CLRF   x47
0310A:  CLRF   x48
0310C:  CLRF   x49
0310E:  MOVWF  x4A
03110:  MOVWF  x4B
03112:  MOVWF  x4C
03114:  CLRF   x4D
03116:  CLRF   x4E
03118:  CLRF   x4F
0311A:  CLRF   x50
0311C:  CLRF   x51
0311E:  CLRF   x52
03120:  CLRF   x53
03122:  CLRF   x54
03124:  CLRF   x55
03126:  CLRF   x56
03128:  CLRF   x57
0312A:  CLRF   x58
0312C:  CLRF   x59
0312E:  CLRF   x5A
03130:  CLRF   x5B
03132:  MOVWF  x5C
03134:  MOVWF  x5D
03136:  MOVWF  x5E
03138:  MOVWF  x5F
0313A:  CLRF   x60
0313C:  CLRF   x61
0313E:  CLRF   x62
03140:  MOVWF  x63
03142:  MOVWF  x64
03144:  MOVWF  x65
03146:  MOVWF  x66
03148:  CLRF   x67
0314A:  CLRF   x68
0314C:  CLRF   x69
0314E:  CLRF   x6A
03150:  CLRF   x6B
03152:  CLRF   x6C
03154:  CLRF   x6D
03156:  CLRF   x6E
03158:  CLRF   x6F
0315A:  CLRF   x70
0315C:  CLRF   x71
0315E:  CLRF   x72
03160:  CLRF   x73
03162:  CLRF   x74
03164:  MOVWF  x75
03166:  MOVWF  x76
03168:  MOVWF  x77
0316A:  MOVWF  x78
0316C:  CLRF   x79
0316E:  CLRF   x7A
03170:  CLRF   x7B
03172:  MOVWF  x7C
03174:  MOVWF  x7D
03176:  MOVWF  x7E
03178:  MOVWF  x7F
0317A:  CLRF   x80
0317C:  CLRF   x81
0317E:  CLRF   x82
03180:  CLRF   x83
03182:  CLRF   x84
03184:  CLRF   x85
03186:  CLRF   x86
03188:  CLRF   x87
0318A:  CLRF   x88
0318C:  CLRF   x89
0318E:  CLRF   x8A
03190:  CLRF   x8B
03192:  CLRF   x8C
03194:  MOVWF  x8D
03196:  MOVWF  x8E
03198:  MOVWF  x8F
0319A:  MOVWF  x90
0319C:  MOVWF  x91
0319E:  CLRF   x92
031A0:  CLRF   x93
031A2:  CLRF   x94
031A4:  MOVWF  x95
031A6:  MOVWF  x96
031A8:  MOVWF  x97
031AA:  MOVWF  x98
031AC:  MOVWF  x99
031AE:  CLRF   x9A
031B0:  CLRF   x9B
031B2:  CLRF   x9C
031B4:  CLRF   x9D
031B6:  CLRF   x9E
031B8:  CLRF   x9F
031BA:  CLRF   xA0
031BC:  CLRF   xA1
031BE:  CLRF   xA2
031C0:  CLRF   xA3
031C2:  CLRF   xA4
031C4:  CLRF   xA5
031C6:  MOVWF  xA6
031C8:  MOVWF  xA7
031CA:  MOVWF  xA8
031CC:  MOVWF  xA9
031CE:  MOVWF  xAA
031D0:  CLRF   xAB
031D2:  CLRF   xAC
031D4:  CLRF   xAD
031D6:  MOVWF  xAE
031D8:  MOVWF  xAF
031DA:  MOVWF  xB0
031DC:  MOVWF  xB1
031DE:  MOVWF  xB2
031E0:  CLRF   xB3
031E2:  CLRF   xB4
031E4:  CLRF   xB5
031E6:  CLRF   xB6
031E8:  CLRF   xB7
031EA:  CLRF   xB8
031EC:  CLRF   xB9
031EE:  CLRF   xBA
031F0:  CLRF   xBB
031F2:  CLRF   xBC
031F4:  CLRF   xBD
031F6:  MOVWF  xBE
031F8:  MOVWF  xBF
031FA:  MOVWF  xC0
031FC:  MOVWF  xC1
031FE:  MOVWF  xC2
03200:  MOVWF  xC3
03202:  CLRF   xC4
03204:  CLRF   xC5
03206:  CLRF   xC6
03208:  MOVWF  xC7
0320A:  MOVWF  xC8
0320C:  MOVWF  xC9
0320E:  MOVWF  xCA
03210:  MOVWF  xCB
03212:  MOVWF  xCC
03214:  CLRF   xCD
03216:  CLRF   xCE
03218:  CLRF   xCF
0321A:  CLRF   xD0
0321C:  CLRF   xD1
0321E:  CLRF   xD2
03220:  CLRF   xD3
03222:  CLRF   xD4
03224:  CLRF   xD5
03226:  CLRF   xD6
03228:  MOVWF  xD7
0322A:  MOVWF  xD8
0322C:  MOVWF  xD9
0322E:  MOVWF  xDA
03230:  MOVWF  xDB
03232:  MOVWF  xDC
03234:  CLRF   xDD
03236:  CLRF   xDE
03238:  CLRF   xDF
0323A:  MOVWF  xE0
0323C:  MOVWF  xE1
0323E:  MOVWF  xE2
03240:  MOVWF  xE3
03242:  MOVWF  xE4
03244:  MOVWF  xE5
03246:  CLRF   xE6
03248:  CLRF   xE7
0324A:  CLRF   xE8
0324C:  CLRF   xE9
0324E:  CLRF   xEA
03250:  CLRF   xEB
03252:  CLRF   xEC
03254:  CLRF   xED
03256:  CLRF   xEE
03258:  MOVWF  xEF
0325A:  MOVWF  xF0
0325C:  MOVWF  xF1
0325E:  MOVWF  xF2
03260:  MOVWF  xF3
03262:  MOVWF  xF4
03264:  MOVWF  xF5
03266:  CLRF   xF6
03268:  CLRF   xF7
0326A:  CLRF   xF8
0326C:  MOVWF  xF9
0326E:  MOVWF  xFA
03270:  MOVWF  xFB
03272:  MOVWF  xFC
03274:  MOVWF  xFD
03276:  MOVWF  xFE
03278:  MOVWF  xFF
0327A:  MOVLB  7
0327C:  CLRF   x00
0327E:  CLRF   x01
03280:  CLRF   x02
03282:  CLRF   x03
03284:  CLRF   x04
03286:  CLRF   x05
03288:  CLRF   x06
0328A:  CLRF   x07
0328C:  MOVWF  x08
0328E:  MOVWF  x09
03290:  MOVWF  x0A
03292:  MOVWF  x0B
03294:  MOVWF  x0C
03296:  MOVWF  x0D
03298:  MOVWF  x0E
0329A:  CLRF   x0F
0329C:  CLRF   x10
0329E:  CLRF   x11
032A0:  MOVWF  x12
032A2:  MOVWF  x13
032A4:  MOVWF  x14
032A6:  MOVWF  x15
032A8:  MOVWF  x16
032AA:  MOVWF  x17
032AC:  MOVWF  x18
032AE:  CLRF   x19
032B0:  CLRF   x1A
032B2:  CLRF   x1B
032B4:  CLRF   x1C
032B6:  CLRF   x1D
032B8:  CLRF   x1E
032BA:  CLRF   x1F
032BC:  MOVWF  x20
032BE:  MOVWF  x21
032C0:  MOVWF  x22
032C2:  MOVWF  x23
032C4:  MOVWF  x24
032C6:  MOVWF  x25
032C8:  MOVWF  x26
032CA:  MOVWF  x27
032CC:  CLRF   x28
032CE:  CLRF   x29
032D0:  CLRF   x2A
032D2:  MOVWF  x2B
032D4:  MOVWF  x2C
032D6:  MOVWF  x2D
032D8:  MOVWF  x2E
032DA:  MOVWF  x2F
032DC:  MOVWF  x30
032DE:  MOVWF  x31
032E0:  MOVWF  x32
032E2:  CLRF   x33
032E4:  CLRF   x34
032E6:  CLRF   x35
032E8:  CLRF   x36
032EA:  CLRF   x37
032EC:  CLRF   x38
032EE:  MOVWF  x39
032F0:  MOVWF  x3A
032F2:  MOVWF  x3B
032F4:  MOVWF  x3C
032F6:  MOVWF  x3D
032F8:  MOVWF  x3E
032FA:  MOVWF  x3F
032FC:  MOVWF  x40
032FE:  MOVWF  x41
03300:  MOVWF  x42
03302:  MOVWF  x43
03304:  MOVWF  x44
03306:  MOVWF  x45
03308:  MOVWF  x46
0330A:  MOVWF  x47
0330C:  MOVWF  x48
0330E:  MOVWF  x49
03310:  MOVWF  x4A
03312:  MOVWF  x4B
03314:  CLRF   x4C
03316:  CLRF   x4D
03318:  CLRF   x4E
0331A:  CLRF   x4F
0331C:  CLRF   x50
0331E:  MOVWF  x51
03320:  MOVWF  x52
03322:  MOVWF  x53
03324:  MOVWF  x54
03326:  MOVWF  x55
03328:  MOVWF  x56
0332A:  MOVWF  x57
0332C:  MOVWF  x58
0332E:  MOVWF  x59
03330:  CLRF   x5A
03332:  CLRF   x5B
03334:  CLRF   x5C
03336:  MOVWF  x5D
03338:  MOVWF  x5E
0333A:  MOVWF  x5F
0333C:  MOVWF  x60
0333E:  MOVWF  x61
03340:  MOVWF  x62
03342:  MOVWF  x63
03344:  MOVWF  x64
03346:  MOVWF  x65
03348:  CLRF   x66
0334A:  CLRF   x67
0334C:  CLRF   x68
0334E:  CLRF   x69
03350:  MOVWF  x6A
03352:  MOVWF  x6B
03354:  MOVWF  x6C
03356:  MOVWF  x6D
03358:  MOVWF  x6E
0335A:  MOVWF  x6F
0335C:  MOVWF  x70
0335E:  MOVWF  x71
03360:  MOVWF  x72
03362:  CLRF   x73
03364:  CLRF   x74
03366:  CLRF   x75
03368:  MOVWF  x76
0336A:  MOVWF  x77
0336C:  MOVWF  x78
0336E:  MOVWF  x79
03370:  MOVWF  x7A
03372:  MOVWF  x7B
03374:  MOVWF  x7C
03376:  MOVWF  x7D
03378:  MOVWF  x7E
0337A:  CLRF   x7F
0337C:  CLRF   x80
0337E:  CLRF   x81
03380:  MOVWF  x82
03382:  MOVWF  x83
03384:  MOVWF  x84
03386:  MOVWF  x85
03388:  MOVWF  x86
0338A:  MOVWF  x87
0338C:  MOVWF  x88
0338E:  MOVWF  x89
03390:  MOVWF  x8A
03392:  MOVWF  x8B
03394:  CLRF   x8C
03396:  CLRF   x8D
03398:  CLRF   x8E
0339A:  MOVWF  x8F
0339C:  MOVWF  x90
0339E:  MOVWF  x91
033A0:  MOVWF  x92
033A2:  MOVWF  x93
033A4:  MOVWF  x94
033A6:  MOVWF  x95
033A8:  MOVWF  x96
033AA:  MOVWF  x97
033AC:  MOVWF  x98
033AE:  CLRF   x99
033B0:  CLRF   x9A
033B2:  MOVWF  x9B
033B4:  MOVWF  x9C
033B6:  MOVWF  x9D
033B8:  MOVWF  x9E
033BA:  MOVWF  x9F
033BC:  MOVWF  xA0
033BE:  MOVWF  xA1
033C0:  MOVWF  xA2
033C2:  MOVWF  xA3
033C4:  MOVWF  xA4
033C6:  MOVWF  xA5
033C8:  MOVWF  xA6
033CA:  MOVWF  xA7
033CC:  MOVWF  xA8
033CE:  MOVWF  xA9
033D0:  MOVWF  xAA
033D2:  MOVWF  xAB
033D4:  MOVWF  xAC
033D6:  MOVWF  xAD
033D8:  MOVWF  xAE
033DA:  MOVWF  xAF
033DC:  MOVWF  xB0
033DE:  MOVWF  xB1
033E0:  CLRF   xB2
033E2:  MOVWF  xB3
033E4:  MOVWF  xB4
033E6:  MOVWF  xB5
033E8:  MOVWF  xB6
033EA:  MOVWF  xB7
033EC:  MOVWF  xB8
033EE:  MOVWF  xB9
033F0:  MOVWF  xBA
033F2:  MOVWF  xBB
033F4:  MOVWF  xBC
033F6:  MOVWF  xBD
033F8:  MOVWF  xBE
033FA:  MOVWF  xBF
033FC:  MOVWF  xC0
033FE:  MOVWF  xC1
03400:  MOVWF  xC2
03402:  MOVWF  xC3
03404:  MOVWF  xC4
03406:  MOVWF  xC5
03408:  MOVWF  xC6
0340A:  MOVWF  xC7
0340C:  MOVWF  xC8
0340E:  MOVWF  xC9
03410:  MOVWF  xCA
03412:  MOVWF  xCB
....................      
....................     for(n=0; n<=625; n++) //draw a block 25 across by 25 down
03414:  MOVLB  5
03416:  CLRF   x58
03418:  CLRF   x57
0341A:  MOVF   x58,W
0341C:  SUBLW  02
0341E:  BNC   34B8
03420:  BNZ   3428
03422:  MOVF   x57,W
03424:  SUBLW  71
03426:  BNC   34B8
....................     {
....................         if(Display)
03428:  MOVF   x56,F
0342A:  BZ    3490
....................         {
....................             if(Alert[n] == 1)  //yellow
0342C:  MOVLW  5B
0342E:  ADDWF  x57,W
03430:  MOVWF  3FE9
03432:  MOVLW  05
03434:  ADDWFC x58,W
03436:  MOVWF  3FEA
03438:  DECFSZ 3FEF,W
0343A:  BRA    345E
....................             {
....................                 Data_Out(0xFF);
0343C:  MOVLB  8
0343E:  SETF   x54
03440:  MOVLB  0
03442:  CALL   0636
....................                 Data_Out(0xFE);
03446:  MOVLW  FE
03448:  MOVLB  8
0344A:  MOVWF  x54
0344C:  MOVLB  0
0344E:  CALL   0636
....................                 Data_Out(0x00);
03452:  MOVLB  8
03454:  CLRF   x54
03456:  MOVLB  0
03458:  CALL   0636
0345C:  MOVLB  5
....................             }
....................  
....................             if(Alert[n] == 0)  //black
0345E:  MOVLW  5B
03460:  ADDWF  x57,W
03462:  MOVWF  3FE9
03464:  MOVLW  05
03466:  ADDWFC x58,W
03468:  MOVWF  3FEA
0346A:  MOVF   3FEF,F
0346C:  BNZ   348E
....................             {
....................                 Data_Out(0x00);
0346E:  MOVLB  8
03470:  CLRF   x54
03472:  MOVLB  0
03474:  CALL   0636
....................                 Data_Out(0x00);
03478:  MOVLB  8
0347A:  CLRF   x54
0347C:  MOVLB  0
0347E:  CALL   0636
....................                 Data_Out(0x00);
03482:  MOVLB  8
03484:  CLRF   x54
03486:  MOVLB  0
03488:  CALL   0636
0348C:  MOVLB  5
....................             }
....................         }
0348E:  BRA    34B0
....................          else   //blank alert icon
....................         {
....................             Data_Out(0x00);
03490:  MOVLB  8
03492:  CLRF   x54
03494:  MOVLB  0
03496:  CALL   0636
....................             Data_Out(0x00);
0349A:  MOVLB  8
0349C:  CLRF   x54
0349E:  MOVLB  0
034A0:  CALL   0636
....................             Data_Out(0x00);
034A4:  MOVLB  8
034A6:  CLRF   x54
034A8:  MOVLB  0
034AA:  CALL   0636
034AE:  MOVLB  5
....................         }
034B0:  INCF   x57,F
034B2:  BTFSC  3FD8.2
034B4:  INCF   x58,F
034B6:  BRA    341A
....................             
....................      }
034B8:  MOVLB  0
034BA:  RETURN 0
....................     //fprintf(DEBUG,"\n\r %u, %u", g_BLE_Logo, g_Paired);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... /******************************************************************************
.................... *
.................... * FUNCTION     : DisplayTime(void)
.................... * INPUTS       : g_TreatMinutes , g_TreatSeconds
.................... * OUTPUTS      : none
.................... * RETURNS      : none
.................... * DESCRIPTION  : Plot bitmaps of integers that represent treatment time as MM:SS 
.................... *
.................... ******************************************************************************/
.................... void    DisplayTime(void)
.................... {
....................    
....................     uint8_t Minute_Tens;   //treatment minutes tens value
....................     uint8_t Minute_Ones;   //treatment minutes ones value
....................     uint8_t Second_Tens;   //treatment seconds tens value
....................     uint8_t Second_Ones;   //treatment seconds ones value
....................     
....................     static uint8_t LastMin_Tens = 4;   //treatment minutes tens value
....................     static uint8_t LastMin_Ones = 0;   //treatment minutes ones value
....................     static uint8_t LastSec_Tens = 0;   //treatment seconds tens value
....................      
....................     Minute_Tens = g_TreatMinutes /10;  //get tens value in minutes
*
05854:  MOVFF  514,55B
05858:  MOVFF  513,55A
0585C:  MOVLB  5
0585E:  CLRF   x5D
05860:  MOVLW  0A
05862:  MOVWF  x5C
05864:  MOVLB  0
05866:  CALL   34BC
0586A:  MOVFF  01,556
....................     Minute_Ones = g_TreatMinutes %10;   //get ones value in minutes
0586E:  MOVFF  514,55B
05872:  MOVFF  513,55A
05876:  MOVLB  5
05878:  CLRF   x5D
0587A:  MOVLW  0A
0587C:  MOVWF  x5C
0587E:  MOVLB  0
05880:  CALL   34BC
05884:  MOVFF  00,557
05888:  MOVLB  5
....................     Second_Tens = g_TreatSeconds /10;  //get tens value in minutes
0588A:  MOVFF  516,55B
0588E:  MOVFF  515,55A
05892:  CLRF   x5D
05894:  MOVLW  0A
05896:  MOVWF  x5C
05898:  MOVLB  0
0589A:  CALL   34BC
0589E:  MOVFF  01,558
....................     Second_Ones = g_TreatSeconds %10;   //get ones value in minutes
058A2:  MOVFF  516,55B
058A6:  MOVFF  515,55A
058AA:  MOVLB  5
058AC:  CLRF   x5D
058AE:  MOVLW  0A
058B0:  MOVWF  x5C
058B2:  MOVLB  0
058B4:  CALL   34BC
058B8:  MOVFF  00,559
058BC:  MOVLB  5
....................    
....................     //Update treatment minutes tens field if it has change
....................     if(LastMin_Tens != Min_Tens)
058BE:  MOVF   x43,F
058C0:  BZ    58CE
....................          Draw_Digit(MIN_TENS, Minute_Tens);
058C2:  CLRF   x5A
058C4:  MOVFF  556,55B
058C8:  MOVLB  0
058CA:  RCALL  5712
058CC:  MOVLB  5
....................     
....................   
....................     //Update treatment minutes ones field it has changed
....................     if(LastMin_Ones != Min_Ones)
058CE:  DECFSZ x44,W
058D0:  BRA    58D4
058D2:  BRA    58E2
....................         Draw_Digit(MIN_ONES, Minute_Ones);
058D4:  MOVLW  01
058D6:  MOVWF  x5A
058D8:  MOVFF  557,55B
058DC:  MOVLB  0
058DE:  RCALL  5712
058E0:  MOVLB  5
....................  
....................      
....................     //Update treatment seconds tens field it has changed
....................     if(LastSec_Tens != Sec_Tens)
058E2:  MOVF   x45,W
058E4:  SUBLW  02
058E6:  BZ    58F6
....................        Draw_Digit(SEC_TENS, Second_Tens);
058E8:  MOVLW  02
058EA:  MOVWF  x5A
058EC:  MOVFF  558,55B
058F0:  MOVLB  0
058F2:  RCALL  5712
058F4:  MOVLB  5
....................   
....................     Draw_Digit(SEC_ONES,Second_Ones);
058F6:  MOVLW  03
058F8:  MOVWF  x5A
058FA:  MOVFF  559,55B
058FE:  MOVLB  0
05900:  RCALL  5712
....................    
....................     //update
....................     LastMin_Tens = Minute_Tens;
05902:  MOVFF  556,543
....................     LastMin_Ones = Minute_Ones;
05906:  MOVFF  557,544
....................     LastSec_Tens = Second_Tens;
0590A:  MOVFF  558,545
0590E:  RETURN 0
....................  }
....................  
....................  
....................  /**
....................     Turn on all pixesl in red, green and blue then black
....................  
....................  **/
....................  void Clear_Display(void)
.................... {
....................     uint16_t i;
....................     uint8_t x,y;
....................     
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................     
....................     x=  X_CENTER;
....................     y = Y_CENTER;    
....................       
....................     Set_Column_Address(0,(x-63),0,(x+63)); //X coordinate
....................     Set_Page_Address(0,(y-59),0,(y+59));    //y coordinate
....................     Write_Memory_Start();
.................... 
....................      
....................     for(i=0; i<20480; i++)   //for each pixel
....................     {
....................         Data_Out(0x00);     //   
....................         Data_Out(0x00);     //   
....................         Data_Out(0x00);     // all black
....................     }
.................... }
....................  
....................  
....................  /**
....................     Draw a white circle for electrofe headset graphic
....................     
.................... **/
.................... void    Draw_Half_Circle(void)
.................... {
....................     int8_t n,i,x,y;
....................     int8_t  const X_CENTER = 64;    //column(X) value for center
....................     int8_t  const Y_CENTER = 80;    //row (Y) value for center
....................     int8_t  Circle1[64][2]= {
....................         {50,0},
....................         {50,5},
....................         {49,10},
....................         {48,15},
....................         {46,19},
....................         {44,24},
....................        {41,28},
....................        {38,32},
....................        {35,36},
....................        {31,39},
....................        {27,42},
....................        {23,45},
....................        {18,47},
....................        {13,48},
....................        {8,49},
....................        {4,50},
....................        {-1,50},
....................        {-6,50},
....................        {-11,49},
....................        {-16,47},
....................        { -21,45},
....................        {-25,43},
....................        {-29,40},
....................        {-33,37},
....................        {-37,34},
....................        {-40,30},
....................        {-43,26},
....................        {-45,21},
....................        {-47,17},
....................        {-49,12},
....................        {-49,7},
....................        {-50,2},
....................        {-50,-3},
....................       {-49,-8},
....................       {-48,-13},
....................       {-47,-18},
....................       {-45,-22},
....................       {-42,-26},
....................       {-40,-31},
....................       {-36,-34},
....................       {-33,-38},
....................       {-29,-41},
....................       {-25,-44},
....................       {-20,-46},
....................       {-15,-48},
....................       {-11,-49},
....................       {-6,-50},
....................       {-1,-50},
....................       {4,-50},
....................       {9,-49},
....................       {14,-48},
....................       {19,-46},
....................       {23,-44},
....................       {28,-42},
....................       {32,-39},
....................       {35,-35},
....................       {39,-32},
....................       {42,-28},
....................       {44,-23},
....................       {46,-19},
....................       {48,-14},
....................       {49,-9},
....................       {50,-4},
....................       {50,1}
....................    }; 
....................       
....................     
....................    for(i=33; i<64; i++)
....................    {
....................         x= Circle1[i][0]; //new column coordinate
....................         y= Circle1[i][1];   //new pagecoordinate
....................         
....................         Set_Column_Address(0,(X_CENTER+x-2),0,(X_CENTER+x+2)); //X coordinate
....................         Set_Page_Address(0,(Y_CENTER+y-2),0,(Y_CENTER+y+2));    //y coordinate
....................     //    Set_Column_Address(0,(X_CENTER+x-1),0,(X_CENTER+x+1)); //X coordinate
....................     //    Set_Page_Address(0,(Y_CENTER+y-1),0,(Y_CENTER+y+1));    //y coordinate
....................         Write_Memory_Start();
....................         
....................         for(n=0; n<9; n++) //draw a block
....................         {
....................             Data_Out(0xFF);
....................             Data_Out(0xFF);
....................             Data_Out(0xFF);
....................         }
....................     } 
.................... }
....................  
....................  
....................   /******************************************************************************
.................... *
.................... * FUNCTION     : Draw Forehead(uint8_t status)
.................... * INPUTS       : electrode status, 0=good, 1 = error
.................... * OUTPUTS      : none
.................... * RETURNS      : none
.................... * DESCRIPTION  : Plot 20x10 forehead electrode graphic status 
.................... *
.................... ******************************************************************************/
....................  void   Draw_Forehead(uint8_t Contact) 
....................  {
....................  
....................     uint16_t    n;
....................     uint8_t x,y;
....................    
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................     
....................     x=  X_CENTER;
*
0229C:  MOVLW  40
0229E:  MOVLB  5
022A0:  MOVWF  x59
....................     y = Y_CENTER -50;    
022A2:  MOVLW  0A
022A4:  MOVWF  x5A
....................             
....................       
....................     Set_Column_Address(0,(x-14),0,(x+15)); //X coordinate
022A6:  MOVLW  0E
022A8:  SUBWF  x59,W
022AA:  MOVLB  7
022AC:  MOVWF  x1D
022AE:  MOVLW  0F
022B0:  MOVLB  5
022B2:  ADDWF  x59,W
022B4:  MOVLB  7
022B6:  MOVWF  x1E
022B8:  MOVLB  8
022BA:  CLRF   x50
022BC:  MOVFF  71D,851
022C0:  CLRF   x52
022C2:  MOVWF  x53
022C4:  MOVLB  0
022C6:  CALL   0D50
....................     Set_Page_Address(0,(y-7),0,(y+8));    //y coordinate
022CA:  MOVLW  07
022CC:  MOVLB  5
022CE:  SUBWF  x5A,W
022D0:  MOVLB  7
022D2:  MOVWF  x1D
022D4:  MOVLW  08
022D6:  MOVLB  5
022D8:  ADDWF  x5A,W
022DA:  MOVLB  7
022DC:  MOVWF  x1E
022DE:  MOVLB  8
022E0:  CLRF   x50
022E2:  MOVFF  71D,851
022E6:  CLRF   x52
022E8:  MOVWF  x53
022EA:  MOVLB  0
022EC:  CALL   0D74
....................     Write_Memory_Start();
022F0:  CALL   0D98
....................     
....................     uint8_t Forehead[450]= {
....................     
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,       
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,       
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1, 
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
022F4:  MOVLW  01
022F6:  MOVLB  5
022F8:  MOVWF  x5B
022FA:  MOVWF  x5C
022FC:  MOVWF  x5D
022FE:  MOVWF  x5E
02300:  MOVWF  x5F
02302:  MOVWF  x60
02304:  MOVWF  x61
02306:  MOVWF  x62
02308:  MOVWF  x63
0230A:  MOVWF  x64
0230C:  MOVWF  x65
0230E:  MOVWF  x66
02310:  MOVWF  x67
02312:  MOVWF  x68
02314:  MOVWF  x69
02316:  MOVWF  x6A
02318:  MOVWF  x6B
0231A:  MOVWF  x6C
0231C:  MOVWF  x6D
0231E:  MOVWF  x6E
02320:  MOVWF  x6F
02322:  MOVWF  x70
02324:  MOVWF  x71
02326:  MOVWF  x72
02328:  MOVWF  x73
0232A:  MOVWF  x74
0232C:  MOVWF  x75
0232E:  MOVWF  x76
02330:  MOVWF  x77
02332:  MOVWF  x78
02334:  MOVWF  x79
02336:  CLRF   x7A
02338:  CLRF   x7B
0233A:  CLRF   x7C
0233C:  CLRF   x7D
0233E:  CLRF   x7E
02340:  CLRF   x7F
02342:  CLRF   x80
02344:  CLRF   x81
02346:  CLRF   x82
02348:  CLRF   x83
0234A:  CLRF   x84
0234C:  CLRF   x85
0234E:  CLRF   x86
02350:  CLRF   x87
02352:  CLRF   x88
02354:  CLRF   x89
02356:  CLRF   x8A
02358:  CLRF   x8B
0235A:  CLRF   x8C
0235C:  CLRF   x8D
0235E:  CLRF   x8E
02360:  CLRF   x8F
02362:  CLRF   x90
02364:  CLRF   x91
02366:  CLRF   x92
02368:  CLRF   x93
0236A:  CLRF   x94
0236C:  CLRF   x95
0236E:  MOVWF  x96
02370:  MOVWF  x97
02372:  CLRF   x98
02374:  CLRF   x99
02376:  CLRF   x9A
02378:  CLRF   x9B
0237A:  CLRF   x9C
0237C:  CLRF   x9D
0237E:  CLRF   x9E
02380:  CLRF   x9F
02382:  CLRF   xA0
02384:  CLRF   xA1
02386:  CLRF   xA2
02388:  CLRF   xA3
0238A:  CLRF   xA4
0238C:  CLRF   xA5
0238E:  CLRF   xA6
02390:  CLRF   xA7
02392:  CLRF   xA8
02394:  CLRF   xA9
02396:  CLRF   xAA
02398:  CLRF   xAB
0239A:  CLRF   xAC
0239C:  CLRF   xAD
0239E:  CLRF   xAE
023A0:  CLRF   xAF
023A2:  CLRF   xB0
023A4:  CLRF   xB1
023A6:  CLRF   xB2
023A8:  CLRF   xB3
023AA:  MOVWF  xB4
023AC:  MOVWF  xB5
023AE:  CLRF   xB6
023B0:  CLRF   xB7
023B2:  CLRF   xB8
023B4:  CLRF   xB9
023B6:  CLRF   xBA
023B8:  CLRF   xBB
023BA:  CLRF   xBC
023BC:  CLRF   xBD
023BE:  CLRF   xBE
023C0:  CLRF   xBF
023C2:  CLRF   xC0
023C4:  CLRF   xC1
023C6:  CLRF   xC2
023C8:  CLRF   xC3
023CA:  CLRF   xC4
023CC:  CLRF   xC5
023CE:  CLRF   xC6
023D0:  CLRF   xC7
023D2:  CLRF   xC8
023D4:  CLRF   xC9
023D6:  CLRF   xCA
023D8:  CLRF   xCB
023DA:  CLRF   xCC
023DC:  CLRF   xCD
023DE:  CLRF   xCE
023E0:  CLRF   xCF
023E2:  CLRF   xD0
023E4:  CLRF   xD1
023E6:  MOVWF  xD2
023E8:  MOVWF  xD3
023EA:  CLRF   xD4
023EC:  CLRF   xD5
023EE:  CLRF   xD6
023F0:  CLRF   xD7
023F2:  CLRF   xD8
023F4:  CLRF   xD9
023F6:  CLRF   xDA
023F8:  CLRF   xDB
023FA:  CLRF   xDC
023FC:  CLRF   xDD
023FE:  CLRF   xDE
02400:  CLRF   xDF
02402:  CLRF   xE0
02404:  CLRF   xE1
02406:  CLRF   xE2
02408:  CLRF   xE3
0240A:  CLRF   xE4
0240C:  CLRF   xE5
0240E:  CLRF   xE6
02410:  CLRF   xE7
02412:  CLRF   xE8
02414:  CLRF   xE9
02416:  CLRF   xEA
02418:  CLRF   xEB
0241A:  CLRF   xEC
0241C:  CLRF   xED
0241E:  CLRF   xEE
02420:  CLRF   xEF
02422:  MOVWF  xF0
02424:  MOVWF  xF1
02426:  CLRF   xF2
02428:  CLRF   xF3
0242A:  CLRF   xF4
0242C:  CLRF   xF5
0242E:  CLRF   xF6
02430:  CLRF   xF7
02432:  CLRF   xF8
02434:  CLRF   xF9
02436:  CLRF   xFA
02438:  CLRF   xFB
0243A:  CLRF   xFC
0243C:  CLRF   xFD
0243E:  CLRF   xFE
02440:  CLRF   xFF
02442:  MOVLB  6
02444:  CLRF   x00
02446:  CLRF   x01
02448:  CLRF   x02
0244A:  CLRF   x03
0244C:  CLRF   x04
0244E:  CLRF   x05
02450:  CLRF   x06
02452:  CLRF   x07
02454:  CLRF   x08
02456:  CLRF   x09
02458:  CLRF   x0A
0245A:  CLRF   x0B
0245C:  CLRF   x0C
0245E:  CLRF   x0D
02460:  MOVWF  x0E
02462:  MOVWF  x0F
02464:  CLRF   x10
02466:  CLRF   x11
02468:  CLRF   x12
0246A:  CLRF   x13
0246C:  CLRF   x14
0246E:  CLRF   x15
02470:  CLRF   x16
02472:  CLRF   x17
02474:  CLRF   x18
02476:  CLRF   x19
02478:  CLRF   x1A
0247A:  CLRF   x1B
0247C:  CLRF   x1C
0247E:  CLRF   x1D
02480:  CLRF   x1E
02482:  CLRF   x1F
02484:  CLRF   x20
02486:  CLRF   x21
02488:  CLRF   x22
0248A:  CLRF   x23
0248C:  CLRF   x24
0248E:  CLRF   x25
02490:  CLRF   x26
02492:  CLRF   x27
02494:  CLRF   x28
02496:  CLRF   x29
02498:  CLRF   x2A
0249A:  CLRF   x2B
0249C:  MOVWF  x2C
0249E:  MOVWF  x2D
024A0:  CLRF   x2E
024A2:  CLRF   x2F
024A4:  CLRF   x30
024A6:  CLRF   x31
024A8:  CLRF   x32
024AA:  CLRF   x33
024AC:  CLRF   x34
024AE:  CLRF   x35
024B0:  CLRF   x36
024B2:  CLRF   x37
024B4:  CLRF   x38
024B6:  CLRF   x39
024B8:  CLRF   x3A
024BA:  CLRF   x3B
024BC:  CLRF   x3C
024BE:  CLRF   x3D
024C0:  CLRF   x3E
024C2:  CLRF   x3F
024C4:  CLRF   x40
024C6:  CLRF   x41
024C8:  CLRF   x42
024CA:  CLRF   x43
024CC:  CLRF   x44
024CE:  CLRF   x45
024D0:  CLRF   x46
024D2:  CLRF   x47
024D4:  CLRF   x48
024D6:  CLRF   x49
024D8:  MOVWF  x4A
024DA:  MOVWF  x4B
024DC:  CLRF   x4C
024DE:  CLRF   x4D
024E0:  CLRF   x4E
024E2:  CLRF   x4F
024E4:  CLRF   x50
024E6:  CLRF   x51
024E8:  CLRF   x52
024EA:  CLRF   x53
024EC:  CLRF   x54
024EE:  CLRF   x55
024F0:  CLRF   x56
024F2:  CLRF   x57
024F4:  CLRF   x58
024F6:  CLRF   x59
024F8:  CLRF   x5A
024FA:  CLRF   x5B
024FC:  CLRF   x5C
024FE:  CLRF   x5D
02500:  CLRF   x5E
02502:  CLRF   x5F
02504:  CLRF   x60
02506:  CLRF   x61
02508:  CLRF   x62
0250A:  CLRF   x63
0250C:  CLRF   x64
0250E:  CLRF   x65
02510:  CLRF   x66
02512:  CLRF   x67
02514:  MOVWF  x68
02516:  MOVWF  x69
02518:  CLRF   x6A
0251A:  CLRF   x6B
0251C:  CLRF   x6C
0251E:  CLRF   x6D
02520:  CLRF   x6E
02522:  CLRF   x6F
02524:  CLRF   x70
02526:  CLRF   x71
02528:  CLRF   x72
0252A:  CLRF   x73
0252C:  CLRF   x74
0252E:  CLRF   x75
02530:  CLRF   x76
02532:  CLRF   x77
02534:  CLRF   x78
02536:  CLRF   x79
02538:  CLRF   x7A
0253A:  CLRF   x7B
0253C:  CLRF   x7C
0253E:  CLRF   x7D
02540:  CLRF   x7E
02542:  CLRF   x7F
02544:  CLRF   x80
02546:  CLRF   x81
02548:  CLRF   x82
0254A:  CLRF   x83
0254C:  CLRF   x84
0254E:  CLRF   x85
02550:  MOVWF  x86
02552:  MOVWF  x87
02554:  CLRF   x88
02556:  CLRF   x89
02558:  CLRF   x8A
0255A:  CLRF   x8B
0255C:  CLRF   x8C
0255E:  CLRF   x8D
02560:  CLRF   x8E
02562:  CLRF   x8F
02564:  CLRF   x90
02566:  CLRF   x91
02568:  CLRF   x92
0256A:  CLRF   x93
0256C:  CLRF   x94
0256E:  CLRF   x95
02570:  CLRF   x96
02572:  CLRF   x97
02574:  CLRF   x98
02576:  CLRF   x99
02578:  CLRF   x9A
0257A:  CLRF   x9B
0257C:  CLRF   x9C
0257E:  CLRF   x9D
02580:  CLRF   x9E
02582:  CLRF   x9F
02584:  CLRF   xA0
02586:  CLRF   xA1
02588:  CLRF   xA2
0258A:  CLRF   xA3
0258C:  MOVWF  xA4
0258E:  MOVWF  xA5
02590:  CLRF   xA6
02592:  CLRF   xA7
02594:  CLRF   xA8
02596:  CLRF   xA9
02598:  CLRF   xAA
0259A:  CLRF   xAB
0259C:  CLRF   xAC
0259E:  CLRF   xAD
025A0:  CLRF   xAE
025A2:  CLRF   xAF
025A4:  CLRF   xB0
025A6:  CLRF   xB1
025A8:  CLRF   xB2
025AA:  CLRF   xB3
025AC:  CLRF   xB4
025AE:  CLRF   xB5
025B0:  CLRF   xB6
025B2:  CLRF   xB7
025B4:  CLRF   xB8
025B6:  CLRF   xB9
025B8:  CLRF   xBA
025BA:  CLRF   xBB
025BC:  CLRF   xBC
025BE:  CLRF   xBD
025C0:  CLRF   xBE
025C2:  CLRF   xBF
025C4:  CLRF   xC0
025C6:  CLRF   xC1
025C8:  MOVWF  xC2
025CA:  MOVWF  xC3
025CC:  CLRF   xC4
025CE:  CLRF   xC5
025D0:  CLRF   xC6
025D2:  CLRF   xC7
025D4:  CLRF   xC8
025D6:  CLRF   xC9
025D8:  CLRF   xCA
025DA:  CLRF   xCB
025DC:  CLRF   xCC
025DE:  CLRF   xCD
025E0:  CLRF   xCE
025E2:  CLRF   xCF
025E4:  CLRF   xD0
025E6:  CLRF   xD1
025E8:  CLRF   xD2
025EA:  CLRF   xD3
025EC:  CLRF   xD4
025EE:  CLRF   xD5
025F0:  CLRF   xD6
025F2:  CLRF   xD7
025F4:  CLRF   xD8
025F6:  CLRF   xD9
025F8:  CLRF   xDA
025FA:  CLRF   xDB
025FC:  CLRF   xDC
025FE:  CLRF   xDD
02600:  CLRF   xDE
02602:  CLRF   xDF
02604:  MOVWF  xE0
02606:  MOVWF  xE1
02608:  CLRF   xE2
0260A:  CLRF   xE3
0260C:  CLRF   xE4
0260E:  CLRF   xE5
02610:  CLRF   xE6
02612:  CLRF   xE7
02614:  CLRF   xE8
02616:  CLRF   xE9
02618:  CLRF   xEA
0261A:  CLRF   xEB
0261C:  CLRF   xEC
0261E:  CLRF   xED
02620:  CLRF   xEE
02622:  CLRF   xEF
02624:  CLRF   xF0
02626:  CLRF   xF1
02628:  CLRF   xF2
0262A:  CLRF   xF3
0262C:  CLRF   xF4
0262E:  CLRF   xF5
02630:  CLRF   xF6
02632:  CLRF   xF7
02634:  CLRF   xF8
02636:  CLRF   xF9
02638:  CLRF   xFA
0263A:  CLRF   xFB
0263C:  CLRF   xFC
0263E:  CLRF   xFD
02640:  MOVWF  xFE
02642:  MOVWF  xFF
02644:  MOVLB  7
02646:  MOVWF  x00
02648:  MOVWF  x01
0264A:  MOVWF  x02
0264C:  MOVWF  x03
0264E:  MOVWF  x04
02650:  MOVWF  x05
02652:  MOVWF  x06
02654:  MOVWF  x07
02656:  MOVWF  x08
02658:  MOVWF  x09
0265A:  MOVWF  x0A
0265C:  MOVWF  x0B
0265E:  MOVWF  x0C
02660:  MOVWF  x0D
02662:  MOVWF  x0E
02664:  MOVWF  x0F
02666:  MOVWF  x10
02668:  MOVWF  x11
0266A:  MOVWF  x12
0266C:  MOVWF  x13
0266E:  MOVWF  x14
02670:  MOVWF  x15
02672:  MOVWF  x16
02674:  MOVWF  x17
02676:  MOVWF  x18
02678:  MOVWF  x19
0267A:  MOVWF  x1A
0267C:  MOVWF  x1B
0267E:  MOVWF  x1C
....................     
....................     for(n=0; n<=449; n++) //draw a block 20 across by 10 down
02680:  MOVLB  5
02682:  CLRF   x58
02684:  CLRF   x57
02686:  MOVF   x58,W
02688:  SUBLW  01
0268A:  BNC   2716
0268C:  BNZ   2694
0268E:  MOVF   x57,W
02690:  SUBLW  C1
02692:  BNC   2716
....................     {
....................         if(Forehead[n] == 1)  //white
02694:  MOVLW  5B
02696:  ADDWF  x57,W
02698:  MOVWF  3FE9
0269A:  MOVLW  05
0269C:  ADDWFC x58,W
0269E:  MOVWF  3FEA
026A0:  DECFSZ 3FEF,W
026A2:  BRA    26C6
....................         {
....................             Data_Out(0xFF);
026A4:  MOVLB  8
026A6:  SETF   x54
026A8:  MOVLB  0
026AA:  CALL   0636
....................             Data_Out(0xFF);
026AE:  MOVLB  8
026B0:  SETF   x54
026B2:  MOVLB  0
026B4:  CALL   0636
....................             Data_Out(0xFF);
026B8:  MOVLB  8
026BA:  SETF   x54
026BC:  MOVLB  0
026BE:  CALL   0636
....................         }
026C2:  BRA    270C
026C4:  MOVLB  5
....................         else
....................         {
....................             if(Contact == POOR)  
026C6:  MOVF   x56,F
026C8:  BNZ   26EE
....................             {
....................                 Data_Out(0xFF);  //yellow
026CA:  MOVLB  8
026CC:  SETF   x54
026CE:  MOVLB  0
026D0:  CALL   0636
....................                 Data_Out(0xFE);
026D4:  MOVLW  FE
026D6:  MOVLB  8
026D8:  MOVWF  x54
026DA:  MOVLB  0
026DC:  CALL   0636
....................                 Data_Out(0x00);
026E0:  MOVLB  8
026E2:  CLRF   x54
026E4:  MOVLB  0
026E6:  CALL   0636
....................             }
026EA:  BRA    270C
026EC:  MOVLB  5
....................             else   //electrode is green
....................             {
....................                 Data_Out(0x00);
026EE:  MOVLB  8
026F0:  CLRF   x54
026F2:  MOVLB  0
026F4:  CALL   0636
....................                 Data_Out(0xFF);
026F8:  MOVLB  8
026FA:  SETF   x54
026FC:  MOVLB  0
026FE:  CALL   0636
....................                 Data_Out(0x00);
02702:  MOVLB  8
02704:  CLRF   x54
02706:  MOVLB  0
02708:  CALL   0636
....................             }
....................             
....................         }  
0270C:  MOVLB  5
0270E:  INCF   x57,F
02710:  BTFSC  3FD8.2
02712:  INCF   x58,F
02714:  BRA    2686
....................     }
02716:  MOVLB  0
02718:  RETURN 0
....................  
....................  }
....................  
....................  
....................  
....................   
....................   /******************************************************************************
.................... *
.................... * FUNCTION     : Draw <Mastoid(uint8_t status, uint8_t Side)
.................... * INPUTS       : electrode status: 0=poor, 1=good, side: 1=left, 0=right
.................... * OUTPUTS      : none
.................... * RETURNS      : none
.................... * DESCRIPTION  : Plot forehead electrode graphic status 
.................... uint8_t const       POOR = 0;
.................... uint8_t const       GOOD = 1;
.................... uint8_t const       LEFT = 1;
.................... uint8_t const       RIGHT = 0;
.................... *
.................... ******************************************************************************/
....................  void   Draw_Mastoid(uint8_t Contact, uint8_t Side) 
....................  {
....................  
....................     uint16_t    n;
....................     uint8_t x,y;
....................    
....................     uint8_t const  X_CENTER = 64;    //column(X) value for center
....................     uint8_t const  Y_CENTER = 60;    //row (Y) value for center
....................     
....................     if(Side == LEFT)
0271A:  MOVLB  5
0271C:  DECFSZ x57,W
0271E:  BRA    2724
....................         x=  X_CENTER + 48;
02720:  MOVLW  70
02722:  MOVWF  x5A
....................    
....................     if(Side == RIGHT)
02724:  MOVF   x57,F
02726:  BNZ   272C
....................        x=  X_CENTER - 48;   
02728:  MOVLW  10
0272A:  MOVWF  x5A
....................        
....................     y = Y_CENTER + 15;
0272C:  MOVLW  4B
0272E:  MOVWF  x5B
....................  //   fprintf(DEBUG,"\n\r %u, %u,",Contact,Side);        
....................       
....................  //   Set_Column_Address(0,(x-5),0,(x+6)); //X coordinate
.................... //    Set_Page_Address(0,(y-5),0,(y+6));    //y coordinate
....................     Set_Column_Address(0,(x-6),0,(x+7)); //X coordinate
02730:  MOVLW  06
02732:  SUBWF  x5A,W
02734:  MOVLB  6
02736:  MOVWF  x20
02738:  MOVLW  07
0273A:  MOVLB  5
0273C:  ADDWF  x5A,W
0273E:  MOVLB  6
02740:  MOVWF  x21
02742:  MOVLB  8
02744:  CLRF   x50
02746:  MOVFF  620,851
0274A:  CLRF   x52
0274C:  MOVWF  x53
0274E:  MOVLB  0
02750:  CALL   0D50
....................     Set_Page_Address(0,(y-6),0,(y+7));    //y coordinate
02754:  MOVLW  06
02756:  MOVLB  5
02758:  SUBWF  x5B,W
0275A:  MOVLB  6
0275C:  MOVWF  x20
0275E:  MOVLW  07
02760:  MOVLB  5
02762:  ADDWF  x5B,W
02764:  MOVLB  6
02766:  MOVWF  x21
02768:  MOVLB  8
0276A:  CLRF   x50
0276C:  MOVFF  620,851
02770:  CLRF   x52
02772:  MOVWF  x53
02774:  MOVLB  0
02776:  CALL   0D74
....................     Write_Memory_Start();
0277A:  CALL   0D98
....................     
....................    // uint8_t Mastoid[144]= {
....................     uint8_t Mastoid[196]= {
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,   
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,    
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,0,0,0,0,0,0,0,0,0,0,0,0,1,
....................     1,1,1,1,1,1,1,1,1,1,1,1,1,1};
0277E:  MOVLW  01
02780:  MOVLB  5
02782:  MOVWF  x5C
02784:  MOVWF  x5D
02786:  MOVWF  x5E
02788:  MOVWF  x5F
0278A:  MOVWF  x60
0278C:  MOVWF  x61
0278E:  MOVWF  x62
02790:  MOVWF  x63
02792:  MOVWF  x64
02794:  MOVWF  x65
02796:  MOVWF  x66
02798:  MOVWF  x67
0279A:  MOVWF  x68
0279C:  MOVWF  x69
0279E:  MOVWF  x6A
027A0:  CLRF   x6B
027A2:  CLRF   x6C
027A4:  CLRF   x6D
027A6:  CLRF   x6E
027A8:  CLRF   x6F
027AA:  CLRF   x70
027AC:  CLRF   x71
027AE:  CLRF   x72
027B0:  CLRF   x73
027B2:  CLRF   x74
027B4:  CLRF   x75
027B6:  CLRF   x76
027B8:  MOVWF  x77
027BA:  MOVWF  x78
027BC:  CLRF   x79
027BE:  CLRF   x7A
027C0:  CLRF   x7B
027C2:  CLRF   x7C
027C4:  CLRF   x7D
027C6:  CLRF   x7E
027C8:  CLRF   x7F
027CA:  CLRF   x80
027CC:  CLRF   x81
027CE:  CLRF   x82
027D0:  CLRF   x83
027D2:  CLRF   x84
027D4:  MOVWF  x85
027D6:  MOVWF  x86
027D8:  CLRF   x87
027DA:  CLRF   x88
027DC:  CLRF   x89
027DE:  CLRF   x8A
027E0:  CLRF   x8B
027E2:  CLRF   x8C
027E4:  CLRF   x8D
027E6:  CLRF   x8E
027E8:  CLRF   x8F
027EA:  CLRF   x90
027EC:  CLRF   x91
027EE:  CLRF   x92
027F0:  MOVWF  x93
027F2:  MOVWF  x94
027F4:  CLRF   x95
027F6:  CLRF   x96
027F8:  CLRF   x97
027FA:  CLRF   x98
027FC:  CLRF   x99
027FE:  CLRF   x9A
02800:  CLRF   x9B
02802:  CLRF   x9C
02804:  CLRF   x9D
02806:  CLRF   x9E
02808:  CLRF   x9F
0280A:  CLRF   xA0
0280C:  MOVWF  xA1
0280E:  MOVWF  xA2
02810:  CLRF   xA3
02812:  CLRF   xA4
02814:  CLRF   xA5
02816:  CLRF   xA6
02818:  CLRF   xA7
0281A:  CLRF   xA8
0281C:  CLRF   xA9
0281E:  CLRF   xAA
02820:  CLRF   xAB
02822:  CLRF   xAC
02824:  CLRF   xAD
02826:  CLRF   xAE
02828:  MOVWF  xAF
0282A:  MOVWF  xB0
0282C:  CLRF   xB1
0282E:  CLRF   xB2
02830:  CLRF   xB3
02832:  CLRF   xB4
02834:  CLRF   xB5
02836:  CLRF   xB6
02838:  CLRF   xB7
0283A:  CLRF   xB8
0283C:  CLRF   xB9
0283E:  CLRF   xBA
02840:  CLRF   xBB
02842:  CLRF   xBC
02844:  MOVWF  xBD
02846:  MOVWF  xBE
02848:  CLRF   xBF
0284A:  CLRF   xC0
0284C:  CLRF   xC1
0284E:  CLRF   xC2
02850:  CLRF   xC3
02852:  CLRF   xC4
02854:  CLRF   xC5
02856:  CLRF   xC6
02858:  CLRF   xC7
0285A:  CLRF   xC8
0285C:  CLRF   xC9
0285E:  CLRF   xCA
02860:  MOVWF  xCB
02862:  MOVWF  xCC
02864:  CLRF   xCD
02866:  CLRF   xCE
02868:  CLRF   xCF
0286A:  CLRF   xD0
0286C:  CLRF   xD1
0286E:  CLRF   xD2
02870:  CLRF   xD3
02872:  CLRF   xD4
02874:  CLRF   xD5
02876:  CLRF   xD6
02878:  CLRF   xD7
0287A:  CLRF   xD8
0287C:  MOVWF  xD9
0287E:  MOVWF  xDA
02880:  CLRF   xDB
02882:  CLRF   xDC
02884:  CLRF   xDD
02886:  CLRF   xDE
02888:  CLRF   xDF
0288A:  CLRF   xE0
0288C:  CLRF   xE1
0288E:  CLRF   xE2
02890:  CLRF   xE3
02892:  CLRF   xE4
02894:  CLRF   xE5
02896:  CLRF   xE6
02898:  MOVWF  xE7
0289A:  MOVWF  xE8
0289C:  CLRF   xE9
0289E:  CLRF   xEA
028A0:  CLRF   xEB
028A2:  CLRF   xEC
028A4:  CLRF   xED
028A6:  CLRF   xEE
028A8:  CLRF   xEF
028AA:  CLRF   xF0
028AC:  CLRF   xF1
028AE:  CLRF   xF2
028B0:  CLRF   xF3
028B2:  CLRF   xF4
028B4:  MOVWF  xF5
028B6:  MOVWF  xF6
028B8:  CLRF   xF7
028BA:  CLRF   xF8
028BC:  CLRF   xF9
028BE:  CLRF   xFA
028C0:  CLRF   xFB
028C2:  CLRF   xFC
028C4:  CLRF   xFD
028C6:  CLRF   xFE
028C8:  CLRF   xFF
028CA:  MOVLB  6
028CC:  CLRF   x00
028CE:  CLRF   x01
028D0:  CLRF   x02
028D2:  MOVWF  x03
028D4:  MOVWF  x04
028D6:  MOVWF  x05
028D8:  MOVWF  x06
028DA:  MOVWF  x07
028DC:  MOVWF  x08
028DE:  MOVWF  x09
028E0:  MOVWF  x0A
028E2:  MOVWF  x0B
028E4:  MOVWF  x0C
028E6:  MOVWF  x0D
028E8:  MOVWF  x0E
028EA:  MOVWF  x0F
028EC:  MOVWF  x10
028EE:  MOVWF  x11
028F0:  CLRF   x12
028F2:  CLRF   x13
028F4:  CLRF   x14
028F6:  CLRF   x15
028F8:  CLRF   x16
028FA:  CLRF   x17
028FC:  CLRF   x18
028FE:  CLRF   x19
02900:  CLRF   x1A
02902:  CLRF   x1B
02904:  CLRF   x1C
02906:  CLRF   x1D
02908:  CLRF   x1E
0290A:  CLRF   x1F
....................     
....................     //for(n=0; n<=143; n++) //draw a block 30 across by 15 down
....................      for(n=0; n<=195; n++) //draw a block 30 across by 15 down
0290C:  MOVLB  5
0290E:  CLRF   x59
02910:  CLRF   x58
02912:  MOVF   x59,F
02914:  BNZ   299E
02916:  MOVF   x58,W
02918:  SUBLW  C3
0291A:  BNC   299E
....................     {
....................         if(Mastoid[n] == 1)  //white
0291C:  MOVLW  5C
0291E:  ADDWF  x58,W
02920:  MOVWF  3FE9
02922:  MOVLW  05
02924:  ADDWFC x59,W
02926:  MOVWF  3FEA
02928:  DECFSZ 3FEF,W
0292A:  BRA    294E
....................         {
....................             Data_Out(0xFF);
0292C:  MOVLB  8
0292E:  SETF   x54
02930:  MOVLB  0
02932:  CALL   0636
....................             Data_Out(0xFF);
02936:  MOVLB  8
02938:  SETF   x54
0293A:  MOVLB  0
0293C:  CALL   0636
....................             Data_Out(0xFF);
02940:  MOVLB  8
02942:  SETF   x54
02944:  MOVLB  0
02946:  CALL   0636
....................         }
0294A:  BRA    2994
0294C:  MOVLB  5
....................         else
....................         {
....................             if(Contact == POOR)  
0294E:  MOVF   x56,F
02950:  BNZ   2976
....................             {
....................                 Data_Out(0xFF);  //yellow
02952:  MOVLB  8
02954:  SETF   x54
02956:  MOVLB  0
02958:  CALL   0636
....................                 Data_Out(0xFE);
0295C:  MOVLW  FE
0295E:  MOVLB  8
02960:  MOVWF  x54
02962:  MOVLB  0
02964:  CALL   0636
....................                 Data_Out(0x00);
02968:  MOVLB  8
0296A:  CLRF   x54
0296C:  MOVLB  0
0296E:  CALL   0636
....................             }
02972:  BRA    2994
02974:  MOVLB  5
....................             else   //electrode is green
....................             {
....................                 Data_Out(0x00);
02976:  MOVLB  8
02978:  CLRF   x54
0297A:  MOVLB  0
0297C:  CALL   0636
....................                 Data_Out(0xFF);
02980:  MOVLB  8
02982:  SETF   x54
02984:  MOVLB  0
02986:  CALL   0636
....................                 Data_Out(0x00);
0298A:  MOVLB  8
0298C:  CLRF   x54
0298E:  MOVLB  0
02990:  CALL   0636
....................             }
....................             
....................         }  
02994:  MOVLB  5
02996:  INCF   x58,F
02998:  BTFSC  3FD8.2
0299A:  INCF   x59,F
0299C:  BRA    2912
....................     }
0299E:  MOVLB  0
029A0:  RETURN 0
....................   
....................  }
....................  
....................  
....................  
....................  /******************************************************************************
.................... *
.................... * FUNCTION     : Draw Electrodes(void)
.................... * INPUTS       : Left, Forehead and Right Electrode status, 0=good, 1 = bad
.................... * OUTPUTS      : none
.................... * RETURNS      : none
.................... * DESCRIPTION  : Plot headset electrode graphic status 
.................... *
.................... ******************************************************************************/
.................... void    Draw_Electrodes(void)
.................... {
.................... 
....................   //  Clear_Display();     //clear display
....................     Draw_Circle();      //Draw a circle
029A2:  GOTO   1FB4
....................     
....................     if(bit_test(g_Contact_Status,FORE_FLG))     //if forehead contact is good
029A6:  MOVLB  5
029A8:  BTFSS  x11.1
029AA:  BRA    29B8
....................         Draw_Forehead(GOOD);     //draw forehead, green
029AC:  MOVLW  01
029AE:  MOVWF  x56
029B0:  MOVLB  0
029B2:  RCALL  229C
029B4:  BRA    29BE
029B6:  MOVLB  5
....................     else
....................          Draw_Forehead(POOR);     //draw forehead,yellow
029B8:  CLRF   x56
029BA:  MOVLB  0
029BC:  RCALL  229C
.................... 
....................     if(bit_test(g_Contact_Status,LEFT_FLG))     //if left contact is good
029BE:  MOVLB  5
029C0:  BTFSS  x11.0
029C2:  BRA    29D2
....................         Draw_Mastoid(GOOD,LEFT);    //draw Left mastoid, green
029C4:  MOVLW  01
029C6:  MOVWF  x56
029C8:  MOVWF  x57
029CA:  MOVLB  0
029CC:  RCALL  271A
029CE:  BRA    29DC
029D0:  MOVLB  5
....................     else
....................         Draw_Mastoid(POOR,LEFT);    //draw Left mastoid, draw forehead,yellow
029D2:  CLRF   x56
029D4:  MOVLW  01
029D6:  MOVWF  x57
029D8:  MOVLB  0
029DA:  RCALL  271A
....................          
....................     if(bit_test(g_Contact_Status,RIGHT_FLG))     //if right contact is good
029DC:  MOVLB  5
029DE:  BTFSS  x11.2
029E0:  BRA    29F0
....................         Draw_Mastoid(GOOD,RIGHT);    //draw Left mastoid, green
029E2:  MOVLW  01
029E4:  MOVWF  x56
029E6:  CLRF   x57
029E8:  MOVLB  0
029EA:  RCALL  271A
029EC:  BRA    29F8
029EE:  MOVLB  5
....................     else
....................         Draw_Mastoid(POOR,RIGHT);    //draw Left mastoid, draw forehead,yellow  
029F0:  CLRF   x56
029F2:  CLRF   x57
029F4:  MOVLB  0
029F6:  RCALL  271A
029F8:  RETURN 0
....................   //  Draw_Mastoid(POOR,RIGHT);    //draw Left mastoid,
....................  //   Draw_Mastoid(POOR,LEFT);    //draw Left mastoid,
....................  //   Draw_Colon();
.................... //    DisplayTime();
.................... }
.................... 
.................... 
.................... 
....................  /******************************************************************************
.................... *
.................... * FUNCTION     : void Display_Treat_Screen(void);
.................... * INPUTS       : none
.................... * OUTPUTS      : none
.................... * RETURNS      : none
.................... * DESCRIPTION  : Set up treatment screen
.................... *
.................... ******************************************************************************/
.................... void Display_Treat_Screen(void)
.................... {
....................     fprintf(DEBUG,"\n\r Clear");
....................    //  Clear_Display();
....................   
....................   //  Draw_Circle();
....................  //   Draw_Colon();
....................   //   DisplayTime();
.................... }
.................... 
.................... 
.................... //Prototypes
.................... //**********************************************************
.................... void    TIMER1_isr(void);       //system heartbeat 10msec
.................... void    Init_IO(void);
.................... void    Self_Test(void);
.................... void    Check_Buttons(void);     //check buttons
.................... void    Clocks(void);   //update clocks
.................... void    Charge_Battery(void);   //charge battery
.................... void    Tasks(void);
.................... void    Main(void);
.................... void    UpdateDisplayTime(void);
.................... void    Check_BLE(void); 
.................... void    Update_Handset_Battery_Gauge(void);
.................... void    Update_Headset_Battery_Gauge(void);
.................... void    Update_Handset_Battery_VI(void);
.................... void    Process_Command(void);
.................... 
.................... //*************************************Code **********************************
.................... 
.................... 
.................... /******************************************************************************
.................... *
.................... * FUNCTION     : Update_Head_Battery(void)
.................... * INPUTS       : Head battery voltage
.................... * OUTPUTS      : none
.................... * RETURNS      : none
.................... * DESCRIPTION  : Convert battery voltage to levels and display 
.................... /*****************************************************************************/
.................... 
.................... void    Update_Headset_Battery_Gauge(void)
.................... {
....................            
....................    if( (g_Head_Batt_Volts > 380l) && (g_Head_Batt_Level !=100) )
*
06120:  MOVLB  5
06122:  MOVF   x1E,W
06124:  SUBLW  00
06126:  BC    6148
06128:  XORLW  FF
0612A:  BNZ   6132
0612C:  MOVF   x1D,W
0612E:  SUBLW  7C
06130:  BC    6148
06132:  MOVF   x22,W
06134:  SUBLW  64
06136:  BZ    6148
....................    {
....................         g_Head_Batt_Level = 100;
06138:  MOVLW  64
0613A:  MOVWF  x22
....................         Draw_Full_Battery(HEAD);
0613C:  CLRF   x56
0613E:  MOVLB  0
06140:  CALL   18DC
....................    }
06144:  BRA    622E
06146:  MOVLB  5
....................    else if( (g_Head_Batt_Volts<= 380l) && (g_Head_Batt_Volts > 370l) && (g_Head_Batt_Level !=80) )
06148:  MOVF   x1E,W
0614A:  SUBLW  01
0614C:  BNC   617C
0614E:  BNZ   6156
06150:  MOVF   x1D,W
06152:  SUBLW  7C
06154:  BNC   617C
06156:  MOVF   x1E,W
06158:  SUBLW  00
0615A:  BC    617C
0615C:  XORLW  FF
0615E:  BNZ   6166
06160:  MOVF   x1D,W
06162:  SUBLW  72
06164:  BC    617C
06166:  MOVF   x22,W
06168:  SUBLW  50
0616A:  BZ    617C
....................    {
....................         g_Head_Batt_Level = 80;
0616C:  MOVLW  50
0616E:  MOVWF  x22
....................         Draw_Three_Quart_Battery(HEAD);
06170:  CLRF   x56
06172:  MOVLB  0
06174:  CALL   151C
....................    }
06178:  BRA    622E
0617A:  MOVLB  5
....................    else if( (g_Head_Batt_Volts <= 370l) && (g_Head_Batt_Volts > 360l) && (g_Head_Batt_Level !=60) )
0617C:  MOVF   x1E,W
0617E:  SUBLW  01
06180:  BNC   61B0
06182:  BNZ   618A
06184:  MOVF   x1D,W
06186:  SUBLW  72
06188:  BNC   61B0
0618A:  MOVF   x1E,W
0618C:  SUBLW  00
0618E:  BC    61B0
06190:  XORLW  FF
06192:  BNZ   619A
06194:  MOVF   x1D,W
06196:  SUBLW  68
06198:  BC    61B0
0619A:  MOVF   x22,W
0619C:  SUBLW  3C
0619E:  BZ    61B0
....................    {
....................         g_Head_Batt_Level = 60;
061A0:  MOVLW  3C
061A2:  MOVWF  x22
....................         Draw_Half_Battery(HEAD);
061A4:  CLRF   x56
061A6:  MOVLB  0
061A8:  CALL   1160
....................     }      
061AC:  BRA    622E
061AE:  MOVLB  5
....................     else if( (g_Head_Batt_Volts <= 360l) && (g_Head_Batt_Volts > 350l) && (g_Head_Batt_Level !=40) )
061B0:  MOVF   x1E,W
061B2:  SUBLW  01
061B4:  BNC   61E4
061B6:  BNZ   61BE
061B8:  MOVF   x1D,W
061BA:  SUBLW  68
061BC:  BNC   61E4
061BE:  MOVF   x1E,W
061C0:  SUBLW  00
061C2:  BC    61E4
061C4:  XORLW  FF
061C6:  BNZ   61CE
061C8:  MOVF   x1D,W
061CA:  SUBLW  5E
061CC:  BC    61E4
061CE:  MOVF   x22,W
061D0:  SUBLW  28
061D2:  BZ    61E4
....................    {
....................        g_Head_Batt_Level = 40;
061D4:  MOVLW  28
061D6:  MOVWF  x22
....................         Draw_Quart_Battery(HEAD);
061D8:  CLRF   x56
061DA:  MOVLB  0
061DC:  CALL   0DA4
....................    }       
061E0:  BRA    622E
061E2:  MOVLB  5
....................     else if( (g_Head_Batt_Volts <= 350l) && (g_Head_Batt_Volts > 340l) && (g_Head_Batt_Level !=20) )
061E4:  MOVF   x1E,W
061E6:  SUBLW  01
061E8:  BNC   6218
061EA:  BNZ   61F2
061EC:  MOVF   x1D,W
061EE:  SUBLW  5E
061F0:  BNC   6218
061F2:  MOVF   x1E,W
061F4:  SUBLW  00
061F6:  BC    6218
061F8:  XORLW  FF
061FA:  BNZ   6202
061FC:  MOVF   x1D,W
061FE:  SUBLW  54
06200:  BC    6218
06202:  MOVF   x22,W
06204:  SUBLW  14
06206:  BZ    6218
....................    {
....................        g_Head_Batt_Level = 20;
06208:  MOVLW  14
0620A:  MOVWF  x22
....................         Draw_Empty_Battery(HEAD);
0620C:  CLRF   x56
0620E:  MOVLB  0
06210:  CALL   29FA
....................    }             
06214:  BRA    622E
06216:  MOVLB  5
....................    else if(g_Head_Batt_Volts < 340l)  //if dead battert 
06218:  MOVF   x1E,W
0621A:  SUBLW  01
0621C:  BNC   6230
0621E:  BNZ   6226
06220:  MOVF   x1D,W
06222:  SUBLW  53
06224:  BNC   6230
....................     {
....................        Draw_Empty_Battery(HEAD);
06226:  CLRF   x56
06228:  MOVLB  0
0622A:  CALL   29FA
0622E:  MOVLB  5
....................     }
06230:  MOVLB  0
06232:  GOTO   6466 (RETURN)
....................  // fprintf(DEBUG,"\n\r %lu,Level=%u", g_Head_Batt_Volts, g_Head_Batt_Level);
.................... 
....................  }   
.................... 
.................... 
.................... 
.................... /******************************************************************************
.................... *
.................... * FUNCTION     : Update_Handset_Battery(void)
.................... * INPUTS       : Handset battery voltage
.................... * OUTPUTS      : none
.................... * RETURNS      : none
.................... * DESCRIPTION  : Convert battery voltage to levels and display 
.................... /*****************************************************************************/
.................... 
.................... void    Update_Handset_Battery_Gauge(void)
.................... {
....................   static    uint8_t   Batt_Level = 0;
.................... 
....................    if( (g_Batt_Volts > 380) && (Batt_Level !=100) )   
*
02DB6:  MOVLB  5
02DB8:  MOVF   x1A,W
02DBA:  SUBLW  00
02DBC:  BC    2DE0
02DBE:  XORLW  FF
02DC0:  BNZ   2DC8
02DC2:  MOVF   x19,W
02DC4:  SUBLW  7C
02DC6:  BC    2DE0
02DC8:  MOVF   x46,W
02DCA:  SUBLW  64
02DCC:  BZ    2DE0
....................    {
....................         Batt_Level = 100;
02DCE:  MOVLW  64
02DD0:  MOVWF  x46
....................         Draw_Full_Battery(HAND);
02DD2:  MOVLW  01
02DD4:  MOVWF  x56
02DD6:  MOVLB  0
02DD8:  CALL   18DC
....................    }
02DDC:  BRA    2ECC
02DDE:  MOVLB  5
....................    else if( (g_Batt_Volts <= 380l) && (g_Batt_Volts > 370l) && (Batt_Level !=80) )
02DE0:  MOVF   x1A,W
02DE2:  SUBLW  01
02DE4:  BNC   2E16
02DE6:  BNZ   2DEE
02DE8:  MOVF   x19,W
02DEA:  SUBLW  7C
02DEC:  BNC   2E16
02DEE:  MOVF   x1A,W
02DF0:  SUBLW  00
02DF2:  BC    2E16
02DF4:  XORLW  FF
02DF6:  BNZ   2DFE
02DF8:  MOVF   x19,W
02DFA:  SUBLW  72
02DFC:  BC    2E16
02DFE:  MOVF   x46,W
02E00:  SUBLW  50
02E02:  BZ    2E16
....................    {
....................         Batt_Level = 80;
02E04:  MOVLW  50
02E06:  MOVWF  x46
....................         Draw_Three_Quart_Battery(HAND);
02E08:  MOVLW  01
02E0A:  MOVWF  x56
02E0C:  MOVLB  0
02E0E:  CALL   151C
....................    }
02E12:  BRA    2ECC
02E14:  MOVLB  5
....................    else if( (g_Batt_Volts <= 370l) && (g_Batt_Volts > 360l) && (Batt_Level !=60) )
02E16:  MOVF   x1A,W
02E18:  SUBLW  01
02E1A:  BNC   2E4C
02E1C:  BNZ   2E24
02E1E:  MOVF   x19,W
02E20:  SUBLW  72
02E22:  BNC   2E4C
02E24:  MOVF   x1A,W
02E26:  SUBLW  00
02E28:  BC    2E4C
02E2A:  XORLW  FF
02E2C:  BNZ   2E34
02E2E:  MOVF   x19,W
02E30:  SUBLW  68
02E32:  BC    2E4C
02E34:  MOVF   x46,W
02E36:  SUBLW  3C
02E38:  BZ    2E4C
....................    {
....................         Batt_Level = 60;
02E3A:  MOVLW  3C
02E3C:  MOVWF  x46
....................         Draw_Half_Battery(HAND);
02E3E:  MOVLW  01
02E40:  MOVWF  x56
02E42:  MOVLB  0
02E44:  CALL   1160
....................    }      
02E48:  BRA    2ECC
02E4A:  MOVLB  5
....................     else if( (g_Batt_Volts <= 360l) && (g_Batt_Volts > 350l) && (Batt_Level !=40) )
02E4C:  MOVF   x1A,W
02E4E:  SUBLW  01
02E50:  BNC   2E82
02E52:  BNZ   2E5A
02E54:  MOVF   x19,W
02E56:  SUBLW  68
02E58:  BNC   2E82
02E5A:  MOVF   x1A,W
02E5C:  SUBLW  00
02E5E:  BC    2E82
02E60:  XORLW  FF
02E62:  BNZ   2E6A
02E64:  MOVF   x19,W
02E66:  SUBLW  5E
02E68:  BC    2E82
02E6A:  MOVF   x46,W
02E6C:  SUBLW  28
02E6E:  BZ    2E82
....................    {
....................         Batt_Level = 40;
02E70:  MOVLW  28
02E72:  MOVWF  x46
....................         Draw_Quart_Battery(HAND);
02E74:  MOVLW  01
02E76:  MOVWF  x56
02E78:  MOVLB  0
02E7A:  CALL   0DA4
....................    }       
02E7E:  BRA    2ECC
02E80:  MOVLB  5
....................     else if( (g_Batt_Volts <= 350l) && (g_Batt_Volts > 340l) && (Batt_Level !=20) )
02E82:  MOVF   x1A,W
02E84:  SUBLW  01
02E86:  BNC   2EB6
02E88:  BNZ   2E90
02E8A:  MOVF   x19,W
02E8C:  SUBLW  5E
02E8E:  BNC   2EB6
02E90:  MOVF   x1A,W
02E92:  SUBLW  00
02E94:  BC    2EB6
02E96:  XORLW  FF
02E98:  BNZ   2EA0
02E9A:  MOVF   x19,W
02E9C:  SUBLW  54
02E9E:  BC    2EB6
02EA0:  MOVF   x46,W
02EA2:  SUBLW  14
02EA4:  BZ    2EB6
....................    {
....................         Batt_Level = 20;
02EA6:  MOVLW  14
02EA8:  MOVWF  x46
....................         Draw_Empty_Battery(HAND);
02EAA:  MOVLW  01
02EAC:  MOVWF  x56
02EAE:  MOVLB  0
02EB0:  RCALL  29FA
....................    }             
02EB2:  BRA    2ECC
02EB4:  MOVLB  5
....................    else if(g_Batt_Volts < 340l)  //if dead battert 
02EB6:  MOVF   x1A,W
02EB8:  SUBLW  01
02EBA:  BNC   2ECE
02EBC:  BNZ   2EC4
02EBE:  MOVF   x19,W
02EC0:  SUBLW  53
02EC2:  BNC   2ECE
....................    {
....................         Draw_Empty_Battery(HAND);
02EC4:  MOVLW  01
02EC6:  MOVWF  x56
02EC8:  MOVLB  0
02ECA:  RCALL  29FA
02ECC:  MOVLB  5
....................     }
02ECE:  MOVLB  0
02ED0:  RETURN 0
....................     
....................     //fprintf(DEBUG,"\n\r %lu, %u", g_Batt_Volts, Batt_Level);
....................   
....................  }   
.................... 
.................... 
.................... /******************************************************************************
.................... *
.................... * FUNCTION     : Update_Handset_Battery(void)
.................... * INPUTS       : Handset battery voltage
.................... * OUTPUTS      : none
.................... * RETURNS      : none
.................... * DESCRIPTION  : Convert battery voltage to levels and display 
.................... /*****************************************************************************/
.................... 
.................... /**
....................     Measure handset battery voltage and current. Update handset battery icon
....................     Battery voltage is scaled down by 2 across BT link
.................... **/
.................... void    Update_Handset_Battery_VI(void)
.................... {
....................     float ftemp;
....................        
....................     set_adc_channel(BATT_V);  //set ADC channel
*
00A74:  MOVLW  01
00A76:  MOVLB  3E
00A78:  MOVWF  xF1
....................     delay_us(100);
00A7A:  MOVLW  64
00A7C:  MOVLB  5
00A7E:  MOVWF  x5A
00A80:  MOVLB  0
00A82:  RCALL  08E2
....................     ftemp= (float)read_adc();
00A84:  MOVLB  3E
00A86:  BSF    xF8.0
00A88:  NOP   
00A8A:  BTFSC  xF8.0
00A8C:  BRA    0A8A
00A8E:  MOVFFL 3EF0,02
00A94:  MOVFFL 3EEF,01
00A9A:  RRCF   02,W
00A9C:  MOVWF  03
00A9E:  RRCF   01,W
00AA0:  MOVWF  02
00AA2:  RRCF   03,F
00AA4:  RRCF   02,F
00AA6:  MOVLW  3F
00AA8:  ANDWF  03,F
00AAA:  MOVFF  02,55A
00AAE:  MOVFF  03,55B
00AB2:  MOVLB  0
00AB4:  RCALL  0906
00AB6:  MOVFF  03,559
00ABA:  MOVFF  02,558
00ABE:  MOVFF  01,557
00AC2:  MOVFF  00,556
....................     g_Batt_Volts = (long)(ftemp * 0.59) ;   //100x battery voltage, 0.00293V/lsb * 2(scale) * 100 = 0.586
00AC6:  MOVFF  559,55D
00ACA:  MOVFF  558,55C
00ACE:  MOVFF  557,55B
00AD2:  MOVFF  556,55A
00AD6:  MOVLW  3D
00AD8:  MOVLB  5
00ADA:  MOVWF  x61
00ADC:  MOVLW  0A
00ADE:  MOVWF  x60
00AE0:  MOVLW  17
00AE2:  MOVWF  x5F
00AE4:  MOVLW  7E
00AE6:  MOVWF  x5E
00AE8:  MOVLB  0
00AEA:  RCALL  093C
00AEC:  MOVFF  03,55D
00AF0:  MOVFF  02,55C
00AF4:  MOVFF  01,55B
00AF8:  MOVFF  00,55A
00AFC:  RCALL  0A38
00AFE:  MOVFF  02,51A
00B02:  MOVFF  01,519
.................... 
....................  
....................     set_adc_channel(BATT_I);  //set ADC channel
00B06:  MOVLB  3E
00B08:  CLRF   xF1
....................     delay_us(100);
00B0A:  MOVLW  64
00B0C:  MOVLB  5
00B0E:  MOVWF  x5A
00B10:  MOVLB  0
00B12:  RCALL  08E2
....................     ftemp= (float)read_adc();
00B14:  MOVLB  3E
00B16:  BSF    xF8.0
00B18:  NOP   
00B1A:  BTFSC  xF8.0
00B1C:  BRA    0B1A
00B1E:  MOVFFL 3EF0,02
00B24:  MOVFFL 3EEF,01
00B2A:  RRCF   02,W
00B2C:  MOVWF  03
00B2E:  RRCF   01,W
00B30:  MOVWF  02
00B32:  RRCF   03,F
00B34:  RRCF   02,F
00B36:  MOVLW  3F
00B38:  ANDWF  03,F
00B3A:  MOVFF  02,55A
00B3E:  MOVFF  03,55B
00B42:  MOVLB  0
00B44:  RCALL  0906
00B46:  MOVFF  03,559
00B4A:  MOVFF  02,558
00B4E:  MOVFF  01,557
00B52:  MOVFF  00,556
....................     g_Batt_Amps = (long)(ftemp * 2.93);   //0.00293/lsb x 1000mA/V= 2.93
00B56:  MOVFF  559,55D
00B5A:  MOVFF  558,55C
00B5E:  MOVFF  557,55B
00B62:  MOVFF  556,55A
00B66:  MOVLW  1F
00B68:  MOVLB  5
00B6A:  MOVWF  x61
00B6C:  MOVLW  85
00B6E:  MOVWF  x60
00B70:  MOVLW  3B
00B72:  MOVWF  x5F
00B74:  MOVLW  80
00B76:  MOVWF  x5E
00B78:  MOVLB  0
00B7A:  RCALL  093C
00B7C:  MOVFF  03,55D
00B80:  MOVFF  02,55C
00B84:  MOVFF  01,55B
00B88:  MOVFF  00,55A
00B8C:  RCALL  0A38
00B8E:  MOVFF  02,51C
00B92:  MOVFF  01,51B
00B96:  RETURN 0
.................... 
....................    // fprintf(DEBUG,"\n\r g_BatI=%lu, batV = %lu", g_Batt_Amps, g_Batt_Volts);
....................  }
.................... 
.................... 
.................... /**
.................... This routine reads the state of the ON/OFF button and the Start and Stop button
.................... The button signal is low when the button is pushed. Pressing the button while
.................... the device is on will turn the device off after reamping down the pressure
.................... **/
.................... void  Check_Buttons(void)
.................... {
....................     uint8_t  ButtonLevel2 ;   
....................     static uint8_t   LastButton2=1; 
.................... 
....................     // Now check the start /stop button
....................     ButtonLevel2 =   input(BUTTON2);  //get current button level, low if pressed
*
05910:  BSF    3FC3.1
05912:  MOVLB  5
05914:  CLRF   x56
05916:  BTFSC  3FCB.1
05918:  INCF   x56,F
....................  
....................     if((ButtonLevel2) && (!LastButton2))   //while button is pushed
0591A:  MOVF   x56,F
0591C:  BZ    5924
0591E:  MOVF   x47,F
05920:  BNZ   5924
....................      {
....................         bit_set(g_FLags,BUTTON_FLG);
05922:  BSF    x0E.4
....................      }
....................     LastButton2 =  ButtonLevel2 ;
05924:  MOVFF  556,547
05928:  MOVLB  0
0592A:  GOTO   7702 (RETURN)
.................... }
.................... 
.................... /**
.................... 
.................... **/
.................... void    Read_Button(void)
.................... {
....................       bit_clear(g_Flags, BUTTON_FLG);
*
063F2:  MOVLB  5
063F4:  BCF    x0E.4
....................       
....................       if(g_Mode == ON)
063F6:  DECFSZ x12,W
063F8:  BRA    641E
....................        {
....................             g_Mode = OFF;
063FA:  CLRF   x12
....................             fprintf(DEBUG,"\n\r OFF");
063FC:  MOVLW  A8
063FE:  MOVWF  3FF6
06400:  MOVLW  04
06402:  MOVWF  3FF7
06404:  MOVLW  00
06406:  MOVWF  3FF8
06408:  CLRF   1B
0640A:  BTFSC  3FD2.7
0640C:  BSF    1B.7
0640E:  BCF    3FD2.7
06410:  MOVLB  0
06412:  CALL   04D0
06416:  BTFSC  1B.7
06418:  BSF    3FD2.7
....................        }
0641A:  BRA    6440
0641C:  MOVLB  5
....................        else
....................        {
....................             g_Mode = ON;
0641E:  MOVLW  01
06420:  MOVWF  x12
....................             fprintf(DEBUG,"\n\r ON");
06422:  MOVLW  B0
06424:  MOVWF  3FF6
06426:  MOVLW  04
06428:  MOVWF  3FF7
0642A:  MOVLW  00
0642C:  MOVWF  3FF8
0642E:  CLRF   1B
06430:  BTFSC  3FD2.7
06432:  BSF    1B.7
06434:  BCF    3FD2.7
06436:  MOVLB  0
06438:  CALL   04D0
0643C:  BTFSC  1B.7
0643E:  BSF    3FD2.7
....................        }
06440:  GOTO   6482 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
....................  /**
....................     Generate 10ms interupt for system heartbeatt
....................  **/
.................... #INT_TIMER1
.................... void  TIMER1_isr(void) 
*
004B6:  MOVLB  0
.................... {
....................     static int8 count;
....................     
....................    // output_high(Pin_A4);
....................   //  delay_us(5);
....................   //output_low(Pin_A4);
....................    
....................     set_timer1(55550);      //10msec interrupt
004B8:  MOVLW  D8
004BA:  MOVWF  3FB1
004BC:  MOVLW  FE
004BE:  MOVWF  3FB0
004C0:  NOP   
....................     bit_set(g_Flags,TMR1);
004C2:  MOVLB  5
004C4:  BSF    x0E.0
....................  }   
.................... 
004C6:  MOVLB  39
004C8:  BCF    xA4.0
004CA:  MOVLB  0
004CC:  GOTO   005A
.................... #INT_EXT
.................... void  EXT_isr(void) 
*
0050C:  MOVLB  0
.................... {
....................     //clear_interrupt(int_EXT); 
....................     // bit_set(g_Flags,INT_FLG); 
....................      fprintf(DEBUG,"\n\r Sleep now");
0050E:  MOVLW  2C
00510:  MOVWF  3FF6
00512:  MOVLW  05
00514:  MOVWF  3FF7
00516:  MOVLW  00
00518:  MOVWF  3FF8
0051A:  RCALL  04D0
....................      output_low(ENB_VCC); //disable power
0051C:  BCF    3FC2.5
0051E:  BCF    3FBA.5
....................      while(1) {}  //wait till dead
00520:  BRA    0520
00522:  MOVLB  39
00524:  BCF    xA1.0
00526:  MOVLB  0
00528:  GOTO   005A
.................... }
.................... 
.................... 
.................... 
.................... /**
.................... void Check_BLE(void)
.................... 
.................... Called once a second from Tasks()
.................... **/
.................... void Check_BLE(void)
.................... {
....................     if(g_Head_Batt_Volts == 0)    //if no battery voltage =  not paired
*
06106:  MOVLB  5
06108:  MOVF   x1D,F
0610A:  BNZ   6114
0610C:  MOVF   x1E,F
0610E:  BNZ   6114
....................     {
....................          g_BLE_Logo = 0; //then turn off
06110:  CLRF   x10
....................     }
06112:  BRA    6118
....................     else
....................     {
....................         g_BLE_Logo = 1;    
06114:  MOVLW  01
06116:  MOVWF  x10
....................     }
....................     Draw_BLE(); //update BLE logo
06118:  MOVLB  0
0611A:  BRA    592E
0611C:  GOTO   644C (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /**
.................... Battery charger function 
....................     Battery PWM range is 100 to 240. Reducing PWM value increase charge voltage
....................     Start with constant curent then constant voltage till current level reaches minimum
.................... **/
.................... void    Charge_Battery(void)
.................... {
....................     static uint16_t Batt_PWM = PWM_MAX;
....................     static uint16_t    Amps_Offset;
....................     static uint16_t  Charge_Time;
....................     static uint8_t   Charge_State = INIT_CHARGE;
....................     static uint8_t   Bars;
.................... 
....................     if(!Input(CHRGR_ON))  //if charger is not attached
*
01CA2:  BSF    3FC2.2
01CA4:  BTFSC  3FCA.2
01CA6:  BRA    1CBE
....................     {
....................         Charge_State = INIT_CHARGE; //reset charge state
01CA8:  MOVLB  5
01CAA:  CLRF   x4F
....................         set_pwm1_duty(Batt_PWM);   //turn off charger PWM
01CAC:  MOVFFL 54A,3F7D
01CB2:  MOVFFL 549,3F7C
....................         Bars = 0;
01CB8:  CLRF   x50
....................     }
01CBA:  BRA    1F62
01CBC:  MOVLB  0
....................     else    //charger is attached
....................     {
....................        // fprintf(DEBUG,"\n\r %u, %lu , %lu, %lu, ", Charge_State, Batt_PWM,  g_Batt_Volts, g_Batt_Amps);
....................        // g_NoActivity = 0;   //clear counter to prevent no activity shutdown
....................                       
....................         switch (Charge_State)
01CBE:  MOVLB  5
01CC0:  MOVF   x4F,W
01CC2:  XORLW  00
01CC4:  MOVLB  0
01CC6:  BZ    1CDA
01CC8:  XORLW  01
01CCA:  BZ    1CF6
01CCC:  XORLW  03
01CCE:  BTFSC  3FD8.2
01CD0:  BRA    1D7E
01CD2:  XORLW  01
01CD4:  BTFSC  3FD8.2
01CD6:  BRA    1DF4
01CD8:  BRA    1E06
....................         {
....................             case INIT_CHARGE:
....................                 Batt_PWM = PWM_MAX; //initialize. 
01CDA:  MOVLW  01
01CDC:  MOVLB  5
01CDE:  MOVWF  x4A
01CE0:  MOVLW  9C
01CE2:  MOVWF  x49
....................                 Charge_Time = 0;
01CE4:  CLRF   x4E
01CE6:  CLRF   x4D
....................                 Charge_State = CC;
01CE8:  MOVLW  01
01CEA:  MOVWF  x4F
....................                 Bars = 0;
01CEC:  CLRF   x50
....................                 Amps_Offset = 60;   //g_Batt_Amps;  //get offset amps level
01CEE:  CLRF   x4C
01CF0:  MOVLW  3C
01CF2:  MOVWF  x4B
....................                // fprintf(DEBUG,"\n\r %lu,", Amps_Offset);
....................                 break;
01CF4:  BRA    1E08
....................                 
....................             case CC:    //constant current mode
....................                 
....................                 if(g_Batt_Amps >= Amps_Offset)  //correct current for offset
01CF6:  MOVLB  5
01CF8:  MOVF   x4C,W
01CFA:  SUBWF  x1C,W
01CFC:  BNC   1D10
01CFE:  BNZ   1D06
01D00:  MOVF   x4B,W
01D02:  SUBWF  x1B,W
01D04:  BNC   1D10
....................                     g_Batt_Amps =  g_Batt_Amps - Amps_Offset;
01D06:  MOVF   x4B,W
01D08:  SUBWF  x1B,F
01D0A:  MOVF   x4C,W
01D0C:  SUBWFB x1C,F
01D0E:  BRA    1D14
....................                 else
....................                     g_Batt_Amps = 0;
01D10:  CLRF   x1C
01D12:  CLRF   x1B
....................   
....................                 if(g_Batt_Amps < CC_AMPS -1L)  //&& (g_Batt_Volts <= FULL_BATT) )
01D14:  MOVF   x1C,F
01D16:  BNZ   1D32
01D18:  MOVF   x1B,W
01D1A:  SUBLW  DA
01D1C:  BNC   1D32
....................                 {
....................                     if(Batt_PWM > PWM_MIN)
01D1E:  MOVF   x4A,F
01D20:  BNZ   1D28
01D22:  MOVF   x49,W
01D24:  SUBLW  1E
01D26:  BC    1D30
....................                     {
....................                         Batt_PWM -=2;   //reduce PWM, inrease charge voltage
01D28:  MOVLW  02
01D2A:  SUBWF  x49,F
01D2C:  MOVLW  00
01D2E:  SUBWFB x4A,F
....................                     }    
....................                 }
01D30:  BRA    1D42
....................                 else if(g_Batt_Amps > CC_AMPS +5L)
01D32:  MOVF   x1C,F
01D34:  BNZ   1D3C
01D36:  MOVF   x1B,W
01D38:  SUBLW  E1
01D3A:  BC    1D42
....................                 {
....................                     Batt_PWM++;     //increase duty cycle, reduce charge voltage
01D3C:  INCF   x49,F
01D3E:  BTFSC  3FD8.2
01D40:  INCF   x4A,F
....................                 }
....................                 
....................                 //if at full voltage or time out or  at max charge voltage
....................                 if( (g_Batt_Volts >=  FULL_BATT) || (Charge_Time > CC_TIME) || (Batt_PWM <= PWM_MIN) )  
01D42:  MOVF   x1A,W
01D44:  SUBLW  00
01D46:  BC    1D52
01D48:  XORLW  FF
01D4A:  BNZ   1D6C
01D4C:  MOVF   x19,W
01D4E:  SUBLW  99
01D50:  BNC   1D6C
01D52:  MOVF   x4E,W
01D54:  SUBLW  1B
01D56:  BC    1D62
01D58:  XORLW  FF
01D5A:  BNZ   1D6C
01D5C:  MOVF   x4D,W
01D5E:  SUBLW  20
01D60:  BNC   1D6C
01D62:  MOVF   x4A,F
01D64:  BNZ   1D76
01D66:  MOVF   x49,W
01D68:  SUBLW  1E
01D6A:  BNC   1D76
....................                 {
....................                     Charge_State = CV;    //change to CV state
01D6C:  MOVLW  02
01D6E:  MOVWF  x4F
....................                     Charge_Time = 0;      //reset safety timer
01D70:  CLRF   x4E
01D72:  CLRF   x4D
....................                 }
01D74:  BRA    1D7C
....................                 else
....................                 {
....................                      Charge_Time++;    //increment timer 
01D76:  INCF   x4D,F
01D78:  BTFSC  3FD8.2
01D7A:  INCF   x4E,F
....................                 }
....................                 break;
01D7C:  BRA    1E08
....................         
....................             case CV:    //constant voltage
....................              
....................                 if(g_Batt_Volts >  FULL_BATT)
01D7E:  MOVLB  5
01D80:  MOVF   x1A,W
01D82:  SUBLW  00
01D84:  BC    1D96
01D86:  XORLW  FF
01D88:  BNZ   1D90
01D8A:  MOVF   x19,W
01D8C:  SUBLW  9A
01D8E:  BC    1D96
....................                 {
....................                    Batt_PWM++;  //decrase charge voltage
01D90:  INCF   x49,F
01D92:  BTFSC  3FD8.2
01D94:  INCF   x4A,F
....................                 }
....................                 
....................                 //if at end current or at end of 2 hours
....................                 if( (g_Batt_Amps <= END_AMPS) || (Charge_Time > MAX_TIME) || (g_Batt_Volts >=  FULL_BATT   ))  
01D96:  MOVF   x1C,F
01D98:  BNZ   1DA0
01D9A:  MOVF   x1B,W
01D9C:  SUBLW  64
01D9E:  BC    1DC0
01DA0:  MOVF   x4E,W
01DA2:  SUBLW  1B
01DA4:  BC    1DB0
01DA6:  XORLW  FF
01DA8:  BNZ   1DC0
01DAA:  MOVF   x4D,W
01DAC:  SUBLW  20
01DAE:  BNC   1DC0
01DB0:  MOVF   x1A,W
01DB2:  SUBLW  00
01DB4:  BC    1DEC
01DB6:  XORLW  FF
01DB8:  BNZ   1DC0
01DBA:  MOVF   x19,W
01DBC:  SUBLW  99
01DBE:  BC    1DEC
....................                 {
....................                     Charge_State = FULL;    //change state
01DC0:  MOVLW  03
01DC2:  MOVWF  x4F
....................                     fprintf(DEBUG,"\n\r Full");
01DC4:  MOVLW  3A
01DC6:  MOVWF  3FF6
01DC8:  MOVLW  05
01DCA:  MOVWF  3FF7
01DCC:  MOVLW  00
01DCE:  MOVWF  3FF8
01DD0:  CLRF   1B
01DD2:  BTFSC  3FD2.7
01DD4:  BSF    1B.7
01DD6:  BCF    3FD2.7
01DD8:  MOVLB  0
01DDA:  CALL   04D0
01DDE:  BTFSC  1B.7
01DE0:  BSF    3FD2.7
....................                     Batt_PWM = PWM_MAX;
01DE2:  MOVLW  01
01DE4:  MOVLB  5
01DE6:  MOVWF  x4A
01DE8:  MOVLW  9C
01DEA:  MOVWF  x49
....................                 } 
....................                 Charge_Time++;    //increment timer
01DEC:  INCF   x4D,F
01DEE:  BTFSC  3FD8.2
01DF0:  INCF   x4E,F
....................               
....................                 break;
01DF2:  BRA    1E08
....................             
....................             case FULL:  //full tank, leave blue LED on
....................                 Batt_PWM = PWM_MAX;
01DF4:  MOVLW  01
01DF6:  MOVLB  5
01DF8:  MOVWF  x4A
01DFA:  MOVLW  9C
01DFC:  MOVWF  x49
....................                  output_high(LED1); 
01DFE:  BCF    3FC2.6
01E00:  BSF    3FBA.6
....................                  break;
01E02:  BRA    1E08
01E04:  MOVLB  0
....................                 
....................             default:
....................                 break;
01E06:  MOVLB  5
....................         }
.................... 
....................        set_pwm1_duty(Batt_PWM);   //update PWM output
01E08:  MOVFFL 54A,3F7D
01E0E:  MOVFFL 549,3F7C
....................        fprintf(DEBUG,"\n\r %u, %lu , %lu, %lu, %lu ", Charge_State, Batt_PWM,  g_Batt_Volts, g_Batt_Amps, Amps_Offset);
01E14:  MOVLW  42
01E16:  MOVWF  3FF6
01E18:  MOVLW  05
01E1A:  MOVWF  3FF7
01E1C:  MOVLW  00
01E1E:  MOVWF  3FF8
01E20:  MOVLW  03
01E22:  MOVWF  x57
01E24:  MOVLB  0
01E26:  CALL   0B98
01E2A:  MOVFF  54F,557
01E2E:  MOVLW  1B
01E30:  MOVLB  5
01E32:  MOVWF  x58
01E34:  MOVLB  0
01E36:  CALL   0C06
01E3A:  MOVLW  2C
01E3C:  MOVLB  39
01E3E:  BTFSS  xA6.3
01E40:  BRA    1E3E
01E42:  MOVLB  3D
01E44:  MOVWF  xD2
01E46:  MOVLW  20
01E48:  MOVLB  39
01E4A:  BTFSS  xA6.3
01E4C:  BRA    1E4A
01E4E:  MOVLB  3D
01E50:  MOVWF  xD2
01E52:  MOVLW  10
01E54:  MOVWF  3FE9
01E56:  MOVFF  54A,557
01E5A:  MOVFF  549,556
01E5E:  MOVLB  0
01E60:  CALL   0C92
01E64:  MOVLW  4C
01E66:  MOVWF  3FF6
01E68:  MOVLW  05
01E6A:  MOVWF  3FF7
01E6C:  MOVLW  00
01E6E:  MOVWF  3FF8
01E70:  MOVLW  03
01E72:  MOVLB  5
01E74:  MOVWF  x57
01E76:  MOVLB  0
01E78:  CALL   0B98
01E7C:  MOVLW  10
01E7E:  MOVWF  3FE9
01E80:  MOVFF  51A,557
01E84:  MOVFF  519,556
01E88:  CALL   0C92
01E8C:  MOVLW  2C
01E8E:  MOVLB  39
01E90:  BTFSS  xA6.3
01E92:  BRA    1E90
01E94:  MOVLB  3D
01E96:  MOVWF  xD2
01E98:  MOVLW  20
01E9A:  MOVLB  39
01E9C:  BTFSS  xA6.3
01E9E:  BRA    1E9C
01EA0:  MOVLB  3D
01EA2:  MOVWF  xD2
01EA4:  MOVLW  10
01EA6:  MOVWF  3FE9
01EA8:  MOVFF  51C,557
01EAC:  MOVFF  51B,556
01EB0:  MOVLB  0
01EB2:  CALL   0C92
01EB6:  MOVLW  2C
01EB8:  MOVLB  39
01EBA:  BTFSS  xA6.3
01EBC:  BRA    1EBA
01EBE:  MOVLB  3D
01EC0:  MOVWF  xD2
01EC2:  MOVLW  20
01EC4:  MOVLB  39
01EC6:  BTFSS  xA6.3
01EC8:  BRA    1EC6
01ECA:  MOVLB  3D
01ECC:  MOVWF  xD2
01ECE:  MOVLW  10
01ED0:  MOVWF  3FE9
01ED2:  MOVFF  54C,557
01ED6:  MOVFF  54B,556
01EDA:  MOVLB  0
01EDC:  CALL   0C92
01EE0:  MOVLW  20
01EE2:  MOVLB  39
01EE4:  BTFSS  xA6.3
01EE6:  BRA    1EE4
01EE8:  MOVLB  3D
01EEA:  MOVWF  xD2
....................        
....................        if(Charge_State != FULL)
01EEC:  MOVLB  5
01EEE:  MOVF   x4F,W
01EF0:  SUBLW  03
01EF2:  BZ    1F56
....................        {
....................            switch(Bars)
01EF4:  MOVF   x50,W
01EF6:  XORLW  00
01EF8:  MOVLB  0
01EFA:  BZ    1F0A
01EFC:  XORLW  01
01EFE:  BZ    1F1C
01F00:  XORLW  03
01F02:  BZ    1F2E
01F04:  XORLW  01
01F06:  BZ    1F40
01F08:  BRA    1F52
....................            {
....................       
....................             case 0: //quarter full
....................                 Draw_Quart_Battery(HAND);
01F0A:  MOVLW  01
01F0C:  MOVLB  5
01F0E:  MOVWF  x56
01F10:  MOVLB  0
01F12:  CALL   0DA4
....................                 Bars++;
01F16:  MOVLB  5
01F18:  INCF   x50,F
....................                 break;
01F1A:  BRA    1F54
....................     
....................             case 1: //half full
....................                 Draw_Half_Battery(HAND);
01F1C:  MOVLW  01
01F1E:  MOVLB  5
01F20:  MOVWF  x56
01F22:  MOVLB  0
01F24:  CALL   1160
....................                 Bars++;
01F28:  MOVLB  5
01F2A:  INCF   x50,F
....................                 break;
01F2C:  BRA    1F54
....................                 
....................             case 2: //3/4 full    
....................                 Draw_Three_Quart_Battery(HAND);
01F2E:  MOVLW  01
01F30:  MOVLB  5
01F32:  MOVWF  x56
01F34:  MOVLB  0
01F36:  CALL   151C
....................                 Bars++;;
01F3A:  MOVLB  5
01F3C:  INCF   x50,F
....................                 break;
01F3E:  BRA    1F54
....................                 
....................             case 3: //full
....................                 Draw_Full_Battery(HAND);
01F40:  MOVLW  01
01F42:  MOVLB  5
01F44:  MOVWF  x56
01F46:  MOVLB  0
01F48:  RCALL  18DC
....................                 Bars = 0;
01F4A:  MOVLB  5
01F4C:  CLRF   x50
....................                 break;
01F4E:  BRA    1F54
01F50:  MOVLB  0
....................             
....................             default:
....................                 break;
01F52:  MOVLB  5
....................            }
....................        }
01F54:  BRA    1F62
....................        else
....................        {
....................             Draw_Full_Battery(HAND);
01F56:  MOVLW  01
01F58:  MOVWF  x56
01F5A:  MOVLB  0
01F5C:  RCALL  18DC
....................             Bars = 0;
01F5E:  MOVLB  5
01F60:  CLRF   x50
....................        }
....................     }
01F62:  MOVLB  0
01F64:  RETURN 0
....................  }
.................... 
.................... 
.................... 
.................... /**
....................     Perform tasks that need to be performed once a second
.................... **/
.................... void    Tasks(void)
.................... {
....................   if (!input(CHRGR_ON))  //if charger not attached check BLE
*
06444:  BSF    3FC2.2
06446:  BTFSC  3FCA.2
06448:  BRA    644C
....................         Check_BLE();
0644A:  BRA    6106
....................     
....................     Update_Handset_Battery_VI();    //get handset battery VI data
0644C:  CALL   0A74
....................     Update_Handset_Battery_Gauge();
06450:  CALL   2DB6
....................     
....................     Charge_Battery();
06454:  CALL   1CA2
....................     
....................    if(g_Head_Batt_Volts >0)
06458:  MOVLB  5
0645A:  MOVF   x1D,F
0645C:  BNZ   6462
0645E:  MOVF   x1E,F
06460:  BZ    6468
....................         Update_Headset_Battery_Gauge();
06462:  MOVLB  0
06464:  BRA    6120
06466:  MOVLB  5
....................         
....................    if( (g_Mode == ON) && (g_Paired) ) {
06468:  DECFSZ x12,W
0646A:  BRA    647A
0646C:  MOVF   x0F,F
0646E:  BZ    647A
....................        UpdateDisplayTime();
06470:  MOVLB  0
06472:  BRA    637E
....................        Draw_Electrodes();
06474:  CALL   29A2
06478:  MOVLB  5
....................    }
....................    
....................    if(bit_test(g_Flags,BUTTON_FLG))
0647A:  BTFSS  x0E.4
0647C:  BRA    6484
....................         Read_Button();  //check if a button2 has been detected
0647E:  MOVLB  0
06480:  BRA    63F2
06482:  MOVLB  5
06484:  MOVLB  0
06486:  RETURN 0
....................  }
.................... 
.................... 
.................... 
.................... 
.................... /******************************************************************************
.................... *
.................... * FUNCTION     :  UpdateDisplayTime(void)
.................... * INPUTS       : g_State, g_Seconds
.................... * OUTPUTS      : g_TreatmentMinutes, g_TreatmentSeconds
.................... * RETURNS      : none
.................... * DESCRIPTION  : Calculate remaining tretment time by decrementing treatment
....................    seconds. Send updated times to display module
.................... /*****************************************************************************/
....................        
.................... void    UpdateDisplayTime(void)
.................... {
....................     if(g_Seconds)
*
0637E:  MOVLB  5
06380:  MOVF   x17,W
06382:  IORWF  x18,W
06384:  BZ    63CA
....................     {
....................          g_Seconds--;
06386:  MOVF   x17,W
06388:  BTFSC  3FD8.2
0638A:  DECF   x18,F
0638C:  DECF   x17,F
....................          g_TreatMinutes = g_Seconds /60l;
0638E:  MOVFF  518,55B
06392:  MOVFF  517,55A
06396:  CLRF   x5D
06398:  MOVLW  3C
0639A:  MOVWF  x5C
0639C:  MOVLB  0
0639E:  CALL   34BC
063A2:  MOVFF  02,514
063A6:  MOVFF  01,513
....................          g_TreatSeconds = g_Seconds %60;
063AA:  MOVFF  518,55B
063AE:  MOVFF  517,55A
063B2:  MOVLB  5
063B4:  CLRF   x5D
063B6:  MOVLW  3C
063B8:  MOVWF  x5C
063BA:  MOVLB  0
063BC:  CALL   34BC
063C0:  MOVFF  00,515
063C4:  MOVLB  5
063C6:  MOVFF  03,516
....................     }     
....................     
....................     Draw_Colon();
063CA:  MOVLB  0
063CC:  BRA    6236
....................     DisplayTime();  //update displayed time
063CE:  CALL   5854
....................     
....................     If(!g_Seconds)  //it out of treatment time
063D2:  MOVLB  5
063D4:  MOVF   x17,W
063D6:  IORWF  x18,W
063D8:  BNZ   63EC
....................        printf(ble_cmd_putc,"$sleep/#\r");     
063DA:  MOVLW  5E
063DC:  MOVWF  3FF6
063DE:  MOVLW  05
063E0:  MOVWF  3FF7
063E2:  MOVLW  00
063E4:  MOVWF  3FF8
063E6:  MOVLB  0
063E8:  RCALL  6348
063EA:  MOVLB  5
063EC:  MOVLB  0
063EE:  GOTO   6474 (RETURN)
....................     
....................    // fprintf(DEBUG,"\n\r %lu, %lu, %lu", g_Seconds, g_TreatMinutes, g_TreatSeconds);
....................  }
.................... 
.................... 
.................... /**
.................... void    Clocks(void)
....................    Executed every 10msec, this function updates all clocks
.................... 
.................... **/
.................... void    Clocks(void)
.................... {
....................     static uint16_t   tmr1_cntr = 0;   //counts TIMR1 interrupts
....................     tmr1_cntr++;    //inrement it
*
06488:  MOVLB  5
0648A:  INCF   x51,F
0648C:  BTFSC  3FD8.2
0648E:  INCF   x52,F
....................      
....................     if(!(tmr1_cntr % 100)) //if 1000msec seconds have passed
06490:  MOVFF  552,55B
06494:  MOVFF  551,55A
06498:  CLRF   x5D
0649A:  MOVLW  64
0649C:  MOVWF  x5C
0649E:  MOVLB  0
064A0:  CALL   34BC
064A4:  MOVF   00,W
064A6:  IORWF  03,W
064A8:  BNZ   64B6
....................     {
....................         bit_set(g_Flags,SECOND);    //set new second flag
064AA:  MOVLB  5
064AC:  BSF    x0E.1
....................         tmr1_cntr = 0;  //reset counter
064AE:  CLRF   x52
064B0:  CLRF   x51
....................         Tasks();    //do tasks that must be done every second
064B2:  MOVLB  0
064B4:  RCALL  6444
....................     }
064B6:  GOTO   7706 (RETURN)
.................... }
.................... 
.................... 
.................... void init(void) {
.................... 
....................    output_high(ENB_VCC);
*
005D0:  BCF    3FC2.5
005D2:  BSF    3FBA.5
....................    output_high(RST_BLE);
005D4:  BCF    3FC3.5
005D6:  BSF    3FBB.5
....................    output_high(LED1);
005D8:  BCF    3FC2.6
005DA:  BSF    3FBA.6
....................   enable_interrupts(INT_TIMER1);  //10 msec heartbeat for Check_buttons()
005DC:  MOVLB  39
005DE:  BSF    x94.0
....................   enable_interrupts(INT_RDA);
005E0:  BSF    x93.3
....................  //  clear_interrupt(INT_EXT_H2L); //interrupt when power button is pressed
....................   // enable_interrupts(INT_EXT_H2L); //interrupt when power button is pressed
....................   enable_interrupts(GLOBAL);
005E2:  MOVLW  C0
005E4:  IORWF  3FD2,F
005E6:  MOVLB  0
005E8:  GOTO   7620 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... void    Process_Command(void)
.................... {
....................     char  term[6];
....................     char  *pntr;    //fixed 20170728 JPC
....................     uint16_t Time;
.................... 
....................     strcpy(term,"/");
*
073F0:  MOVLW  05
073F2:  MOVWF  3FEA
073F4:  MOVLW  56
073F6:  MOVWF  3FE9
073F8:  MOVLW  00
073FA:  CALL   0086
073FE:  TBLRD*-
07400:  TBLRD*+
07402:  MOVF   3FF5,W
07404:  MOVWF  3FEE
07406:  IORLW  00
07408:  BNZ   7400
....................     pntr = strtok(resp, term);
0740A:  MOVLW  05
0740C:  MOVLB  5
0740E:  MOVWF  x61
07410:  MOVLW  23
07412:  MOVWF  x60
07414:  MOVLW  05
07416:  MOVWF  x63
07418:  MOVLW  56
0741A:  MOVWF  x62
0741C:  MOVLB  0
0741E:  RCALL  6F56
07420:  MOVFF  02,55D
07424:  MOVFF  01,55C
....................     pntr = strtok(0, term);  //get next field
07428:  MOVLB  5
0742A:  CLRF   x61
0742C:  CLRF   x60
0742E:  MOVLW  05
07430:  MOVWF  x63
07432:  MOVLW  56
07434:  MOVWF  x62
07436:  MOVLB  0
07438:  RCALL  6F56
0743A:  MOVFF  02,55D
0743E:  MOVFF  01,55C
....................     g_Contact_Status = atoi(pntr); //which is electrode contact status
07442:  MOVFF  55D,561
07446:  MOVFF  55C,560
0744A:  BRA    700E
0744C:  MOVFF  01,511
....................     pntr = strtok(0, term);  //get next field
07450:  MOVLB  5
07452:  CLRF   x61
07454:  CLRF   x60
07456:  MOVLW  05
07458:  MOVWF  x63
0745A:  MOVLW  56
0745C:  MOVWF  x62
0745E:  MOVLB  0
07460:  RCALL  6F56
07462:  MOVFF  02,55D
07466:  MOVFF  01,55C
....................     g_Head_Batt_Volts = atol(pntr); //which is headset battery voltage 
0746A:  MOVFF  55D,561
0746E:  MOVFF  55C,560
07472:  RCALL  720A
07474:  MOVFF  02,51E
07478:  MOVFF  01,51D
....................     pntr = strtok(0, term);  //get next field
0747C:  MOVLB  5
0747E:  CLRF   x61
07480:  CLRF   x60
07482:  MOVLW  05
07484:  MOVWF  x63
07486:  MOVLW  56
07488:  MOVWF  x62
0748A:  MOVLB  0
0748C:  RCALL  6F56
0748E:  MOVFF  02,55D
07492:  MOVFF  01,55C
....................     Time = atol(pntr); //which is headset battery voltage 
07496:  MOVFF  55D,561
0749A:  MOVFF  55C,560
0749E:  RCALL  720A
074A0:  MOVFF  02,55F
074A4:  MOVFF  01,55E
074A8:  GOTO   7804 (RETURN)
....................   //  fprintf(DEBUG,"\n\r %u, %lu, %lu", g_Contact_Status, g_Head_Batt_Volts,Time);
....................   
.................... }
.................... 
.................... 
.................... 
.................... void main(void) {
074AC:  MOVLB  39
074AE:  BSF    xE5.7
074B0:  BCF    xE5.6
074B2:  CLRF   3FF8
074B4:  BCF    3FD2.5
074B6:  BSF    07.7
074B8:  MOVLB  E
074BA:  MOVLW  55
074BC:  MOVLB  3A
074BE:  MOVWF  xBF
074C0:  MOVLW  AA
074C2:  MOVWF  xBF
074C4:  BCF    xBF.0
074C6:  MOVLW  17
074C8:  MOVWF  xE5
074CA:  MOVLW  0C
074CC:  MOVWF  xE8
074CE:  MOVLW  16
074D0:  MOVWF  x0B
074D2:  MOVLW  09
074D4:  MOVWF  x12
074D6:  MOVLW  13
074D8:  MOVWF  x16
074DA:  MOVLW  55
074DC:  MOVWF  xBF
074DE:  MOVLW  AA
074E0:  MOVWF  xBF
074E2:  BSF    xBF.0
074E4:  MOVLB  39
074E6:  CLRF   xDE
074E8:  CLRF   xDB
074EA:  CLRF   xDD
074EC:  MOVLW  06
074EE:  MOVWF  xDF
074F0:  MOVLW  60
074F2:  MOVWF  xD9
074F4:  MOVLB  3D
074F6:  BCF    xDB.7
074F8:  BCF    3FC3.3
074FA:  BSF    3FBB.3
074FC:  MOVLW  B0
074FE:  MOVWF  xDA
07500:  CLRF   xDE
07502:  MOVLW  44
07504:  MOVWF  xDD
07506:  CLRF   xDC
07508:  BSF    xDB.7
0750A:  CLRF   22
0750C:  BCF    xF3.7
0750E:  BCF    3FC4.6
07510:  BSF    3FBC.6
07512:  MOVLW  B0
07514:  MOVWF  xF2
07516:  MOVLW  03
07518:  MOVWF  xF6
0751A:  MOVLW  40
0751C:  MOVWF  xF5
0751E:  CLRF   xF4
07520:  BSF    xF3.7
07522:  BCF    23.0
07524:  BCF    23.1
07526:  MOVLB  0
07528:  CLRF   xA4
0752A:  CLRF   xA5
0752C:  BCF    23.2
0752E:  MOVLW  FE
07530:  MOVWF  xE6
07532:  CLRF   xE7
07534:  MOVLB  5
07536:  CLRF   x09
07538:  CLRF   x08
0753A:  CLRF   x0F
0753C:  CLRF   x10
0753E:  CLRF   x11
07540:  CLRF   x12
07542:  CLRF   x14
07544:  MOVLW  28
07546:  MOVWF  x13
07548:  CLRF   x16
0754A:  CLRF   x15
0754C:  MOVLW  09
0754E:  MOVWF  x18
07550:  MOVLW  60
07552:  MOVWF  x17
07554:  CLRF   x1A
07556:  CLRF   x19
07558:  CLRF   x1C
0755A:  CLRF   x1B
0755C:  CLRF   x1E
0755E:  CLRF   x1D
07560:  CLRF   x21
07562:  MOVLB  3A
07564:  CLRF   x40
07566:  CLRF   x50
07568:  CLRF   x60
0756A:  CLRF   x70
0756C:  CLRF   x80
0756E:  MOVLB  3E
07570:  CLRF   xBD
07572:  CLRF   xBE
07574:  CLRF   xBF
07576:  CLRF   xBC
07578:  CLRF   xB9
0757A:  CLRF   xBA
0757C:  CLRF   xBB
0757E:  CLRF   xB8
07580:  CLRF   1C
07582:  CLRF   1D
07584:  MOVLB  5
07586:  CLRF   x0C
07588:  CLRF   x0D
0758A:  MOVLW  04
0758C:  MOVWF  x43
0758E:  CLRF   x44
07590:  CLRF   x45
07592:  CLRF   x46
07594:  MOVLW  01
07596:  MOVWF  x47
07598:  CLRF   x48
0759A:  MOVLW  9C
0759C:  MOVWF  x49
0759E:  MOVLW  01
075A0:  MOVWF  x4A
075A2:  CLRF   x4B
075A4:  CLRF   x4C
075A6:  CLRF   x4D
075A8:  CLRF   x4E
075AA:  CLRF   x4F
075AC:  CLRF   x50
075AE:  CLRF   x51
075B0:  CLRF   x52
....................  
....................    //char resp[32];
....................    int16 handle;
....................    int1 connected;
....................    connected=FALSE;
075B2:  BCF    x55.0
.................... 
....................      output_high(ENB_VCC);  //allow user to remove finger
075B4:  BCF    3FC2.5
075B6:  BSF    3FBA.5
....................      
....................     setup_adc_ports(sAN0 | sAN1, NO_ANALOGS_P2, VSS_VDD);
075B8:  MOVLW  00
075BA:  MOVLB  3E
075BC:  MOVWF  xFD
075BE:  MOVLW  03
075C0:  MOVLB  3A
075C2:  MOVWF  x40
075C4:  MOVLW  00
075C6:  MOVWF  x50
075C8:  MOVWF  x60
075CA:  MOVWF  x70
075CC:  MOVWF  x80
....................     setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_0 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
075CE:  MOVLW  08
075D0:  MOVLB  3E
075D2:  MOVWF  xFA
075D4:  CLRF   xFB
075D6:  CLRF   xFF
075D8:  CLRF   xF4
075DA:  CLRF   xF3
075DC:  CLRF   xEC
075DE:  MOVLW  94
075E0:  MOVWF  xF8
....................     setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);        //52.4 ms overflow
075E2:  MOVLW  01
075E4:  MOVWF  3FB5
075E6:  MOVLW  37
075E8:  MOVWF  3FB2
075EA:  CLRF   3FB3
075EC:  CLRF   3FB4
....................     setup_timer_2(T2_DIV_BY_1 | T2_CLK_INTERNAL,106,1);        //13.4 us overflow, 13.4 us interrupt
075EE:  CLRF   3FAF
075F0:  CLRF   3FAD
075F2:  MOVLW  01
075F4:  MOVWF  3FAE
075F6:  MOVLW  6A
075F8:  MOVWF  3FAB
075FA:  MOVLW  80
075FC:  MOVWF  3FAC
....................     setup_ccp1(CCP_PWM);
075FE:  BCF    3FC4.2
07600:  BCF    3FBC.2
07602:  BCF    3F7E.7
07604:  MOVLW  0C
07606:  MOVWF  3F7E
07608:  MOVLW  FC
0760A:  MOVLB  3F
0760C:  ANDWF  x5E,F
0760E:  MOVLW  01
07610:  IORWF  x5E,F
07612:  BSF    3F7E.7
....................     set_pwm1_duty((int16)430);  //this value is maximum PWM duty cycle. It generates zero charge voltage
07614:  MOVWF  3F7D
07616:  MOVLW  AE
07618:  MOVWF  3F7C
....................  
....................     init();
0761A:  MOVLB  0
0761C:  GOTO   05D0
....................     Display_Setup();    //configure the display
07620:  GOTO   0658
....................     Display();      //run test pattern
07624:  GOTO   0820
....................    
....................     fprintf(DEBUG," Halo Handset Ver 3\r\n");
07628:  MOVLW  68
0762A:  MOVWF  3FF6
0762C:  MOVLW  05
0762E:  MOVWF  3FF7
07630:  MOVLW  00
07632:  MOVWF  3FF8
07634:  CLRF   1B
07636:  BTFSC  3FD2.7
07638:  BSF    1B.7
0763A:  BCF    3FD2.7
0763C:  CALL   04D0
07640:  BTFSC  1B.7
07642:  BSF    3FD2.7
.................... 
....................     if(input(CHRGR_ON)) 
07644:  BSF    3FC2.2
07646:  BTFSS  3FCA.2
07648:  BRA    7668
....................         fprintf(DEBUG,"\n\r Charger On \n\r");
0764A:  MOVLW  7E
0764C:  MOVWF  3FF6
0764E:  MOVLW  05
07650:  MOVWF  3FF7
07652:  MOVLW  00
07654:  MOVWF  3FF8
07656:  CLRF   1B
07658:  BTFSC  3FD2.7
0765A:  BSF    1B.7
0765C:  BCF    3FD2.7
0765E:  CALL   04D0
07662:  BTFSC  1B.7
07664:  BSF    3FD2.7
07666:  BRA    7684
....................     else 
....................         fprintf(DEBUG,"\n\r Charger Off \n\r");
07668:  MOVLW  90
0766A:  MOVWF  3FF6
0766C:  MOVLW  05
0766E:  MOVWF  3FF7
07670:  MOVLW  00
07672:  MOVWF  3FF8
07674:  CLRF   1B
07676:  BTFSC  3FD2.7
07678:  BSF    1B.7
0767A:  BCF    3FD2.7
0767C:  CALL   04D0
07680:  BTFSC  1B.7
07682:  BSF    3FD2.7
....................    
....................     while(input(CHRGR_ON)) {
07684:  BSF    3FC2.2
07686:  BTFSS  3FCA.2
07688:  BRA    76AC
....................        Update_Handset_Battery_VI();
0768A:  CALL   0A74
....................        Charge_Battery();
0768E:  CALL   1CA2
....................        delay_ms(500);
07692:  MOVLW  02
07694:  MOVLB  5
07696:  MOVWF  x56
07698:  MOVLW  FA
0769A:  MOVWF  xA6
0769C:  MOVLB  0
0769E:  CALL   05EC
076A2:  MOVLB  5
076A4:  DECFSZ x56,F
076A6:  BRA    7698
076A8:  MOVLB  0
076AA:  BRA    7684
....................     }
....................   
....................      
....................     if(!input(CHRGR_ON)) {
076AC:  BSF    3FC2.2
076AE:  BTFSC  3FCA.2
076B0:  BRA    76EC
.................... 
....................         Draw_Electrodes();
076B2:  CALL   29A2
....................         Update_Handset_Battery_VI();
076B6:  CALL   0A74
....................         Update_Handset_Battery_Gauge();
076BA:  CALL   2DB6
....................         Draw_Alert(ON);
076BE:  MOVLW  01
076C0:  MOVLB  5
076C2:  MOVWF  x56
076C4:  MOVLB  0
076C6:  CALL   2ED2
....................         delay_ms(2000);
076CA:  MOVLW  08
076CC:  MOVLB  5
076CE:  MOVWF  x56
076D0:  MOVLW  FA
076D2:  MOVWF  xA6
076D4:  MOVLB  0
076D6:  CALL   05EC
076DA:  MOVLB  5
076DC:  DECFSZ x56,F
076DE:  BRA    76D0
....................         Draw_Alert(OFF);
076E0:  CLRF   x56
076E2:  MOVLB  0
076E4:  CALL   2ED2
....................         DisplayTime();
076E8:  CALL   5854
....................         
....................     }
.................... 
....................   // enable_interrupts(INT_TIMER1);  //10 msec heartbeat for Check_buttons()
....................  //  enable_interrupts(INT_RDA);
....................    clear_interrupt(INT_EXT_H2L); //interrupt when power button is pressed
076EC:  MOVLB  39
076EE:  BCF    xA1.0
....................    enable_interrupts(INT_EXT_H2L); //interrupt when power button is pressed
076F0:  BSF    x91.0
076F2:  BCF    3FD2.0
....................  //  enable_interrupts(GLOBAL);
....................  
....................  
....................    
....................    while(TRUE) {
....................         if(bit_test(g_Flags,TMR1))  //10 msec interrupt
076F4:  MOVLB  5
076F6:  BTFSS  x0E.0
076F8:  BRA    7708
....................         {
....................             bit_clear(g_Flags,TMR1);
076FA:  BCF    x0E.0
....................             Check_Buttons();
076FC:  MOVLB  0
076FE:  GOTO   5910
....................             Clocks();
07702:  GOTO   6488
07706:  MOVLB  5
....................         }    
....................               
....................         if(bit_test(g_Flags,SECOND))  {     //do things once a econd
07708:  BTFSS  x0E.1
0770A:  BRA    7830
....................             bit_clear(g_Flags,SECOND);
0770C:  BCF    x0E.1
....................    
....................             if(!connected) {    //look for BLE connection
0770E:  BTFSC  x55.0
07710:  BRA    772A
....................               handle=ble_start();
07712:  MOVLB  0
07714:  GOTO   6C0C
07718:  MOVFF  02,554
0771C:  MOVFF  01,553
....................               if(handle)
07720:  MOVLB  5
07722:  MOVF   x53,W
07724:  IORWF  x54,W
07726:  BZ    772A
....................                  connected=TRUE;
07728:  BSF    x55.0
....................             }
....................             
....................             fprintf(DEBUG,"\n\r j=%u \n\r", connected);
0772A:  MOVLW  00
0772C:  BTFSC  x55.0
0772E:  MOVLW  01
07730:  MOVWF  x56
07732:  MOVLW  A2
07734:  MOVWF  3FF6
07736:  MOVLW  05
07738:  MOVWF  3FF7
0773A:  MOVLW  00
0773C:  MOVWF  3FF8
0773E:  MOVLW  05
07740:  MOVWF  x57
07742:  MOVLB  0
07744:  CALL   0B98
07748:  MOVFF  556,557
0774C:  MOVLW  1B
0774E:  MOVLB  5
07750:  MOVWF  x58
07752:  MOVLB  0
07754:  CALL   0C06
07758:  MOVLW  A9
0775A:  MOVWF  3FF6
0775C:  MOVLW  05
0775E:  MOVWF  3FF7
07760:  MOVLW  00
07762:  MOVWF  3FF8
07764:  MOVLW  03
07766:  MOVLB  5
07768:  MOVWF  x57
0776A:  MOVLB  0
0776C:  CALL   0B98
....................             
....................             if (connected) {
07770:  MOVLB  5
07772:  BTFSS  x55.0
07774:  BRA    780A
....................                 g_BLE_Activity = 0; //reset counter if connected
07776:  CLRF   x21
....................                g_Paired = TRUE;
07778:  MOVLW  01
0777A:  MOVWF  x0F
....................               
....................                if(g_Mode == ON)
0777C:  DECFSZ x12,W
0777E:  BRA    7794
....................                     printf(ble_cmd_putc,"$on/#\r");
07780:  MOVLW  AE
07782:  MOVWF  3FF6
07784:  MOVLW  05
07786:  MOVWF  3FF7
07788:  MOVLW  00
0778A:  MOVWF  3FF8
0778C:  MOVLB  0
0778E:  CALL   6348
07792:  MOVLB  5
....................                if(g_Mode == OFF)
07794:  MOVF   x12,F
07796:  BNZ   77AC
....................                     printf(ble_cmd_putc,"$off/#\r");
07798:  MOVLW  B6
0779A:  MOVWF  3FF6
0779C:  MOVLW  05
0779E:  MOVWF  3FF7
077A0:  MOVLW  00
077A2:  MOVWF  3FF8
077A4:  MOVLB  0
077A6:  CALL   6348
077AA:  MOVLB  5
....................   
....................                    
....................               ble_gets(resp,sizeof(resp));
077AC:  MOVLW  05
077AE:  MOVWF  x57
077B0:  MOVLW  23
077B2:  MOVWF  x56
077B4:  MOVLW  20
077B6:  MOVWF  x58
077B8:  MOVLB  0
077BA:  GOTO   6D4E
....................               if(resp[0]!=0)
077BE:  MOVLB  5
077C0:  MOVF   x23,F
077C2:  BZ    7800
....................                   fprintf(DEBUG,"Remote Data=%s\r\n",resp); 
077C4:  MOVLW  BE
077C6:  MOVWF  3FF6
077C8:  MOVLW  05
077CA:  MOVWF  3FF7
077CC:  MOVLW  00
077CE:  MOVWF  3FF8
077D0:  MOVLW  0C
077D2:  MOVWF  x57
077D4:  MOVLB  0
077D6:  CALL   0B98
077DA:  MOVLW  05
077DC:  MOVWF  3FEA
077DE:  MOVLW  23
077E0:  MOVWF  3FE9
077E2:  GOTO   6DD6
077E6:  MOVLW  0D
077E8:  MOVLB  39
077EA:  BTFSS  xA6.3
077EC:  BRA    77EA
077EE:  MOVLB  3D
077F0:  MOVWF  xD2
077F2:  MOVLW  0A
077F4:  MOVLB  39
077F6:  BTFSS  xA6.3
077F8:  BRA    77F6
077FA:  MOVLB  3D
077FC:  MOVWF  xD2
077FE:  MOVLB  5
....................               
....................               Process_Command();    //process command from handset
07800:  MOVLB  0
07802:  BRA    73F0
....................               Tasks();  //do tasks that need to be run once a second.      
07804:  CALL   6444
07808:  MOVLB  5
....................                 
....................             }
....................             if(!ble_get_status_resp(resp, 0)) {
0780A:  MOVLW  05
0780C:  MOVWF  xA1
0780E:  MOVLW  23
07810:  MOVWF  xA0
07812:  CLRF   xA3
07814:  CLRF   xA2
07816:  MOVLB  0
07818:  CALL   6A36
0781C:  MOVF   01,F
0781E:  BNZ   7832
....................                //fprintf(DEBUG,"status=%s\r\n",resp); 
....................                if((resp[0]=='D')&&(resp[1]=='I'))
07820:  MOVLB  5
07822:  MOVF   x23,W
07824:  SUBLW  44
07826:  BNZ   7830
07828:  MOVF   x24,W
0782A:  SUBLW  49
0782C:  BNZ   7830
....................                   connected=FALSE;
0782E:  BCF    x55.0
07830:  MOVLB  0
....................            }  
....................            
....................         }    
07832:  MOVLB  39
07834:  BRA    76F4
....................     }
.................... }
.................... 
07836:  SLEEP 

Configuration Fuses:
   Word  1: FFEC   NOEXTOSC RSTOSC_HFINTRC_1MHZ NOCLKOUT PRLOCK1WAY CKS FCMEN
   Word  2: FFF7   MCLR NOPUT NOMVECEN IVT1WAY NOLPBOR BROWNOUT BORV24 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   BBSIZ512 NOBOOTBLOCK NOSAF NOWRT NOWRTB NOWRTC NOWRTD NOWRTSAF NOLVP
   Word  5: FFFF   NOPROTECT

ROM data:
01FFF6: 31 30 30 30 00                                     1000.
01FFFC: 43 30 00                                           C0.
