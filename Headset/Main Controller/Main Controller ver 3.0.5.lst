CCS PCH C Compiler, Version 5.107, 60694               24-Jul-23 09:29

               Filename:   C:\Users\jclaude\Documents\GitHub\Nexalin-Halo\Headset\Main Controller\Main Controller ver 3.0.5.lst

               ROM used:   11354 bytes (17%)
                           Largest free fragment is 54178
               RAM used:   606 (15%) at main() level
                           671 (16%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   2A7C
*
00008:  MOVFF  00,04
0000C:  MOVFF  01,05
00010:  MOVFF  02,06
00014:  CLRF   07
00016:  MOVFF  03,08
0001A:  MOVLB  0
0001C:  MOVFFL 3FF5,09
00022:  MOVFFL 3FF6,0A
00028:  MOVFFL 3FF7,0B
0002E:  MOVLB  39
00030:  BTFSS  x94.0
00032:  GOTO   003C
00036:  BTFSC  xA4.0
00038:  GOTO   0202
0003C:  BTFSS  x97.4
0003E:  GOTO   0048
00042:  BTFSC  xA7.4
00044:  GOTO   021C
00048:  MOVFFL 09,3FF5
0004E:  MOVFFL 0A,3FF6
00054:  MOVFFL 0B,3FF7
0005A:  MOVFF  04,00
0005E:  MOVFF  05,01
00062:  MOVFF  06,02
00066:  BSF    07.7
00068:  MOVFF  08,03
0006C:  RETFIE 1
.................... /**
.................... Copyright: 2022 Nexalin Technology
.................... 
.................... Author: John Claude
.................... 
.................... Function: This application controls the Nexalin Headset Main controller. 
.................... The Main controller controls
....................     treatment stimuation output
....................     BLE peripheral function
....................     battery maintenance
....................     the output controller (waveform generation timing)
.................... 
.................... 
.................... Target: 18F26K83 running at 32MHz located on the Halo headset flex circuit
.................... 
.................... Communication: 
....................     Serial 115.2KB factory debug port and BLE Atmosic module,
....................     Serial 115.2KB serial link with River Headset Output Controller.
.................... 
.................... Release History
....................     20221205    Initial release
....................     20230429    Modify to work with handset v 1.8.2
....................     20230503    Disable BLE function while charging
....................     20230506    Stand alon Headset mode ver 2.0.1
....................     20230510    Modfify haptic pattern, ver 2.0.2  CBE4  Sent to China
....................                 3 beeps for mastoid,
....................                 2 long beeps for mastoid
....................                 10 second at end of treatment.
....................    20230531     Change relay timing for shock, fix haptic bug ver 2.0.5 32A4
....................    20230604     Change power control, change button logic, ver 2.1.0
....................    20230609     Change BLE controller to RN4678,  wer 3.0.1
....................    20230619     Add BT function for RN4678 ver 3.0.3
....................    20230630     Add BLE LED status, adjustable max stim current 
....................    
....................    **/
.................... 
.................... #include <18F26K83.h>
.................... //////////// Standard Header file for the PIC18F26K83 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F26K83
0006E:  CLRF   3FF7
00070:  ADDLW  7E
00072:  MOVWF  3FF6
00074:  MOVLW  00
00076:  ADDWFC 3FF7,F
00078:  TBLRD*+
0007A:  MOVF   3FF5,W
0007C:  RETURN 0
0007E:  DATA 53,41
00080:  DATA 2C,32
00082:  DATA 00,00
00084:  CLRF   3FF7
00086:  ADDLW  94
00088:  MOVWF  3FF6
0008A:  MOVLW  00
0008C:  ADDWFC 3FF7,F
0008E:  TBLRD*+
00090:  MOVF   3FF5,W
00092:  RETURN 0
00094:  DATA 53,47
00096:  DATA 2C,30
00098:  DATA 00,00
0009A:  CLRF   3FF7
0009C:  ADDLW  AA
0009E:  MOVWF  3FF6
000A0:  MOVLW  00
000A2:  ADDWFC 3FF7,F
000A4:  TBLRD*+
000A6:  MOVF   3FF5,W
000A8:  RETURN 0
000AA:  DATA 53,4D
000AC:  DATA 2C,30
000AE:  DATA 00,00
000B0:  CLRF   3FF7
000B2:  ADDLW  C0
000B4:  MOVWF  3FF6
000B6:  MOVLW  00
000B8:  ADDWFC 3FF7,F
000BA:  TBLRD*+
000BC:  MOVF   3FF5,W
000BE:  RETURN 0
000C0:  DATA 53,4E
000C2:  DATA 2C,48
000C4:  DATA 61,6C
000C6:  DATA 6F,00
000C8:  CLRF   3FF7
000CA:  ADDLW  D8
000CC:  MOVWF  3FF6
000CE:  MOVLW  00
000D0:  ADDWFC 3FF7,F
000D2:  TBLRD*+
000D4:  MOVF   3FF5,W
000D6:  RETURN 0
000D8:  DATA 53,59
000DA:  DATA 2C,34
000DC:  DATA 00,00
000DE:  CLRF   3FF7
000E0:  ADDLW  EE
000E2:  MOVWF  3FF6
000E4:  MOVLW  00
000E6:  ADDWFC 3FF7,F
000E8:  TBLRD*+
000EA:  MOVF   3FF5,W
000EC:  RETURN 0
000EE:  DATA 53,53
000F0:  DATA 2C,53
000F2:  DATA 65,72
000F4:  DATA 69,61
000F6:  DATA 6C,20
000F8:  DATA 50,6F
000FA:  DATA 72,74
000FC:  DATA 00,00
000FE:  CLRF   3FF7
00100:  ADDLW  0E
00102:  MOVWF  3FF6
00104:  MOVLW  01
00106:  ADDWFC 3FF7,F
00108:  TBLRD*+
0010A:  MOVF   3FF5,W
0010C:  RETURN 0
0010E:  DATA 52,2C
00110:  DATA 31,00
00112:  CLRF   3FF7
00114:  ADDLW  22
00116:  MOVWF  3FF6
00118:  MOVLW  01
0011A:  ADDWFC 3FF7,F
0011C:  TBLRD*+
0011E:  MOVF   3FF5,W
00120:  RETURN 0
00122:  DATA 2F,00
00124:  DATA 0A,0D
00126:  DATA 20,73
00128:  DATA 74,61
0012A:  DATA 74,65
0012C:  DATA 3D,25
0012E:  DATA 75,00
00130:  DATA 0A,0D
00132:  DATA 20,42
00134:  DATA 54,20
00136:  DATA 52,65
00138:  DATA 73,65
0013A:  DATA 74,00
0013C:  DATA 0A,0D
0013E:  DATA 20,43
00140:  DATA 6F,6E
00142:  DATA 66,69
00144:  DATA 67,75
00146:  DATA 72,69
00148:  DATA 6E,67
0014A:  DATA 20,42
0014C:  DATA 54,00
0014E:  DATA 0A,0D
00150:  DATA 20,00
00152:  DATA 0A,0D
00154:  DATA 20,44
00156:  DATA 6F,6E
00158:  DATA 65,20
0015A:  DATA 42,54
0015C:  DATA 20,43
0015E:  DATA 6F,6E
00160:  DATA 66,69
00162:  DATA 67,00
00164:  DATA 0A,0D
00166:  DATA 20,53
00168:  DATA 6C,65
0016A:  DATA 65,70
0016C:  DATA 00,00
0016E:  DATA 0A,0D
00170:  DATA 20,53
00172:  DATA 65,6C
00174:  DATA 66,20
00176:  DATA 54,65
00178:  DATA 73,74
0017A:  DATA 00,00
0017C:  DATA 0A,0D
0017E:  DATA 20,50
00180:  DATA 72,6F
00182:  DATA 67,72
00184:  DATA 61,6D
00186:  DATA 6D,65
00188:  DATA 72,20
0018A:  DATA 61,74
0018C:  DATA 74,61
0018E:  DATA 63,68
00190:  DATA 65,64
00192:  DATA 00,00
00194:  DATA 0A,0D
00196:  DATA 20,50
00198:  DATA 72,6F
0019A:  DATA 67,72
0019C:  DATA 61,6D
0019E:  DATA 6D,65
001A0:  DATA 72,20
001A2:  DATA 6E,6F
001A4:  DATA 74,20
001A6:  DATA 61,74
001A8:  DATA 74,61
001AA:  DATA 63,68
001AC:  DATA 65,64
001AE:  DATA 00,00
001B0:  DATA 0A,0D
001B2:  DATA 20,4D
001B4:  DATA 61,78
001B6:  DATA 53,65
001B8:  DATA 74,70
001BA:  DATA 6F,69
001BC:  DATA 6E,74
001BE:  DATA 20,3D
001C0:  DATA 20,25
001C2:  DATA 66,00
001C4:  DATA 0A,0D
001C6:  DATA 20,43
001C8:  DATA 68,61
001CA:  DATA 72,67
001CC:  DATA 65,72
001CE:  DATA 20,61
001D0:  DATA 74,74
001D2:  DATA 61,63
001D4:  DATA 68,65
001D6:  DATA 64,00
001D8:  DATA 0A,0D
001DA:  DATA 20,43
001DC:  DATA 68,61
001DE:  DATA 72,67
001E0:  DATA 65,72
001E2:  DATA 20,6E
001E4:  DATA 6F,74
001E6:  DATA 20,61
001E8:  DATA 74,74
001EA:  DATA 61,63
001EC:  DATA 68,65
001EE:  DATA 64,00
001F0:  DATA 0A,0D
001F2:  DATA 20,42
001F4:  DATA 61,74
001F6:  DATA 74,65
001F8:  DATA 72,79
001FA:  DATA 3D,20
001FC:  DATA 20,25
001FE:  DATA 6C,75
00200:  DATA 00,00
*
0027E:  DATA 42,61
00280:  DATA 74,74
00282:  DATA 65,72
00284:  DATA 79,20
00286:  DATA 46,75
00288:  DATA 6C,6C
0028A:  DATA 00,00
0028C:  DATA 0A,0D
0028E:  DATA 20,25
00290:  DATA 75,2C
00292:  DATA 20,25
00294:  DATA 6C,75
00296:  DATA 20,2C
00298:  DATA 20,25
0029A:  DATA 6C,75
0029C:  DATA 2C,20
0029E:  DATA 25,6C
002A0:  DATA 75,2C
002A2:  DATA 20,25
002A4:  DATA 6C,75
002A6:  DATA 2C,20
002A8:  DATA 25,6C
002AA:  DATA 75,20
002AC:  DATA 00,00
002AE:  DATA 0A,0D
002B0:  DATA 20,00
002B2:  DATA 0A,0D
002B4:  DATA 20,24
002B6:  DATA 25,73
002B8:  DATA 00,00
002BA:  DATA 0A,0D
002BC:  DATA 20,24
002BE:  DATA 25,73
002C0:  DATA 00,00
002C2:  DATA 0A,0D
002C4:  DATA 20,00
002C6:  DATA 0A,0D
002C8:  DATA 20,24
002CA:  DATA 25,73
002CC:  DATA 00,00
002CE:  DATA 0A,0D
002D0:  DATA 20,24
002D2:  DATA 25,73
002D4:  DATA 00,00
002D6:  DATA 0A,0D
002D8:  DATA 20,00
002DA:  DATA 0A,0D
002DC:  DATA 20,24
002DE:  DATA 25,73
002E0:  DATA 00,00
002E2:  DATA 0A,0D
002E4:  DATA 20,24
002E6:  DATA 25,73
002E8:  DATA 00,00
002EA:  DATA 0A,0D
002EC:  DATA 20,00
002EE:  DATA 0A,0D
002F0:  DATA 20,24
002F2:  DATA 25,73
002F4:  DATA 00,00
002F6:  DATA 0A,0D
002F8:  DATA 20,24
002FA:  DATA 25,73
002FC:  DATA 00,00
002FE:  DATA 73,65
00300:  DATA 74,00
00302:  DATA 6F,6E
00304:  DATA 00,6F
00306:  DATA 66,66
00308:  DATA 00,64
0030A:  DATA 61,74
0030C:  DATA 61,00
0030E:  DATA 73,6C
00310:  DATA 65,65
00312:  DATA 70,00
00314:  DATA 00,00
00316:  DATA 0A,0D
00318:  DATA 20,53
0031A:  DATA 6C,65
0031C:  DATA 65,70
0031E:  DATA 00,00
00320:  DATA 0A,0D
00322:  DATA 20,53
00324:  DATA 6C,65
00326:  DATA 65,70
00328:  DATA 00,00
0032A:  DATA 0A,0D
0032C:  DATA 20,49
0032E:  DATA 6E,69
00330:  DATA 74,69
00332:  DATA 61,6C
00334:  DATA 69,7A
00336:  DATA 69,6E
00338:  DATA 67,20
0033A:  DATA 4D,61
0033C:  DATA 69,6E
0033E:  DATA 20,43
00340:  DATA 6F,6E
00342:  DATA 74,72
00344:  DATA 6F,6C
00346:  DATA 6C,65
00348:  DATA 72,20
0034A:  DATA 56,65
0034C:  DATA 72,20
0034E:  DATA 33,2E
00350:  DATA 30,2E
00352:  DATA 35,00
*
003A2:  MOVLW  80
003A4:  BTFSS  3FD8.1
003A6:  BRA    03AC
003A8:  MOVLB  2
003AA:  XORWF  x6F,F
003AC:  MOVLB  2
003AE:  CLRF   x74
003B0:  CLRF   x75
003B2:  MOVFF  26B,273
003B6:  MOVF   x6F,W
003B8:  XORWF  x73,F
003BA:  MOVF   x6A,W
003BC:  BTFSC  3FD8.2
003BE:  BRA    057E
003C0:  MOVWF  x72
003C2:  MOVWF  00
003C4:  MOVF   x6E,W
003C6:  BTFSC  3FD8.2
003C8:  BRA    0590
003CA:  SUBWF  x72,F
003CC:  BTFSC  3FD8.2
003CE:  BRA    04D6
003D0:  BNC   044E
003D2:  MOVFF  26F,278
003D6:  BSF    x78.7
003D8:  MOVFF  270,277
003DC:  MOVFF  271,276
003E0:  CLRF   x75
003E2:  BCF    3FD8.0
003E4:  RRCF   x78,F
003E6:  RRCF   x77,F
003E8:  RRCF   x76,F
003EA:  RRCF   x75,F
003EC:  DECFSZ x72,F
003EE:  BRA    03E0
003F0:  BTFSS  x73.7
003F2:  BRA    03FA
003F4:  BSF    x74.0
003F6:  BRA    05B8
003F8:  BCF    x74.0
003FA:  BCF    x72.0
003FC:  BSF    x74.4
003FE:  MOVLW  02
00400:  MOVWF  3FEA
00402:  MOVLW  6D
00404:  MOVWF  3FE9
00406:  BRA    05DE
00408:  BCF    x74.4
0040A:  BTFSC  x73.7
0040C:  BRA    0422
0040E:  BTFSS  x72.0
00410:  BRA    0438
00412:  RRCF   x78,F
00414:  RRCF   x77,F
00416:  RRCF   x76,F
00418:  RRCF   x75,F
0041A:  INCF   00,F
0041C:  BTFSC  3FD8.2
0041E:  BRA    05AE
00420:  BRA    0438
00422:  BTFSC  x78.7
00424:  BRA    043E
00426:  BCF    3FD8.0
00428:  RLCF   x75,F
0042A:  RLCF   x76,F
0042C:  RLCF   x77,F
0042E:  RLCF   x78,F
00430:  DECF   00,F
00432:  BTFSC  3FD8.2
00434:  BRA    05AE
00436:  BRA    0422
00438:  BSF    x74.6
0043A:  BRA    0516
0043C:  BCF    x74.6
0043E:  MOVFF  26B,273
00442:  BTFSS  x6B.7
00444:  BRA    044A
00446:  BSF    x78.7
00448:  BRA    05A0
0044A:  BCF    x78.7
0044C:  BRA    05A0
0044E:  MOVFF  26E,272
00452:  MOVFF  26E,00
00456:  MOVF   x6A,W
00458:  SUBWF  x72,F
0045A:  MOVFF  26B,278
0045E:  BSF    x78.7
00460:  MOVFF  26C,277
00464:  MOVFF  26D,276
00468:  CLRF   x75
0046A:  BCF    3FD8.0
0046C:  RRCF   x78,F
0046E:  RRCF   x77,F
00470:  RRCF   x76,F
00472:  RRCF   x75,F
00474:  DECFSZ x72,F
00476:  BRA    0468
00478:  BTFSS  x73.7
0047A:  BRA    0482
0047C:  BSF    x74.1
0047E:  BRA    05B8
00480:  BCF    x74.1
00482:  BCF    x72.0
00484:  BSF    x74.5
00486:  MOVLW  02
00488:  MOVWF  3FEA
0048A:  MOVLW  71
0048C:  MOVWF  3FE9
0048E:  BRA    05DE
00490:  BCF    x74.5
00492:  BTFSC  x73.7
00494:  BRA    04AA
00496:  BTFSS  x72.0
00498:  BRA    04C0
0049A:  RRCF   x78,F
0049C:  RRCF   x77,F
0049E:  RRCF   x76,F
004A0:  RRCF   x75,F
004A2:  INCF   00,F
004A4:  BTFSC  3FD8.2
004A6:  BRA    05AE
004A8:  BRA    04C0
004AA:  BTFSC  x78.7
004AC:  BRA    04C6
004AE:  BCF    3FD8.0
004B0:  RLCF   x75,F
004B2:  RLCF   x76,F
004B4:  RLCF   x77,F
004B6:  RLCF   x78,F
004B8:  DECF   00,F
004BA:  BTFSC  3FD8.2
004BC:  BRA    05AE
004BE:  BRA    04AA
004C0:  BSF    x74.7
004C2:  BRA    0516
004C4:  BCF    x74.7
004C6:  MOVFF  26F,273
004CA:  BTFSS  x6F.7
004CC:  BRA    04D2
004CE:  BSF    x78.7
004D0:  BRA    05A0
004D2:  BCF    x78.7
004D4:  BRA    05A0
004D6:  MOVFF  26F,278
004DA:  BSF    x78.7
004DC:  MOVFF  270,277
004E0:  MOVFF  271,276
004E4:  BTFSS  x73.7
004E6:  BRA    04F0
004E8:  BCF    x78.7
004EA:  BSF    x74.2
004EC:  BRA    05B8
004EE:  BCF    x74.2
004F0:  CLRF   x75
004F2:  BCF    x72.0
004F4:  MOVLW  02
004F6:  MOVWF  3FEA
004F8:  MOVLW  6D
004FA:  MOVWF  3FE9
004FC:  BRA    05DE
004FE:  BTFSC  x73.7
00500:  BRA    053A
00502:  MOVFF  26B,273
00506:  BTFSS  x72.0
00508:  BRA    0516
0050A:  RRCF   x78,F
0050C:  RRCF   x77,F
0050E:  RRCF   x76,F
00510:  RRCF   x75,F
00512:  INCF   00,F
00514:  BZ    05AE
00516:  BTFSS  x75.7
00518:  BRA    0530
0051A:  INCF   x76,F
0051C:  BNZ   0530
0051E:  INCF   x77,F
00520:  BNZ   0530
00522:  INCF   x78,F
00524:  BNZ   0530
00526:  RRCF   x78,F
00528:  RRCF   x77,F
0052A:  RRCF   x76,F
0052C:  INCF   00,F
0052E:  BZ    05AE
00530:  BTFSC  x74.6
00532:  BRA    043C
00534:  BTFSC  x74.7
00536:  BRA    04C4
00538:  BRA    0572
0053A:  MOVLW  80
0053C:  XORWF  x78,F
0053E:  BTFSS  x78.7
00540:  BRA    054A
00542:  BRA    05B8
00544:  MOVFF  26F,273
00548:  BRA    055E
0054A:  MOVFF  26B,273
0054E:  MOVF   x78,F
00550:  BNZ   055E
00552:  MOVF   x77,F
00554:  BNZ   055E
00556:  MOVF   x76,F
00558:  BNZ   055E
0055A:  CLRF   00
0055C:  BRA    05A0
0055E:  BTFSC  x78.7
00560:  BRA    0572
00562:  BCF    3FD8.0
00564:  RLCF   x75,F
00566:  RLCF   x76,F
00568:  RLCF   x77,F
0056A:  RLCF   x78,F
0056C:  DECFSZ 00,F
0056E:  BRA    055E
00570:  BRA    05AE
00572:  BTFSS  x73.7
00574:  BRA    057A
00576:  BSF    x78.7
00578:  BRA    05A0
0057A:  BCF    x78.7
0057C:  BRA    05A0
0057E:  MOVFF  26E,00
00582:  MOVFF  26F,278
00586:  MOVFF  270,277
0058A:  MOVFF  271,276
0058E:  BRA    05A0
00590:  MOVFF  26A,00
00594:  MOVFF  26B,278
00598:  MOVFF  26C,277
0059C:  MOVFF  26D,276
005A0:  MOVFF  278,01
005A4:  MOVFF  277,02
005A8:  MOVFF  276,03
005AC:  BRA    0616
005AE:  CLRF   00
005B0:  CLRF   01
005B2:  CLRF   02
005B4:  CLRF   03
005B6:  BRA    0616
005B8:  CLRF   x75
005BA:  COMF   x76,F
005BC:  COMF   x77,F
005BE:  COMF   x78,F
005C0:  COMF   x75,F
005C2:  INCF   x75,F
005C4:  BNZ   05D0
005C6:  INCF   x76,F
005C8:  BNZ   05D0
005CA:  INCF   x77,F
005CC:  BNZ   05D0
005CE:  INCF   x78,F
005D0:  BTFSC  x74.0
005D2:  BRA    03F8
005D4:  BTFSC  x74.1
005D6:  BRA    0480
005D8:  BTFSC  x74.2
005DA:  BRA    04EE
005DC:  BRA    0544
005DE:  MOVF   3FEF,W
005E0:  ADDWF  x76,F
005E2:  BNC   05EE
005E4:  INCF   x77,F
005E6:  BNZ   05EE
005E8:  INCF   x78,F
005EA:  BTFSC  3FD8.2
005EC:  BSF    x72.0
005EE:  MOVF   3FED,F
005F0:  MOVF   3FEF,W
005F2:  ADDWF  x77,F
005F4:  BNC   05FC
005F6:  INCF   x78,F
005F8:  BTFSC  3FD8.2
005FA:  BSF    x72.0
005FC:  MOVF   3FED,F
005FE:  MOVF   3FEF,W
00600:  BTFSC  3FEF.7
00602:  BRA    0606
00604:  XORLW  80
00606:  ADDWF  x78,F
00608:  BTFSC  3FD8.0
0060A:  BSF    x72.0
0060C:  BTFSC  x74.4
0060E:  BRA    0408
00610:  BTFSC  x74.5
00612:  BRA    0490
00614:  BRA    04FE
00616:  MOVLB  0
00618:  RETURN 0
0061A:  MOVLB  2
0061C:  MOVF   x6A,W
0061E:  BTFSC  3FD8.2
00620:  BRA    070A
00622:  MOVWF  00
00624:  MOVF   x6E,W
00626:  BTFSC  3FD8.2
00628:  BRA    070A
0062A:  ADDWF  00,F
0062C:  BNC   0636
0062E:  MOVLW  81
00630:  ADDWF  00,F
00632:  BC    070A
00634:  BRA    063E
00636:  MOVLW  7F
00638:  SUBWF  00,F
0063A:  BNC   070A
0063C:  BZ    070A
0063E:  MOVFF  26B,272
00642:  MOVF   x6F,W
00644:  XORWF  x72,F
00646:  BSF    x6B.7
00648:  BSF    x6F.7
0064A:  MOVF   x6D,W
0064C:  MULWF  x71
0064E:  MOVFFL 3FF4,274
00654:  MOVF   x6C,W
00656:  MULWF  x70
00658:  MOVFFL 3FF4,03
0065E:  MOVFFL 3FF3,273
00664:  MULWF  x71
00666:  MOVF   3FF3,W
00668:  ADDWF  x74,F
0066A:  MOVF   3FF4,W
0066C:  ADDWFC x73,F
0066E:  MOVLW  00
00670:  ADDWFC 03,F
00672:  MOVF   x6D,W
00674:  MULWF  x70
00676:  MOVF   3FF3,W
00678:  ADDWF  x74,F
0067A:  MOVF   3FF4,W
0067C:  ADDWFC x73,F
0067E:  MOVLW  00
00680:  CLRF   02
00682:  ADDWFC 03,F
00684:  ADDWFC 02,F
00686:  MOVF   x6B,W
00688:  MULWF  x71
0068A:  MOVF   3FF3,W
0068C:  ADDWF  x73,F
0068E:  MOVF   3FF4,W
00690:  ADDWFC 03,F
00692:  MOVLW  00
00694:  ADDWFC 02,F
00696:  MOVF   x6B,W
00698:  MULWF  x70
0069A:  MOVF   3FF3,W
0069C:  ADDWF  03,F
0069E:  MOVF   3FF4,W
006A0:  ADDWFC 02,F
006A2:  MOVLW  00
006A4:  CLRF   01
006A6:  ADDWFC 01,F
006A8:  MOVF   x6D,W
006AA:  MULWF  x6F
006AC:  MOVF   3FF3,W
006AE:  ADDWF  x73,F
006B0:  MOVF   3FF4,W
006B2:  ADDWFC 03,F
006B4:  MOVLW  00
006B6:  ADDWFC 02,F
006B8:  ADDWFC 01,F
006BA:  MOVF   x6C,W
006BC:  MULWF  x6F
006BE:  MOVF   3FF3,W
006C0:  ADDWF  03,F
006C2:  MOVF   3FF4,W
006C4:  ADDWFC 02,F
006C6:  MOVLW  00
006C8:  ADDWFC 01,F
006CA:  MOVF   x6B,W
006CC:  MULWF  x6F
006CE:  MOVF   3FF3,W
006D0:  ADDWF  02,F
006D2:  MOVF   3FF4,W
006D4:  ADDWFC 01,F
006D6:  INCF   00,F
006D8:  BTFSC  01.7
006DA:  BRA    06E6
006DC:  RLCF   x73,F
006DE:  RLCF   03,F
006E0:  RLCF   02,F
006E2:  RLCF   01,F
006E4:  DECF   00,F
006E6:  MOVLW  00
006E8:  BTFSS  x73.7
006EA:  BRA    0700
006EC:  INCF   03,F
006EE:  ADDWFC 02,F
006F0:  ADDWFC 01,F
006F2:  MOVF   01,W
006F4:  BNZ   0700
006F6:  MOVF   02,W
006F8:  BNZ   0700
006FA:  MOVF   03,W
006FC:  BNZ   0700
006FE:  INCF   00,F
00700:  BTFSC  x72.7
00702:  BSF    01.7
00704:  BTFSS  x72.7
00706:  BCF    01.7
00708:  BRA    0712
0070A:  CLRF   00
0070C:  CLRF   01
0070E:  CLRF   02
00710:  CLRF   03
00712:  MOVLB  0
00714:  RETURN 0
00716:  MOVFF  26B,272
0071A:  MOVLB  2
0071C:  MOVF   x6F,W
0071E:  XORWF  x72,F
00720:  BTFSS  x72.7
00722:  BRA    072E
00724:  BCF    3FD8.2
00726:  BCF    3FD8.0
00728:  BTFSC  x6B.7
0072A:  BSF    3FD8.0
0072C:  BRA    078C
0072E:  MOVFF  26B,272
00732:  MOVFF  26E,273
00736:  MOVF   x6A,W
00738:  SUBWF  x73,F
0073A:  BZ    0748
0073C:  BTFSS  x72.7
0073E:  BRA    078C
00740:  MOVF   3FD8,W
00742:  XORLW  01
00744:  MOVWF  3FD8
00746:  BRA    078C
00748:  MOVFF  26F,273
0074C:  MOVF   x6B,W
0074E:  SUBWF  x73,F
00750:  BZ    075E
00752:  BTFSS  x72.7
00754:  BRA    078C
00756:  MOVF   3FD8,W
00758:  XORLW  01
0075A:  MOVWF  3FD8
0075C:  BRA    078C
0075E:  MOVFF  270,273
00762:  MOVF   x6C,W
00764:  SUBWF  x73,F
00766:  BZ    0774
00768:  BTFSS  x72.7
0076A:  BRA    078C
0076C:  MOVF   3FD8,W
0076E:  XORLW  01
00770:  MOVWF  3FD8
00772:  BRA    078C
00774:  MOVFF  271,273
00778:  MOVF   x6D,W
0077A:  SUBWF  x73,F
0077C:  BZ    078A
0077E:  BTFSS  x72.7
00780:  BRA    078C
00782:  MOVF   3FD8,W
00784:  XORLW  01
00786:  MOVWF  3FD8
00788:  BRA    078C
0078A:  BCF    3FD8.0
0078C:  MOVLB  0
0078E:  RETURN 0
00790:  MOVLW  8E
00792:  MOVWF  00
00794:  MOVLB  2
00796:  MOVF   x6A,W
00798:  SUBWF  00,F
0079A:  MOVFF  26B,02
0079E:  MOVFF  26C,01
007A2:  BSF    02.7
007A4:  MOVF   00,F
007A6:  BZ    07BA
007A8:  BCF    3FD8.0
007AA:  MOVF   02,F
007AC:  BNZ   07B2
007AE:  MOVF   01,F
007B0:  BZ    07BA
007B2:  RRCF   02,F
007B4:  RRCF   01,F
007B6:  DECFSZ 00,F
007B8:  BRA    07A8
007BA:  BTFSS  x6B.7
007BC:  BRA    07C8
007BE:  COMF   01,F
007C0:  COMF   02,F
007C2:  INCF   01,F
007C4:  BTFSC  3FD8.2
007C6:  INCF   02,F
007C8:  MOVLB  0
007CA:  RETURN 0
*
0095C:  TBLRD*+
0095E:  MOVF   3FF5,F
00960:  BZ    098A
00962:  MOVFFL 3FF6,26F
00968:  MOVFFL 3FF7,270
0096E:  MOVF   3FF5,W
00970:  MOVLB  39
00972:  BTFSS  xA3.4
00974:  BRA    0972
00976:  MOVLB  3D
00978:  MOVWF  xEA
0097A:  MOVFFL 26F,3FF6
00980:  MOVFFL 270,3FF7
00986:  MOVLB  0
00988:  BRA    095C
0098A:  RETURN 0
0098C:  MOVLW  8E
0098E:  MOVWF  00
00990:  MOVFF  266,01
00994:  MOVFF  265,02
00998:  CLRF   03
0099A:  MOVF   01,F
0099C:  BNZ   09B0
0099E:  MOVFF  02,01
009A2:  CLRF   02
009A4:  MOVLW  08
009A6:  SUBWF  00,F
009A8:  MOVF   01,F
009AA:  BNZ   09B0
009AC:  CLRF   00
009AE:  BRA    09C0
009B0:  BCF    3FD8.0
009B2:  BTFSC  01.7
009B4:  BRA    09BE
009B6:  RLCF   02,F
009B8:  RLCF   01,F
009BA:  DECF   00,F
009BC:  BRA    09B0
009BE:  BCF    01.7
009C0:  RETURN 0
009C2:  TBLRD*+
009C4:  MOVFFL 3FF6,266
009CA:  MOVFFL 3FF7,267
009D0:  MOVF   3FF5,W
009D2:  MOVLB  39
009D4:  BTFSS  xA3.4
009D6:  BRA    09D4
009D8:  MOVLB  3D
009DA:  MOVWF  xEA
009DC:  MOVFFL 266,3FF6
009E2:  MOVFFL 267,3FF7
009E8:  MOVLB  2
009EA:  DECFSZ x65,F
009EC:  BRA    09F0
009EE:  BRA    09F4
009F0:  MOVLB  0
009F2:  BRA    09C2
009F4:  MOVLB  0
009F6:  RETURN 0
009F8:  MOVLB  2
009FA:  MOVF   x68,W
009FC:  SUBLW  B6
009FE:  MOVWF  x68
00A00:  CLRF   03
00A02:  MOVFF  269,26C
00A06:  BSF    x69.7
00A08:  BCF    3FD8.0
00A0A:  RRCF   x69,F
00A0C:  RRCF   x6A,F
00A0E:  RRCF   x6B,F
00A10:  RRCF   03,F
00A12:  RRCF   02,F
00A14:  RRCF   01,F
00A16:  RRCF   00,F
00A18:  DECFSZ x68,F
00A1A:  BRA    0A08
00A1C:  BTFSS  x6C.7
00A1E:  BRA    0A36
00A20:  COMF   00,F
00A22:  COMF   01,F
00A24:  COMF   02,F
00A26:  COMF   03,F
00A28:  INCF   00,F
00A2A:  BTFSC  3FD8.2
00A2C:  INCF   01,F
00A2E:  BTFSC  3FD8.2
00A30:  INCF   02,F
00A32:  BTFSC  3FD8.2
00A34:  INCF   03,F
00A36:  MOVLB  0
00A38:  GOTO   0B2E (RETURN)
00A3C:  BTFSC  3FD8.1
00A3E:  BRA    0A48
00A40:  MOVLW  02
00A42:  MOVWF  3FEA
00A44:  MOVLW  70
00A46:  MOVWF  3FE9
00A48:  CLRF   00
00A4A:  CLRF   01
00A4C:  CLRF   02
00A4E:  CLRF   03
00A50:  MOVLB  2
00A52:  CLRF   x70
00A54:  CLRF   x71
00A56:  CLRF   x72
00A58:  CLRF   x73
00A5A:  MOVF   x6F,W
00A5C:  IORWF  x6E,W
00A5E:  IORWF  x6D,W
00A60:  IORWF  x6C,W
00A62:  BZ    0ABC
00A64:  MOVLW  20
00A66:  MOVWF  x74
00A68:  BCF    3FD8.0
00A6A:  RLCF   x68,F
00A6C:  RLCF   x69,F
00A6E:  RLCF   x6A,F
00A70:  RLCF   x6B,F
00A72:  RLCF   x70,F
00A74:  RLCF   x71,F
00A76:  RLCF   x72,F
00A78:  RLCF   x73,F
00A7A:  MOVF   x6F,W
00A7C:  SUBWF  x73,W
00A7E:  BNZ   0A90
00A80:  MOVF   x6E,W
00A82:  SUBWF  x72,W
00A84:  BNZ   0A90
00A86:  MOVF   x6D,W
00A88:  SUBWF  x71,W
00A8A:  BNZ   0A90
00A8C:  MOVF   x6C,W
00A8E:  SUBWF  x70,W
00A90:  BNC   0AB0
00A92:  MOVF   x6C,W
00A94:  SUBWF  x70,F
00A96:  MOVF   x6D,W
00A98:  BTFSS  3FD8.0
00A9A:  INCFSZ x6D,W
00A9C:  SUBWF  x71,F
00A9E:  MOVF   x6E,W
00AA0:  BTFSS  3FD8.0
00AA2:  INCFSZ x6E,W
00AA4:  SUBWF  x72,F
00AA6:  MOVF   x6F,W
00AA8:  BTFSS  3FD8.0
00AAA:  INCFSZ x6F,W
00AAC:  SUBWF  x73,F
00AAE:  BSF    3FD8.0
00AB0:  RLCF   00,F
00AB2:  RLCF   01,F
00AB4:  RLCF   02,F
00AB6:  RLCF   03,F
00AB8:  DECFSZ x74,F
00ABA:  BRA    0A68
00ABC:  MOVFFL 270,3FEF
00AC2:  MOVFFL 271,3FEC
00AC8:  MOVFFL 272,3FEC
00ACE:  MOVFFL 273,3FEC
00AD4:  MOVLB  0
00AD6:  RETURN 0
00AD8:  MOVF   3FE9,W
00ADA:  MOVLB  2
00ADC:  MOVWF  x60
00ADE:  MOVF   x5F,W
00AE0:  MOVWF  x62
00AE2:  BZ    0B1A
00AE4:  MOVFF  25E,26D
00AE8:  MOVFF  25D,26C
00AEC:  MOVFF  25C,26B
00AF0:  MOVFF  25B,26A
00AF4:  CLRF   x71
00AF6:  CLRF   x70
00AF8:  MOVLW  20
00AFA:  MOVWF  x6F
00AFC:  MOVLW  82
00AFE:  MOVWF  x6E
00B00:  MOVLB  0
00B02:  RCALL  061A
00B04:  MOVFF  03,25E
00B08:  MOVFF  02,25D
00B0C:  MOVFF  01,25C
00B10:  MOVFF  00,25B
00B14:  MOVLB  2
00B16:  DECFSZ x62,F
00B18:  BRA    0AE4
00B1A:  MOVFF  25E,26B
00B1E:  MOVFF  25D,26A
00B22:  MOVFF  25C,269
00B26:  MOVFF  25B,268
00B2A:  MOVLB  0
00B2C:  BRA    09F8
00B2E:  MOVFF  03,25E
00B32:  MOVFF  02,25D
00B36:  MOVFF  01,25C
00B3A:  MOVFF  00,25B
00B3E:  MOVLB  2
00B40:  BTFSS  x5E.7
00B42:  BRA    0B5E
00B44:  DECF   x60,F
00B46:  BSF    x60.5
00B48:  COMF   x5B,F
00B4A:  COMF   x5C,F
00B4C:  COMF   x5D,F
00B4E:  COMF   x5E,F
00B50:  INCF   x5B,F
00B52:  BTFSC  3FD8.2
00B54:  INCF   x5C,F
00B56:  BTFSC  3FD8.2
00B58:  INCF   x5D,F
00B5A:  BTFSC  3FD8.2
00B5C:  INCF   x5E,F
00B5E:  MOVLW  3B
00B60:  MOVWF  x67
00B62:  MOVLW  9A
00B64:  MOVWF  x66
00B66:  MOVLW  CA
00B68:  MOVWF  x65
00B6A:  CLRF   x64
00B6C:  MOVLW  0A
00B6E:  MOVWF  x62
00B70:  MOVF   x5F,W
00B72:  BTFSC  3FD8.2
00B74:  INCF   x60,F
00B76:  BSF    3FD8.1
00B78:  MOVLW  02
00B7A:  MOVWF  3FEA
00B7C:  MOVLW  5B
00B7E:  MOVWF  3FE9
00B80:  MOVFF  25E,26B
00B84:  MOVFF  25D,26A
00B88:  MOVFF  25C,269
00B8C:  MOVFF  25B,268
00B90:  MOVFF  267,26F
00B94:  MOVFF  266,26E
00B98:  MOVFF  265,26D
00B9C:  MOVFF  264,26C
00BA0:  MOVLB  0
00BA2:  RCALL  0A3C
00BA4:  MOVF   01,W
00BA6:  MOVF   00,F
00BA8:  BNZ   0BD0
00BAA:  MOVLB  2
00BAC:  INCF   x5F,W
00BAE:  SUBWF  x62,W
00BB0:  BTFSS  3FD8.2
00BB2:  BRA    0BB8
00BB4:  MOVLB  0
00BB6:  BRA    0BD0
00BB8:  MOVF   x60,W
00BBA:  BZ    0BD6
00BBC:  ANDLW  0F
00BBE:  SUBWF  x62,W
00BC0:  BZ    0BC4
00BC2:  BC    0C54
00BC4:  BTFSC  x60.7
00BC6:  BRA    0C54
00BC8:  BTFSC  x60.6
00BCA:  BRA    0BD6
00BCC:  MOVLW  20
00BCE:  BRA    0C44
00BD0:  MOVLW  20
00BD2:  MOVLB  2
00BD4:  ANDWF  x60,F
00BD6:  BTFSS  x60.5
00BD8:  BRA    0BFA
00BDA:  BCF    x60.5
00BDC:  MOVF   x5F,W
00BDE:  BTFSS  3FD8.2
00BE0:  DECF   x60,F
00BE2:  MOVF   00,W
00BE4:  MOVWF  x60
00BE6:  MOVLW  2D
00BE8:  MOVLB  39
00BEA:  BTFSS  xA3.4
00BEC:  BRA    0BEA
00BEE:  MOVLB  3D
00BF0:  MOVWF  xEA
00BF2:  MOVLB  2
00BF4:  MOVF   x60,W
00BF6:  MOVWF  00
00BF8:  CLRF   x60
00BFA:  MOVF   x5F,W
00BFC:  SUBWF  x62,W
00BFE:  BNZ   0C1C
00C00:  MOVF   00,W
00C02:  MOVWF  x60
00C04:  MOVLW  2E
00C06:  MOVLB  39
00C08:  BTFSS  xA3.4
00C0A:  BRA    0C08
00C0C:  MOVLB  3D
00C0E:  MOVWF  xEA
00C10:  MOVLB  2
00C12:  MOVF   x60,W
00C14:  MOVWF  00
00C16:  MOVLW  20
00C18:  ANDWF  x60,F
00C1A:  MOVLW  00
00C1C:  MOVLW  30
00C1E:  BTFSS  x60.5
00C20:  BRA    0C44
00C22:  BCF    x60.5
00C24:  MOVF   x5F,W
00C26:  BTFSS  3FD8.2
00C28:  DECF   x60,F
00C2A:  MOVF   00,W
00C2C:  MOVWF  x60
00C2E:  MOVLW  2D
00C30:  MOVLB  39
00C32:  BTFSS  xA3.4
00C34:  BRA    0C32
00C36:  MOVLB  3D
00C38:  MOVWF  xEA
00C3A:  MOVLB  2
00C3C:  MOVF   x60,W
00C3E:  MOVWF  00
00C40:  CLRF   x60
00C42:  MOVLW  30
00C44:  ADDWF  00,F
00C46:  MOVF   00,W
00C48:  MOVLB  39
00C4A:  BTFSS  xA3.4
00C4C:  BRA    0C4A
00C4E:  MOVLB  3D
00C50:  MOVWF  xEA
00C52:  MOVLB  2
00C54:  BCF    3FD8.1
00C56:  MOVFF  267,26B
00C5A:  MOVFF  266,26A
00C5E:  MOVFF  265,269
00C62:  MOVFF  264,268
00C66:  CLRF   x6F
00C68:  CLRF   x6E
00C6A:  CLRF   x6D
00C6C:  MOVLW  0A
00C6E:  MOVWF  x6C
00C70:  MOVLB  0
00C72:  RCALL  0A3C
00C74:  MOVFF  03,267
00C78:  MOVFF  02,266
00C7C:  MOVFF  01,265
00C80:  MOVFF  00,264
00C84:  MOVLB  2
00C86:  DECFSZ x62,F
00C88:  BRA    0B76
00C8A:  MOVLB  0
00C8C:  GOTO   0F8E (RETURN)
*
00DDA:  MOVFFL 3FEA,26D
00DE0:  MOVFFL 3FE9,26C
00DE6:  MOVLB  2
00DE8:  SWAPF  x66,W
00DEA:  IORLW  F0
00DEC:  MOVWF  x68
00DEE:  ADDWF  x68,F
00DF0:  ADDLW  E2
00DF2:  MOVWF  x69
00DF4:  ADDLW  32
00DF6:  MOVWF  x6B
00DF8:  MOVF   x66,W
00DFA:  ANDLW  0F
00DFC:  ADDWF  x69,F
00DFE:  ADDWF  x69,F
00E00:  ADDWF  x6B,F
00E02:  ADDLW  E9
00E04:  MOVWF  x6A
00E06:  ADDWF  x6A,F
00E08:  ADDWF  x6A,F
00E0A:  SWAPF  x65,W
00E0C:  ANDLW  0F
00E0E:  ADDWF  x6A,F
00E10:  ADDWF  x6B,F
00E12:  RLCF   x6A,F
00E14:  RLCF   x6B,F
00E16:  COMF   x6B,F
00E18:  RLCF   x6B,F
00E1A:  MOVF   x65,W
00E1C:  ANDLW  0F
00E1E:  ADDWF  x6B,F
00E20:  RLCF   x68,F
00E22:  MOVLW  07
00E24:  MOVWF  x67
00E26:  MOVLW  0A
00E28:  DECF   x6A,F
00E2A:  ADDWF  x6B,F
00E2C:  BNC   0E28
00E2E:  DECF   x69,F
00E30:  ADDWF  x6A,F
00E32:  BNC   0E2E
00E34:  DECF   x68,F
00E36:  ADDWF  x69,F
00E38:  BNC   0E34
00E3A:  DECF   x67,F
00E3C:  ADDWF  x68,F
00E3E:  BNC   0E3A
00E40:  MOVLW  02
00E42:  MOVWF  3FEA
00E44:  MOVLW  67
00E46:  MOVWF  3FE9
00E48:  MOVLW  07
00E4A:  ANDWF  x6C,W
00E4C:  BCF    x6C.6
00E4E:  ADDWF  3FE9,F
00E50:  MOVLW  00
00E52:  ADDWFC 3FEA,F
00E54:  MOVF   3FE9,W
00E56:  SUBLW  6B
00E58:  BNZ   0E62
00E5A:  MOVF   3FEA,W
00E5C:  SUBLW  02
00E5E:  BNZ   0E62
00E60:  BSF    x6C.6
00E62:  MOVF   3FEF,W
00E64:  MOVWF  00
00E66:  BNZ   0E78
00E68:  BTFSC  x6C.6
00E6A:  BRA    0E78
00E6C:  BTFSC  x6C.4
00E6E:  BRA    0E8E
00E70:  BTFSC  x6C.3
00E72:  BRA    0E78
00E74:  MOVLW  20
00E76:  BRA    0E7E
00E78:  BSF    x6C.3
00E7A:  BCF    x6C.4
00E7C:  MOVLW  30
00E7E:  ADDWF  00,F
00E80:  MOVF   00,W
00E82:  MOVLB  39
00E84:  BTFSS  xA3.4
00E86:  BRA    0E84
00E88:  MOVLB  3D
00E8A:  MOVWF  xEA
00E8C:  MOVLB  2
00E8E:  MOVF   3FEE,W
00E90:  BTFSS  x6C.6
00E92:  BRA    0E54
00E94:  MOVLB  0
00E96:  RETURN 0
*
0110C:  MOVF   3FEF,F
0110E:  BZ    113E
01110:  MOVFFL 3FEA,292
01116:  MOVFFL 3FE9,291
0111C:  MOVF   3FEF,W
0111E:  MOVLB  39
01120:  BTFSS  xA7.5
01122:  BRA    1120
01124:  MOVLB  3D
01126:  MOVWF  xD2
01128:  MOVFFL 292,3FEA
0112E:  MOVFFL 291,3FE9
01134:  INCF   3FE9,F
01136:  BTFSC  3FD8.2
01138:  INCF   3FEA,F
0113A:  MOVLB  0
0113C:  BRA    110C
0113E:  RETURN 0
*
012C2:  CLRF   01
012C4:  CLRF   02
012C6:  CLRF   00
012C8:  CLRF   03
012CA:  MOVLB  2
012CC:  MOVF   x64,W
012CE:  BNZ   12D4
012D0:  MOVF   x63,W
012D2:  BZ    1304
012D4:  MOVLW  10
012D6:  MOVWF  x65
012D8:  BCF    3FD8.0
012DA:  RLCF   x61,F
012DC:  RLCF   x62,F
012DE:  RLCF   00,F
012E0:  RLCF   03,F
012E2:  MOVF   x64,W
012E4:  SUBWF  03,W
012E6:  BNZ   12EC
012E8:  MOVF   x63,W
012EA:  SUBWF  00,W
012EC:  BNC   12FC
012EE:  MOVF   x63,W
012F0:  SUBWF  00,F
012F2:  BTFSS  3FD8.0
012F4:  DECF   03,F
012F6:  MOVF   x64,W
012F8:  SUBWF  03,F
012FA:  BSF    3FD8.0
012FC:  RLCF   01,F
012FE:  RLCF   02,F
01300:  DECFSZ x65,F
01302:  BRA    12D8
01304:  MOVLB  0
01306:  RETURN 0
*
013D4:  MOVLB  2
013D6:  MOVF   x68,W
013D8:  CLRF   01
013DA:  SUBWF  x67,W
013DC:  BC    13E4
013DE:  MOVFF  267,00
013E2:  BRA    13FC
013E4:  CLRF   00
013E6:  MOVLW  08
013E8:  MOVWF  x69
013EA:  RLCF   x67,F
013EC:  RLCF   00,F
013EE:  MOVF   x68,W
013F0:  SUBWF  00,W
013F2:  BTFSC  3FD8.0
013F4:  MOVWF  00
013F6:  RLCF   01,F
013F8:  DECFSZ x69,F
013FA:  BRA    13EA
013FC:  MOVLB  0
013FE:  RETURN 0
01400:  MOVF   01,W
01402:  MOVFF  265,267
01406:  MOVLW  64
01408:  MOVLB  2
0140A:  MOVWF  x68
0140C:  MOVLB  0
0140E:  RCALL  13D4
01410:  MOVFF  00,265
01414:  MOVF   01,W
01416:  MOVLW  30
01418:  BNZ   142A
0141A:  MOVLB  2
0141C:  BTFSS  x66.1
0141E:  BRA    1442
01420:  BTFSC  x66.3
01422:  BRA    1442
01424:  BTFSC  x66.4
01426:  MOVLW  20
01428:  BRA    1432
0142A:  MOVLB  2
0142C:  BCF    x66.3
0142E:  BCF    x66.4
01430:  BSF    x66.0
01432:  ADDWF  01,F
01434:  MOVF   01,W
01436:  MOVLB  39
01438:  BTFSS  xA3.4
0143A:  BRA    1438
0143C:  MOVLB  3D
0143E:  MOVWF  xEA
01440:  MOVLB  2
01442:  MOVFF  265,267
01446:  MOVLW  0A
01448:  MOVWF  x68
0144A:  MOVLB  0
0144C:  RCALL  13D4
0144E:  MOVFF  00,265
01452:  MOVF   01,W
01454:  MOVLW  30
01456:  BNZ   1468
01458:  MOVLB  2
0145A:  BTFSC  x66.3
0145C:  BRA    1478
0145E:  BTFSS  x66.0
01460:  BRA    1478
01462:  BTFSC  x66.4
01464:  MOVLW  20
01466:  MOVLB  0
01468:  ADDWF  01,F
0146A:  MOVF   01,W
0146C:  MOVLB  39
0146E:  BTFSS  xA3.4
01470:  BRA    146E
01472:  MOVLB  3D
01474:  MOVWF  xEA
01476:  MOVLB  2
01478:  MOVLW  30
0147A:  ADDWF  x65,F
0147C:  MOVF   x65,W
0147E:  MOVLB  39
01480:  BTFSS  xA3.4
01482:  BRA    1480
01484:  MOVLB  3D
01486:  MOVWF  xEA
01488:  MOVLB  0
0148A:  RETURN 0
*
018A6:  MOVLB  2
018A8:  MOVF   x61,W
018AA:  MULWF  x63
018AC:  MOVFFL 3FF3,01
018B2:  MOVFFL 3FF4,00
018B8:  MULWF  x64
018BA:  MOVF   3FF3,W
018BC:  ADDWF  00,F
018BE:  MOVF   x62,W
018C0:  MULWF  x63
018C2:  MOVF   3FF3,W
018C4:  ADDWFC 00,W
018C6:  MOVWF  02
018C8:  MOVLB  0
018CA:  GOTO   1BD8 (RETURN)
018CE:  MOVLB  2
018D0:  MOVF   x63,W
018D2:  BTFSC  3FD8.2
018D4:  BRA    1A20
018D6:  MOVWF  x6F
018D8:  MOVF   x67,W
018DA:  BTFSC  3FD8.2
018DC:  BRA    1A20
018DE:  SUBWF  x6F,F
018E0:  BNC   18EC
018E2:  MOVLW  7F
018E4:  ADDWF  x6F,F
018E6:  BTFSC  3FD8.0
018E8:  BRA    1A20
018EA:  BRA    18F8
018EC:  MOVLW  81
018EE:  SUBWF  x6F,F
018F0:  BTFSS  3FD8.0
018F2:  BRA    1A20
018F4:  BTFSC  3FD8.2
018F6:  BRA    1A20
018F8:  MOVFF  26F,00
018FC:  CLRF   01
018FE:  CLRF   02
01900:  CLRF   03
01902:  CLRF   x6E
01904:  MOVFF  264,26D
01908:  BSF    x6D.7
0190A:  MOVFF  265,26C
0190E:  MOVFF  266,26B
01912:  MOVLW  19
01914:  MOVWF  x6F
01916:  MOVF   x6A,W
01918:  SUBWF  x6B,F
0191A:  BC    1936
0191C:  MOVLW  01
0191E:  SUBWF  x6C,F
01920:  BC    1936
01922:  SUBWF  x6D,F
01924:  BC    1936
01926:  SUBWF  x6E,F
01928:  BC    1936
0192A:  INCF   x6E,F
0192C:  INCF   x6D,F
0192E:  INCF   x6C,F
01930:  MOVF   x6A,W
01932:  ADDWF  x6B,F
01934:  BRA    1986
01936:  MOVF   x69,W
01938:  SUBWF  x6C,F
0193A:  BC    1960
0193C:  MOVLW  01
0193E:  SUBWF  x6D,F
01940:  BC    1960
01942:  SUBWF  x6E,F
01944:  BC    1960
01946:  INCF   x6E,F
01948:  INCF   x6D,F
0194A:  MOVF   x69,W
0194C:  ADDWF  x6C,F
0194E:  MOVF   x6A,W
01950:  ADDWF  x6B,F
01952:  BNC   1986
01954:  INCF   x6C,F
01956:  BNZ   1986
01958:  INCF   x6D,F
0195A:  BNZ   1986
0195C:  INCF   x6E,F
0195E:  BRA    1986
01960:  MOVF   x68,W
01962:  IORLW  80
01964:  SUBWF  x6D,F
01966:  BC    1984
01968:  MOVLW  01
0196A:  SUBWF  x6E,F
0196C:  BC    1984
0196E:  INCF   x6E,F
01970:  MOVF   x68,W
01972:  IORLW  80
01974:  ADDWF  x6D,F
01976:  MOVF   x69,W
01978:  ADDWF  x6C,F
0197A:  BNC   194E
0197C:  INCF   x6D,F
0197E:  BNZ   194E
01980:  INCF   x6E,F
01982:  BRA    194E
01984:  BSF    03.0
01986:  DECFSZ x6F,F
01988:  BRA    198C
0198A:  BRA    19A2
0198C:  BCF    3FD8.0
0198E:  RLCF   x6B,F
01990:  RLCF   x6C,F
01992:  RLCF   x6D,F
01994:  RLCF   x6E,F
01996:  BCF    3FD8.0
01998:  RLCF   03,F
0199A:  RLCF   02,F
0199C:  RLCF   01,F
0199E:  RLCF   x70,F
019A0:  BRA    1916
019A2:  BTFSS  x70.0
019A4:  BRA    19B2
019A6:  BCF    3FD8.0
019A8:  RRCF   01,F
019AA:  RRCF   02,F
019AC:  RRCF   03,F
019AE:  RRCF   x70,F
019B0:  BRA    19B6
019B2:  DECF   00,F
019B4:  BZ    1A20
019B6:  BTFSC  x70.7
019B8:  BRA    19F6
019BA:  BCF    3FD8.0
019BC:  RLCF   x6B,F
019BE:  RLCF   x6C,F
019C0:  RLCF   x6D,F
019C2:  RLCF   x6E,F
019C4:  MOVF   x6A,W
019C6:  SUBWF  x6B,F
019C8:  BC    19D8
019CA:  MOVLW  01
019CC:  SUBWF  x6C,F
019CE:  BC    19D8
019D0:  SUBWF  x6D,F
019D2:  BC    19D8
019D4:  SUBWF  x6E,F
019D6:  BNC   1A0C
019D8:  MOVF   x69,W
019DA:  SUBWF  x6C,F
019DC:  BC    19E8
019DE:  MOVLW  01
019E0:  SUBWF  x6D,F
019E2:  BC    19E8
019E4:  SUBWF  x6E,F
019E6:  BNC   1A0C
019E8:  MOVF   x68,W
019EA:  IORLW  80
019EC:  SUBWF  x6D,F
019EE:  BC    19F6
019F0:  MOVLW  01
019F2:  SUBWF  x6E,F
019F4:  BNC   1A0C
019F6:  INCF   03,F
019F8:  BNZ   1A0C
019FA:  INCF   02,F
019FC:  BNZ   1A0C
019FE:  INCF   01,F
01A00:  BNZ   1A0C
01A02:  INCF   00,F
01A04:  BZ    1A20
01A06:  RRCF   01,F
01A08:  RRCF   02,F
01A0A:  RRCF   03,F
01A0C:  MOVFF  264,26F
01A10:  MOVF   x68,W
01A12:  XORWF  x6F,F
01A14:  BTFSS  x6F.7
01A16:  BRA    1A1C
01A18:  BSF    01.7
01A1A:  BRA    1A28
01A1C:  BCF    01.7
01A1E:  BRA    1A28
01A20:  CLRF   00
01A22:  CLRF   01
01A24:  CLRF   02
01A26:  CLRF   03
01A28:  MOVLB  0
01A2A:  GOTO   1C0E (RETURN)
*
01FD2:  MOVFFL 3FEA,3FE2
01FD8:  MOVFFL 3FE9,3FE1
01FDE:  CLRF   01
01FE0:  BSF    00.0
01FE2:  TBLRD*+
01FE4:  MOVF   3FF5,W
01FE6:  BTFSS  00.0
01FE8:  BRA    1FF4
01FEA:  SUBWF  3FEE,W
01FEC:  BNZ   1FF4
01FEE:  MOVF   3FF5,F
01FF0:  BNZ   1FE2
01FF2:  BRA    2012
01FF4:  BCF    00.0
01FF6:  MOVF   3FF5,F
01FF8:  BNZ   1FE2
01FFA:  INCF   01,F
01FFC:  BSF    00.0
01FFE:  MOVFFL 3FE2,3FEA
02004:  MOVFFL 3FE1,3FE9
0200A:  TBLRD*
0200C:  MOVF   3FF5,F
0200E:  BNZ   1FE2
02010:  SETF   01
02012:  GOTO   243A (RETURN)
02016:  TBLRD*+
02018:  MOVF   3FF5,F
0201A:  BZ    2044
0201C:  MOVFFL 3FF6,265
02022:  MOVFFL 3FF7,266
02028:  MOVF   3FF5,W
0202A:  MOVLB  39
0202C:  BTFSS  xA7.5
0202E:  BRA    202C
02030:  MOVLB  3D
02032:  MOVWF  xD2
02034:  MOVFFL 265,3FF6
0203A:  MOVFFL 266,3FF7
02040:  MOVLB  0
02042:  BRA    2016
02044:  RETURN 0
02046:  TBLRD*+
02048:  MOVFFL 3FF6,266
0204E:  MOVFFL 3FF7,267
02054:  MOVF   3FF5,W
02056:  MOVLB  39
02058:  BTFSS  xA7.5
0205A:  BRA    2058
0205C:  MOVLB  3D
0205E:  MOVWF  xD2
02060:  MOVFFL 266,3FF6
02066:  MOVFFL 267,3FF7
0206C:  MOVLB  2
0206E:  DECFSZ x65,F
02070:  BRA    2074
02072:  BRA    2078
02074:  MOVLB  0
02076:  BRA    2046
02078:  MOVLB  0
0207A:  RETURN 0
0207C:  MOVF   3FEF,F
0207E:  BZ    20AE
02080:  MOVFFL 3FEA,266
02086:  MOVFFL 3FE9,265
0208C:  MOVF   3FEF,W
0208E:  MOVLB  39
02090:  BTFSS  xA3.4
02092:  BRA    2090
02094:  MOVLB  3D
02096:  MOVWF  xEA
02098:  MOVFFL 266,3FEA
0209E:  MOVFFL 265,3FE9
020A4:  INCF   3FE9,F
020A6:  BTFSC  3FD8.2
020A8:  INCF   3FEA,F
020AA:  MOVLB  0
020AC:  BRA    207C
020AE:  RETURN 0
020B0:  CLRF   00
020B2:  CLRF   01
020B4:  MOVLB  2
020B6:  MOVF   x6C,W
020B8:  BCF    3FD8.0
020BA:  BTFSC  x6D.0
020BC:  ADDWF  00,F
020BE:  RRCF   00,F
020C0:  RRCF   01,F
020C2:  BTFSC  x6D.1
020C4:  ADDWF  00,F
020C6:  RRCF   00,F
020C8:  RRCF   01,F
020CA:  BTFSC  x6D.2
020CC:  ADDWF  00,F
020CE:  RRCF   00,F
020D0:  RRCF   01,F
020D2:  BTFSC  x6D.3
020D4:  ADDWF  00,F
020D6:  RRCF   00,F
020D8:  RRCF   01,F
020DA:  BTFSC  x6D.4
020DC:  ADDWF  00,F
020DE:  RRCF   00,F
020E0:  RRCF   01,F
020E2:  BTFSC  x6D.5
020E4:  ADDWF  00,F
020E6:  RRCF   00,F
020E8:  RRCF   01,F
020EA:  BTFSC  x6D.6
020EC:  ADDWF  00,F
020EE:  RRCF   00,F
020F0:  RRCF   01,F
020F2:  BTFSC  x6D.7
020F4:  ADDWF  00,F
020F6:  RRCF   00,F
020F8:  RRCF   01,F
020FA:  MOVLB  0
020FC:  GOTO   21D8 (RETURN)
*
022A0:  MOVF   01,W
022A2:  MOVFF  265,267
022A6:  MOVLW  64
022A8:  MOVLB  2
022AA:  MOVWF  x68
022AC:  MOVLB  0
022AE:  CALL   13D4
022B2:  MOVFF  00,265
022B6:  MOVF   01,W
022B8:  MOVLW  30
022BA:  BNZ   22CC
022BC:  MOVLB  2
022BE:  BTFSS  x66.1
022C0:  BRA    22E4
022C2:  BTFSC  x66.3
022C4:  BRA    22E4
022C6:  BTFSC  x66.4
022C8:  MOVLW  20
022CA:  BRA    22D4
022CC:  MOVLB  2
022CE:  BCF    x66.3
022D0:  BCF    x66.4
022D2:  BSF    x66.0
022D4:  ADDWF  01,F
022D6:  MOVF   01,W
022D8:  MOVLB  39
022DA:  BTFSS  xA7.5
022DC:  BRA    22DA
022DE:  MOVLB  3D
022E0:  MOVWF  xD2
022E2:  MOVLB  2
022E4:  MOVFF  265,267
022E8:  MOVLW  0A
022EA:  MOVWF  x68
022EC:  MOVLB  0
022EE:  CALL   13D4
022F2:  MOVFF  00,265
022F6:  MOVF   01,W
022F8:  MOVLW  30
022FA:  BNZ   230C
022FC:  MOVLB  2
022FE:  BTFSC  x66.3
02300:  BRA    231C
02302:  BTFSS  x66.0
02304:  BRA    231C
02306:  BTFSC  x66.4
02308:  MOVLW  20
0230A:  MOVLB  0
0230C:  ADDWF  01,F
0230E:  MOVF   01,W
02310:  MOVLB  39
02312:  BTFSS  xA7.5
02314:  BRA    2312
02316:  MOVLB  3D
02318:  MOVWF  xD2
0231A:  MOVLB  2
0231C:  MOVLW  30
0231E:  ADDWF  x65,F
02320:  MOVF   x65,W
02322:  MOVLB  39
02324:  BTFSS  xA7.5
02326:  BRA    2324
02328:  MOVLB  3D
0232A:  MOVWF  xD2
0232C:  MOVLB  0
0232E:  RETURN 0
02330:  MOVFFL 3FEA,26D
02336:  MOVFFL 3FE9,26C
0233C:  MOVLB  2
0233E:  SWAPF  x66,W
02340:  IORLW  F0
02342:  MOVWF  x68
02344:  ADDWF  x68,F
02346:  ADDLW  E2
02348:  MOVWF  x69
0234A:  ADDLW  32
0234C:  MOVWF  x6B
0234E:  MOVF   x66,W
02350:  ANDLW  0F
02352:  ADDWF  x69,F
02354:  ADDWF  x69,F
02356:  ADDWF  x6B,F
02358:  ADDLW  E9
0235A:  MOVWF  x6A
0235C:  ADDWF  x6A,F
0235E:  ADDWF  x6A,F
02360:  SWAPF  x65,W
02362:  ANDLW  0F
02364:  ADDWF  x6A,F
02366:  ADDWF  x6B,F
02368:  RLCF   x6A,F
0236A:  RLCF   x6B,F
0236C:  COMF   x6B,F
0236E:  RLCF   x6B,F
02370:  MOVF   x65,W
02372:  ANDLW  0F
02374:  ADDWF  x6B,F
02376:  RLCF   x68,F
02378:  MOVLW  07
0237A:  MOVWF  x67
0237C:  MOVLW  0A
0237E:  DECF   x6A,F
02380:  ADDWF  x6B,F
02382:  BNC   237E
02384:  DECF   x69,F
02386:  ADDWF  x6A,F
02388:  BNC   2384
0238A:  DECF   x68,F
0238C:  ADDWF  x69,F
0238E:  BNC   238A
02390:  DECF   x67,F
02392:  ADDWF  x68,F
02394:  BNC   2390
02396:  MOVLW  02
02398:  MOVWF  3FEA
0239A:  MOVLW  67
0239C:  MOVWF  3FE9
0239E:  MOVLW  07
023A0:  ANDWF  x6C,W
023A2:  BCF    x6C.6
023A4:  ADDWF  3FE9,F
023A6:  MOVLW  00
023A8:  ADDWFC 3FEA,F
023AA:  MOVF   3FE9,W
023AC:  SUBLW  6B
023AE:  BNZ   23B8
023B0:  MOVF   3FEA,W
023B2:  SUBLW  02
023B4:  BNZ   23B8
023B6:  BSF    x6C.6
023B8:  MOVF   3FEF,W
023BA:  MOVWF  00
023BC:  BNZ   23CE
023BE:  BTFSC  x6C.6
023C0:  BRA    23CE
023C2:  BTFSC  x6C.4
023C4:  BRA    23E4
023C6:  BTFSC  x6C.3
023C8:  BRA    23CE
023CA:  MOVLW  20
023CC:  BRA    23D4
023CE:  BSF    x6C.3
023D0:  BCF    x6C.4
023D2:  MOVLW  30
023D4:  ADDWF  00,F
023D6:  MOVF   00,W
023D8:  MOVLB  39
023DA:  BTFSS  xA7.5
023DC:  BRA    23DA
023DE:  MOVLB  3D
023E0:  MOVWF  xD2
023E2:  MOVLB  2
023E4:  MOVF   3FEE,W
023E6:  BTFSS  x6C.6
023E8:  BRA    23AA
023EA:  MOVLB  0
023EC:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... //#fuses WDT
.................... #fuses NOWDT
.................... #fuses NOBROWNOUT
.................... 
.................... #use delay(internal=32MHz)
*
00354:  MOVLW  02
00356:  MOVWF  3FEA
00358:  MOVLW  91
0035A:  MOVWF  3FE9
0035C:  MOVF   3FEF,W
0035E:  BZ    037A
00360:  MOVLW  0A
00362:  MOVWF  01
00364:  CLRF   00
00366:  DECFSZ 00,F
00368:  BRA    0366
0036A:  DECFSZ 01,F
0036C:  BRA    0364
0036E:  MOVLW  5F
00370:  MOVWF  00
00372:  DECFSZ 00,F
00374:  BRA    0372
00376:  DECFSZ 3FEF,F
00378:  BRA    0360
0037A:  RETURN 0
*
00C90:  MOVLW  02
00C92:  MOVLB  2
00C94:  SUBWF  x5F,F
00C96:  BNC   0CB0
00C98:  MOVLW  02
00C9A:  MOVWF  3FEA
00C9C:  MOVLW  5F
00C9E:  MOVWF  3FE9
00CA0:  MOVF   3FEF,W
00CA2:  BZ    0CB0
00CA4:  BRA    0CAC
00CA6:  BRA    0CA8
00CA8:  BRA    0CAA
00CAA:  NOP   
00CAC:  DECFSZ 3FEF,F
00CAE:  BRA    0CA6
00CB0:  MOVLB  0
00CB2:  RETURN 0
.................... 
.................... #pin_select U1TX=PIN_C6
.................... #pin_select U1RX=PIN_C7
.................... 
.................... #pin_select U2TX = PIN_B4
.................... #pin_select U2RX = PIN_B3
.................... 
.................... #pin_select CCP1OUT=PIN_C2  // pin 10
.................... #pin_select CCP2OUT=PIN_C1  //pin 9
.................... 
.................... 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=DEBUG)
.................... #use rs232(baud=115200,parity=N,xmit=PIN_B4,rcv=PIN_B3,bits=8,stream=UART)
*
01026:  MOVLB  39
01028:  BTFSS  xA7.5
0102A:  BRA    1028
0102C:  MOVLB  3D
0102E:  MOVWF  xD2
01030:  MOVLB  0
01032:  RETURN 0
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
*
01094:  MOVFF  292,296
01098:  MOVFF  291,295
0109C:  MOVFFL 296,3FEA
010A2:  MOVLB  2
010A4:  MOVF   x95,W
010A6:  MOVWF  3FE9
010A8:  MOVF   3FEF,F
010AA:  BZ    10B8
010AC:  INCF   x95,F
010AE:  BTFSC  3FD8.2
010B0:  INCF   x96,F
010B2:  MOVLB  0
010B4:  BRA    109C
010B6:  MOVLB  2
....................    while(*s2 != '\0')
010B8:  MOVFFL 294,3FEA
010BE:  MOVF   x93,W
010C0:  MOVWF  3FE9
010C2:  MOVF   3FEF,F
010C4:  BZ    10F2
....................    {
....................       *s = *s2;
010C6:  MOVFFL 294,3FEA
010CC:  MOVF   x93,W
010CE:  MOVWF  3FE9
010D0:  MOVF   3FEF,W
010D2:  MOVFFL 296,3FEA
010D8:  MOVFFL 295,3FE9
010DE:  MOVFFL 3FE8,3FEF
....................       ++s;
010E4:  INCF   x95,F
010E6:  BTFSC  3FD8.2
010E8:  INCF   x96,F
....................       ++s2;
010EA:  INCF   x93,F
010EC:  BTFSC  3FD8.2
010EE:  INCF   x94,F
010F0:  BRA    10B8
....................    }
.................... 
....................    *s = '\0';
010F2:  MOVFFL 296,3FEA
010F8:  MOVF   x95,W
010FA:  MOVWF  3FE9
010FC:  CLRF   3FEF
....................    return(s1);
010FE:  MOVFF  291,01
01102:  MOVFF  292,02
01106:  MOVLB  0
01108:  GOTO   117A (RETURN)
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
01E62:  MOVFF  26E,272
01E66:  MOVFF  26D,271
01E6A:  MOVFFL 272,3FEA
01E70:  MOVLB  2
01E72:  MOVF   x71,W
01E74:  MOVWF  3FE9
01E76:  MOVF   3FEF,F
01E78:  BZ    1ED2
....................       for (sc2 = s2; *sc2 != 0; sc2++)
01E7A:  MOVFF  270,274
01E7E:  MOVFF  26F,273
01E82:  MOVFFL 274,3FEA
01E88:  MOVF   x73,W
01E8A:  MOVWF  3FE9
01E8C:  MOVF   3FEF,F
01E8E:  BZ    1EC6
....................          if (*sc1 == *sc2)
01E90:  MOVFF  272,03
01E94:  MOVF   x71,W
01E96:  MOVWF  3FE9
01E98:  MOVFFL 03,3FEA
01E9E:  MOVFFL 3FEF,275
01EA4:  MOVFFL 274,3FEA
01EAA:  MOVF   x73,W
01EAC:  MOVWF  3FE9
01EAE:  MOVF   3FEF,W
01EB0:  SUBWF  x75,W
01EB2:  BNZ   1EBE
....................             return(sc1);
01EB4:  MOVFF  271,01
01EB8:  MOVFF  272,02
01EBC:  BRA    1ED8
01EBE:  INCF   x73,F
01EC0:  BTFSC  3FD8.2
01EC2:  INCF   x74,F
01EC4:  BRA    1E82
01EC6:  INCF   x71,F
01EC8:  BTFSC  3FD8.2
01ECA:  INCF   x72,F
01ECC:  MOVLB  0
01ECE:  BRA    1E6A
01ED0:  MOVLB  2
....................    return(0);
01ED2:  MOVLW  00
01ED4:  MOVWF  01
01ED6:  MOVWF  02
01ED8:  MOVLB  0
01EDA:  GOTO   1F7E (RETURN)
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
01DD0:  MOVFF  26E,272
01DD4:  MOVFF  26D,271
01DD8:  MOVFFL 272,3FEA
01DDE:  MOVLB  2
01DE0:  MOVF   x71,W
01DE2:  MOVWF  3FE9
01DE4:  MOVF   3FEF,F
01DE6:  BZ    1E4A
....................       for (sc2 = s2; ; sc2++)
01DE8:  MOVFF  270,274
01DEC:  MOVFF  26F,273
....................     if (*sc2 == '\0')
01DF0:  MOVFFL 274,3FEA
01DF6:  MOVF   x73,W
01DF8:  MOVWF  3FE9
01DFA:  MOVF   3FEF,F
01DFC:  BNZ   1E14
....................        return(sc1 - s1);
01DFE:  MOVF   x6D,W
01E00:  SUBWF  x71,W
01E02:  MOVWF  00
01E04:  MOVF   x6E,W
01E06:  SUBWFB x72,W
01E08:  MOVWF  03
01E0A:  MOVFF  00,01
01E0E:  MOVWF  02
01E10:  BRA    1E5C
01E12:  BRA    1E36
....................          else if (*sc1 == *sc2)
01E14:  MOVFFL 272,3FEA
01E1A:  MOVF   x71,W
01E1C:  MOVWF  3FE9
01E1E:  MOVFFL 3FEF,275
01E24:  MOVFFL 274,3FEA
01E2A:  MOVF   x73,W
01E2C:  MOVWF  3FE9
01E2E:  MOVF   3FEF,W
01E30:  SUBWF  x75,W
01E32:  BNZ   1E36
....................             break;
01E34:  BRA    1E3E
01E36:  INCF   x73,F
01E38:  BTFSC  3FD8.2
01E3A:  INCF   x74,F
01E3C:  BRA    1DF0
01E3E:  INCF   x71,F
01E40:  BTFSC  3FD8.2
01E42:  INCF   x72,F
01E44:  MOVLB  0
01E46:  BRA    1DD8
01E48:  MOVLB  2
....................    return(sc1 - s1);
01E4A:  MOVF   x6D,W
01E4C:  SUBWF  x71,W
01E4E:  MOVWF  00
01E50:  MOVF   x6E,W
01E52:  SUBWFB x72,W
01E54:  MOVWF  03
01E56:  MOVFF  00,01
01E5A:  MOVWF  02
01E5C:  MOVLB  0
01E5E:  GOTO   1F4A (RETURN)
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
01EDE:  MOVFF  26E,270
01EE2:  MOVFF  26D,26F
01EE6:  MOVFFL 270,3FEA
01EEC:  MOVLB  2
01EEE:  MOVF   x6F,W
01EF0:  MOVWF  3FE9
01EF2:  MOVF   3FEF,F
01EF4:  BZ    1F02
01EF6:  INCF   x6F,F
01EF8:  BTFSC  3FD8.2
01EFA:  INCF   x70,F
01EFC:  MOVLB  0
01EFE:  BRA    1EE6
01F00:  MOVLB  2
....................    return(sc - s);
01F02:  MOVF   x6D,W
01F04:  SUBWF  x6F,W
01F06:  MOVWF  00
01F08:  MOVF   x6E,W
01F0A:  SUBWFB x70,W
01F0C:  MOVWF  03
01F0E:  MOVFF  00,01
01F12:  MOVWF  02
01F14:  MOVLB  0
01F16:  GOTO   1FB8 (RETURN)
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
01F1A:  MOVLB  2
01F1C:  MOVF   x65,W
01F1E:  IORWF  x66,W
01F20:  BZ    1F2A
01F22:  MOVFF  266,03
01F26:  MOVF   x65,W
01F28:  BRA    1F30
01F2A:  MOVFF  1A,03
01F2E:  MOVF   19,W
01F30:  MOVWF  x69
01F32:  MOVFF  03,26A
....................    beg += strspn(beg, s2);
01F36:  MOVFF  26A,26E
01F3A:  MOVFF  269,26D
01F3E:  MOVFF  268,270
01F42:  MOVFF  267,26F
01F46:  MOVLB  0
01F48:  BRA    1DD0
01F4A:  MOVF   01,W
01F4C:  MOVLB  2
01F4E:  ADDWF  x69,F
01F50:  MOVF   02,W
01F52:  ADDWFC x6A,F
....................    if (*beg == '\0')
01F54:  MOVFFL 26A,3FEA
01F5A:  MOVF   x69,W
01F5C:  MOVWF  3FE9
01F5E:  MOVF   3FEF,F
01F60:  BNZ   1F6A
....................       return(0);
01F62:  MOVLW  00
01F64:  MOVWF  01
01F66:  MOVWF  02
01F68:  BRA    1FCE
....................       
....................    end = strpbrk(beg, s2);
01F6A:  MOVFF  26A,26E
01F6E:  MOVFF  269,26D
01F72:  MOVFF  268,270
01F76:  MOVFF  267,26F
01F7A:  MOVLB  0
01F7C:  BRA    1E62
01F7E:  MOVFF  02,26C
01F82:  MOVFF  01,26B
....................    if (end != '\0')
01F86:  MOVLB  2
01F88:  MOVF   x6B,F
01F8A:  BNZ   1F90
01F8C:  MOVF   x6C,F
01F8E:  BZ    1FAC
....................    {
....................       *end = '\0';
01F90:  MOVFFL 26C,3FEA
01F96:  MOVF   x6B,W
01F98:  MOVWF  3FE9
01F9A:  CLRF   3FEF
....................       end++;
01F9C:  INCF   x6B,F
01F9E:  BTFSC  3FD8.2
01FA0:  INCF   x6C,F
....................       save = end;
01FA2:  MOVFF  26C,1A
01FA6:  MOVFF  26B,19
....................    }
01FAA:  BRA    1FC6
....................    else
....................       save = beg + strlen(beg);
01FAC:  MOVFF  26A,26E
01FB0:  MOVFF  269,26D
01FB4:  MOVLB  0
01FB6:  BRA    1EDE
01FB8:  MOVF   01,W
01FBA:  MOVLB  2
01FBC:  ADDWF  x69,W
01FBE:  MOVWF  19
01FC0:  MOVF   02,W
01FC2:  ADDWFC x6A,W
01FC4:  MOVWF  1A
....................    
....................    return(beg);
01FC6:  MOVFF  269,01
01FCA:  MOVFF  26A,02
01FCE:  MOVLB  0
01FD0:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
02100:  MOVLB  2
02102:  CLRF   x6A
....................    sign = 0;
02104:  CLRF   x68
....................    base = 10;
02106:  MOVLW  0A
02108:  MOVWF  x69
....................    result = 0;
0210A:  CLRF   x67
.................... 
....................    if (!s)
0210C:  MOVF   x65,W
0210E:  IORWF  x66,W
02110:  BNZ   2118
....................       return 0;
02112:  MOVLW  00
02114:  MOVWF  01
02116:  BRA    229A
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
02118:  MOVF   x6A,W
0211A:  INCF   x6A,F
0211C:  ADDWF  x65,W
0211E:  MOVWF  3FE9
02120:  MOVLW  00
02122:  ADDWFC x66,W
02124:  MOVWF  3FEA
02126:  MOVFFL 3FEF,26B
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
0212C:  MOVF   x6B,W
0212E:  SUBLW  2D
02130:  BNZ   214C
....................    {
....................       sign = 1;         // Set the sign to negative
02132:  MOVLW  01
02134:  MOVWF  x68
....................       c = s[index++];
02136:  MOVF   x6A,W
02138:  INCF   x6A,F
0213A:  ADDWF  x65,W
0213C:  MOVWF  3FE9
0213E:  MOVLW  00
02140:  ADDWFC x66,W
02142:  MOVWF  3FEA
02144:  MOVFFL 3FEF,26B
....................    }
0214A:  BRA    2166
....................    else if (c == '+')
0214C:  MOVF   x6B,W
0214E:  SUBLW  2B
02150:  BNZ   2166
....................    {
....................       c = s[index++];
02152:  MOVF   x6A,W
02154:  INCF   x6A,F
02156:  ADDWF  x65,W
02158:  MOVWF  3FE9
0215A:  MOVLW  00
0215C:  ADDWFC x66,W
0215E:  MOVWF  3FEA
02160:  MOVFFL 3FEF,26B
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
02166:  MOVF   x6B,W
02168:  SUBLW  2F
0216A:  BTFSC  3FD8.0
0216C:  BRA    228A
0216E:  MOVF   x6B,W
02170:  SUBLW  39
02172:  BTFSS  3FD8.0
02174:  BRA    228A
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
02176:  MOVF   x6B,W
02178:  SUBLW  30
0217A:  BNZ   21BA
0217C:  MOVF   x6A,W
0217E:  ADDWF  x65,W
02180:  MOVWF  3FE9
02182:  MOVLW  00
02184:  ADDWFC x66,W
02186:  MOVWF  3FEA
02188:  MOVF   3FEF,W
0218A:  SUBLW  78
0218C:  BZ    21A0
0218E:  MOVF   x6A,W
02190:  ADDWF  x65,W
02192:  MOVWF  3FE9
02194:  MOVLW  00
02196:  ADDWFC x66,W
02198:  MOVWF  3FEA
0219A:  MOVF   3FEF,W
0219C:  SUBLW  58
0219E:  BNZ   21BA
....................       {
....................          base = 16;
021A0:  MOVLW  10
021A2:  MOVWF  x69
....................          index++;
021A4:  INCF   x6A,F
....................          c = s[index++];
021A6:  MOVF   x6A,W
021A8:  INCF   x6A,F
021AA:  ADDWF  x65,W
021AC:  MOVWF  3FE9
021AE:  MOVLW  00
021B0:  ADDWFC x66,W
021B2:  MOVWF  3FEA
021B4:  MOVFFL 3FEF,26B
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
021BA:  MOVF   x69,W
021BC:  SUBLW  0A
021BE:  BNZ   21FA
....................       {
....................          while (c >= '0' && c <= '9')
021C0:  MOVF   x6B,W
021C2:  SUBLW  2F
021C4:  BC    21F8
021C6:  MOVF   x6B,W
021C8:  SUBLW  39
021CA:  BNC   21F8
....................          {
....................             result = 10*result + (c - '0');
021CC:  MOVLW  0A
021CE:  MOVWF  x6C
021D0:  MOVFF  267,26D
021D4:  MOVLB  0
021D6:  BRA    20B0
021D8:  MOVLW  30
021DA:  MOVLB  2
021DC:  SUBWF  x6B,W
021DE:  ADDWF  01,W
021E0:  MOVWF  x67
....................             c = s[index++];
021E2:  MOVF   x6A,W
021E4:  INCF   x6A,F
021E6:  ADDWF  x65,W
021E8:  MOVWF  3FE9
021EA:  MOVLW  00
021EC:  ADDWFC x66,W
021EE:  MOVWF  3FEA
021F0:  MOVFFL 3FEF,26B
021F6:  BRA    21C0
....................          }
....................       }
021F8:  BRA    228A
....................       else if (base == 16)    // The number is a hexa number
021FA:  MOVF   x69,W
021FC:  SUBLW  10
021FE:  BNZ   228A
....................       {
....................          c = toupper(c);
02200:  MOVF   x6B,W
02202:  SUBLW  60
02204:  BC    2212
02206:  MOVF   x6B,W
02208:  SUBLW  7A
0220A:  BNC   2212
0220C:  MOVF   x6B,W
0220E:  ANDLW  DF
02210:  BRA    2214
02212:  MOVF   x6B,W
02214:  MOVWF  x6B
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
02216:  MOVF   x6B,W
02218:  SUBLW  2F
0221A:  BC    2222
0221C:  MOVF   x6B,W
0221E:  SUBLW  39
02220:  BC    222E
02222:  MOVF   x6B,W
02224:  SUBLW  40
02226:  BC    228A
02228:  MOVF   x6B,W
0222A:  SUBLW  46
0222C:  BNC   228A
....................          {
....................             if (c >= '0' && c <= '9')
0222E:  MOVF   x6B,W
02230:  SUBLW  2F
02232:  BC    224C
02234:  MOVF   x6B,W
02236:  SUBLW  39
02238:  BNC   224C
....................                result = (result << 4) + (c - '0');
0223A:  SWAPF  x67,W
0223C:  MOVWF  x6C
0223E:  MOVLW  F0
02240:  ANDWF  x6C,F
02242:  MOVLW  30
02244:  SUBWF  x6B,W
02246:  ADDWF  x6C,W
02248:  MOVWF  x67
0224A:  BRA    225E
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
0224C:  SWAPF  x67,W
0224E:  MOVWF  x6C
02250:  MOVLW  F0
02252:  ANDWF  x6C,F
02254:  MOVLW  41
02256:  SUBWF  x6B,W
02258:  ADDLW  0A
0225A:  ADDWF  x6C,W
0225C:  MOVWF  x67
.................... 
....................             c = s[index++];
0225E:  MOVF   x6A,W
02260:  INCF   x6A,F
02262:  ADDWF  x65,W
02264:  MOVWF  3FE9
02266:  MOVLW  00
02268:  ADDWFC x66,W
0226A:  MOVWF  3FEA
0226C:  MOVFFL 3FEF,26B
....................             c = toupper(c);
02272:  MOVF   x6B,W
02274:  SUBLW  60
02276:  BC    2284
02278:  MOVF   x6B,W
0227A:  SUBLW  7A
0227C:  BNC   2284
0227E:  MOVF   x6B,W
02280:  ANDLW  DF
02282:  BRA    2286
02284:  MOVF   x6B,W
02286:  MOVWF  x6B
02288:  BRA    2216
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
0228A:  DECFSZ x68,W
0228C:  BRA    2296
0228E:  MOVF   x69,W
02290:  SUBLW  0A
02292:  BNZ   2296
....................        result = -result;
02294:  NEGF   x67
.................... 
....................    return(result);
02296:  MOVFF  267,01
0229A:  MOVLB  0
0229C:  GOTO   24CA (RETURN)
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #define PGD         PIN_B7     //DI, clear if programmer attached
.................... #define ENB_VCC     PIN_C0      //DO, set to enable system VCC
.................... //#define BUCK_PWM    PIN_C1      //DO, control battery charge voltage
.................... //#define DAC_PWM     PIN_C2      //D0, control stimulation voltage, 
.................... #define RESET_BT    PIN_C3      //DO, clear to reset BLE controller
.................... #define ENB_SW_BAT  PIN_C4      //D0, clear to enable analog rails
.................... #define STATUS      PIN_C5      //DI, cleared when BLE paired
.................... #define BUTTON      PIN_B0      //DI, cleared when button is pushed
.................... #define HAPTIC      PIN_B1      //DO, set to turn on haptic
.................... #define SYNC        PIN_A6      //DI, set to trigger interrupt
.................... #define RELAY       PIN_A4      //DO, set set to close output relay 
.................... #define CHRGR_ON    PIN_B2      //DI, set when charger is attached
.................... #define BLUE_LED    PIN_A7      //DO, set to turn on LED
.................... #byte RCSTA1 =0xFAB      //UART serial port  receive control register
.................... #byte RCSTA2 =0xF71      //DEBUG serial port receive control register
.................... 
.................... //constants
.................... uint8_t const OERR = 1; //bit 1 set during serial port overrun
.................... uint8_t const CREN = 4; //bit 4 , set to clear overrun
.................... uint8_t const SPEN = 7; //bit 7 , set to clear overrun
.................... uint8_t  const  CLEAR = 0;        //clear PID state
.................... uint8_t  const  RUN = 1;        //run PID
.................... float    const   FAST_RAMP = 0.02;
.................... float    const   SLOW_RAMP = 0.002;
.................... uint8_t const   DEFAULT_MA = 10;    //default mA setpoint
.................... uint8_t const   SET_ADDR = 1;   //eeprom address in controller eeprom
.................... 
.................... // Serial port communication flag constants
.................... //const unsigned int8 COMM_IDLE =      0x00;   //!< Idle state
.................... const unsigned int8 COMM_CMD  =      0x01;   //!< Looking for command
.................... const unsigned int8 COMM_FND_CR =    0x02;   //!< Looking for carriage return
.................... const unsigned int8 COMM_FND_LF  =   0x04;   //!< Looking for line feed
.................... const unsigned int8 COMM_FND_CMD =   0x80;   //!< Found command
.................... const unsigned int8  BUFFER_LEN =    0xFF;     //!< length of the serial portcommand buffer   
.................... 
.................... // Atmosic NLE Communications buffers 
.................... typedef struct    //!< Serial communication struct
....................     {
....................     char  buff[BUFFER_LEN];  //!< Buffer for received characters
....................     char  utf8[BUFFER_LEN];  //!< Buffer for received characters
....................     uint8_t  len;               //!< Length of buffer
....................     uint8_t  Flags; 
....................     }     // serial communication structure
....................     
.................... structBuff; 
.................... structBuff        g_UART;              //!< UART Buffer for Atmosic
.................... 
.................... 
.................... typedef enum    //g_Fault_Num
.................... {
....................     SELF_TEST_FLG,
....................     DEAD_BATT_FLG,
....................     STIM_FLG,   //set when stimulation output bad
....................  }  FaultFlagsType;
.................... 
.................... 
.................... typedef enum    //machine states and substates
.................... {
....................     POST = 0,
....................     WAIT,    // wait
....................     TREAT,      //treatment
....................     POOR_CONTACT,   //poor electrode contact
....................     GOOD_CONTACT,
....................     FAULT,  //fault condition
.................... }  MachineStateType;
.................... 
.................... 
.................... typedef enum    //electrode c ontact flags for g_Contact_Status
.................... {
....................     LEFT_FLG = 0,   //left mastoid, set when good
....................     FORE_FLG,       // forehead, set when good
....................     RIGHT_FLG,      //right mastoid, set when good
.................... }  ContactType;
.................... 
.................... 
.................... typedef enum    //g_Flags for internal use only
.................... {
....................     TMR1_FLG = 0,   //flag register bit set when timer1 interrupt
....................     BTPAIRED_FLG,   //flag register bit set when parried
....................     INT_FLG,
.................... 
.................... }  SystemFlagType;
.................... 
.................... 
.................... typedef enum    //ADC Channels
.................... {
....................     VSENSE = 0,       //stim voltage
....................     LSENSE = 1,       //stim left current
....................     RSENSE = 2,       //stim right current
....................     BATT_V = 3,
....................     BATT_I = 5,
....................       
.................... }  ADC_ChannelType;
.................... 
.................... 
.................... typedef enum    //battery charging states
.................... {
....................     INIT_CHARGE = 0,  //initialize chargeer
....................     CC,     //constant current
....................     CV,     //constant voltage
....................     FULL,   //full charge
.................... }   ChargeStageType;
.................... 
.................... 
.................... typedef enum    //Bluetooth states
.................... {
....................     UNPAIRED = 0,
....................     PAIRED   
.................... }   BTStateType;
.................... 
.................... 
.................... /**Globals **/
.................... uint8_t     g_State;
.................... uint8_t     g_Flags;
.................... uint16_t    g_Seconds;
.................... uint16_t    g_Batt_Volts;
.................... uint16_t    g_Batt_Amps;
.................... uint16_t    g_Vsense;
.................... uint16_t    g_Lsense;
.................... uint16_t    g_Rsense;
.................... float       g_Total_mA;
.................... float       g_Gain_Err;
.................... float       g_Setpoint_mA;
.................... float       g_MaxSetpoint;
.................... uint16_t    g_DACVal;
.................... uint8_t     g_Contact = 0;   //all electrode poor contact
.................... uint8_t     g_Charge_State;
.................... uint16_t    g_Haptic_Count;
.................... uint8_t     g_BTState;
.................... //uint16_t    g_Batt_Level;
.................... 
.................... // Prototypes
.................... void    Init_Globals(void);
.................... void    Init_IO(void);
.................... void    Self_Test(void);
.................... void    Clocks(void);
.................... void    Tasks(void);
.................... void    Charge_Battery(void);
.................... void    Update_BatteryVI(void);
.................... void    PID(uint8_t);
.................... void    Go_To_Sleep(void);
.................... void    Update_Stim_VI(void);  
.................... void    Send_Serial(void);
.................... void    Check_BLE(void);
.................... void    Process_Command(void);
.................... void    Int_2_Str(int16_t data);
.................... void    SendString_2_BT(char* string, uint16_t  Delay);
.................... void    Configure_BT(void);    
.................... void    ThreeBeeps(void);
.................... void    TwoBeeps(void);
.................... 
.................... // ************************* Start Code ****************************************
.................... 
.................... /**
.................... void    UpdateLEDs(void)
....................   
.................... **/
.................... void    Update_LEDs(void)
.................... {
....................     static uint8_t  ToggleBT;
....................  
....................     fprintf(DEBUG,"\n\r state=%u", g_BTState );
*
017F8:  MOVLW  24
017FA:  MOVWF  3FF6
017FC:  MOVLW  01
017FE:  MOVWF  3FF7
01800:  MOVLW  09
01802:  MOVLB  2
01804:  MOVWF  x65
01806:  MOVLB  0
01808:  CALL   09C2
0180C:  MOVFF  243,265
01810:  MOVLW  1B
01812:  MOVLB  2
01814:  MOVWF  x66
01816:  MOVLB  0
01818:  RCALL  1400
....................     
....................     if(g_BTState == UNPAIRED)   //if not paired 
0181A:  MOVLB  2
0181C:  MOVF   x43,F
0181E:  BNZ   1836
....................     {
....................        if(ToggleBT)    //then toggle blue LED on and off
01820:  MOVF   x44,F
01822:  BZ    182C
....................         {
....................             ToggleBT = 0;
01824:  CLRF   x44
....................             output_low(BLUE_LED); //Blue LED active indicating not paired
01826:  BCF    3FC2.7
01828:  BCF    3FBA.7
....................         }
0182A:  BRA    1834
....................         else
....................         {
....................             ToggleBT = 1;
0182C:  MOVLW  01
0182E:  MOVWF  x44
....................             output_high(BLUE_LED); //Blue LED active indicating not paired  
01830:  BCF    3FC2.7
01832:  BSF    3FBA.7
....................         }
....................     }
01834:  BRA    183E
....................     else if(g_BTState == PAIRED)    //we are paired
01836:  DECFSZ x43,W
01838:  BRA    183E
....................     {
....................         output_high(BLUE_LED); //Blue LED active indicating not paired      
0183A:  BCF    3FC2.7
0183C:  BSF    3FBA.7
....................     }
0183E:  MOVLB  0
01840:  GOTO   1874 (RETURN)
.................... }
.................... 
.................... 
.................... /**
....................     Hard Reboot the RN4678 BT module
.................... 
.................... **/
.................... void    Reboot_BT(void)
.................... {
....................     disable_interrupts(INT_TIMER1); //then enable 10msec interrupt
*
0177A:  MOVLB  39
0177C:  BCF    x94.0
....................     output_low(RESET_BT);
0177E:  BCF    3FC4.3
01780:  BCF    3FBC.3
....................     delay_ms(1);
01782:  MOVLW  01
01784:  MOVLB  2
01786:  MOVWF  x91
01788:  MOVLB  0
0178A:  CALL   0354
....................     output_high(RESET_BT);
0178E:  BCF    3FC4.3
01790:  BSF    3FBC.3
....................     fprintf(DEBUG,"\n\r BT Reset");
01792:  MOVLW  30
01794:  MOVWF  3FF6
01796:  MOVLW  01
01798:  MOVWF  3FF7
0179A:  CALL   095C
....................     delay_ms(100);
0179E:  MOVLW  64
017A0:  MOVLB  2
017A2:  MOVWF  x91
017A4:  MOVLB  0
017A6:  CALL   0354
....................     enable_interrupts(INT_TIMER1); //then enable 10msec interrupt
017AA:  MOVLB  39
017AC:  BSF    x94.0
017AE:  MOVLB  0
017B0:  GOTO   17D4 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /**
....................     Get the state of the bluetooth connection
.................... **/
.................... void     Get_BTState(VOID)
.................... {
.................... 
....................     static uint8_t    LastBTState = PAIRED; 
....................     static uint8_t    LastState;
....................   
....................     if(input(STATUS))   //if not paired now
017B4:  BSF    3FC4.5
017B6:  BTFSS  3FCC.5
017B8:  BRA    17DA
....................     {
....................         if(LastBTState == PAIRED) //and last BT state was paired
017BA:  MOVLB  2
017BC:  DECFSZ x47,W
017BE:  BRA    17D6
....................         {
....................             g_BTState = UNPAIRED;   //then updare pairing status
017C0:  CLRF   x43
....................         
....................             if(g_State == TREAT)    //if in treat state
017C2:  MOVF   x1F,W
017C4:  SUBLW  02
017C6:  BNZ   17D6
....................             {
....................                 LastState = TREAT;
017C8:  MOVLW  02
017CA:  MOVWF  x48
....................                 g_State = WAIT;
017CC:  MOVLW  01
017CE:  MOVWF  x1F
....................                 Reboot_BT();    //reset BT radio
017D0:  MOVLB  0
017D2:  BRA    177A
017D4:  MOVLB  2
....................             }
....................         }
....................     }
017D6:  BRA    17EE
017D8:  MOVLB  0
....................     else     //device is paired now
....................     {
....................         if(LastBTState == UNPAIRED)       
017DA:  MOVLB  2
017DC:  MOVF   x47,F
017DE:  BNZ   17EE
....................         {
....................             g_BTState = PAIRED;
017E0:  MOVLW  01
017E2:  MOVWF  x43
....................             
....................             if(LastState == TREAT)
017E4:  MOVF   x48,W
017E6:  SUBLW  02
017E8:  BNZ   17EE
....................             {
....................                  g_State = WAIT;
017EA:  MOVLW  01
017EC:  MOVWF  x1F
....................             }
....................        }
....................     } 
....................     LastBTState = g_BTState;
017EE:  MOVFF  243,247
017F2:  MOVLB  0
017F4:  GOTO   1872 (RETURN)
.................... }
.................... 
.................... 
.................... /**
.................... *  Send contents of cmd[] to RN4678 BT controller over serial stream UART.
.................... *  Requires UART Serial Interrupt Service Routine to be enabled
.................... *
.................... **/
.................... void SendString_2_BT(char* string)
.................... {
....................     char CR[] = "\r" ;
*
01140:  MOVLW  0D
01142:  MOVLB  2
01144:  MOVWF  x71
01146:  CLRF   x72
....................     char cmd[30] ;
.................... 
....................     strcpy(cmd,string) ;
01148:  MOVLW  02
0114A:  MOVWF  3FEA
0114C:  MOVLW  73
0114E:  MOVWF  3FE9
01150:  MOVFFL 270,3FE2
01156:  MOVFFL 26F,3FE1
0115C:  MOVF   3FE7,F
0115E:  MOVFFL 3FE6,3FEE
01164:  BNZ   115C
....................     strcat(cmd,CR) ;
01166:  MOVLW  02
01168:  MOVWF  x92
0116A:  MOVLW  73
0116C:  MOVWF  x91
0116E:  MOVLW  02
01170:  MOVWF  x94
01172:  MOVLW  71
01174:  MOVWF  x93
01176:  MOVLB  0
01178:  BRA    1094
.................... 
....................     fprintf(UART,"%s",cmd) ;
0117A:  MOVLW  02
0117C:  MOVWF  3FEA
0117E:  MOVLW  73
01180:  MOVWF  3FE9
01182:  RCALL  110C
....................     delay_ms(250);
01184:  MOVLW  FA
01186:  MOVLB  2
01188:  MOVWF  x91
0118A:  MOVLB  0
0118C:  CALL   0354
....................     restart_wdt();  //reset watchdog
01190:  MOVLB  39
01192:  MOVF   x5B,W
01194:  CLRWDT
01196:  MOVLB  0
01198:  RETURN 0
.................... }
.................... 
.................... 
.................... /**
....................     Command RN4678 to enter command mode. Send "$$$"
.................... **/
.................... void    CMD_Mode(void)
.................... {
....................     
....................     uint8_t CONST DELAY = 20;
....................    
....................     fprintf(DEBUG,"\n\r Configuring BT");
*
01034:  MOVLW  3C
01036:  MOVWF  3FF6
01038:  MOVLW  01
0103A:  MOVWF  3FF7
0103C:  RCALL  095C
....................     fprintf(DEBUG,"\n\r ");
0103E:  MOVLW  4E
01040:  MOVWF  3FF6
01042:  MOVLW  01
01044:  MOVWF  3FF7
01046:  RCALL  095C
....................     delay_ms(200);
01048:  MOVLW  C8
0104A:  MOVLB  2
0104C:  MOVWF  x91
0104E:  MOVLB  0
01050:  CALL   0354
....................     
....................     fputc(0x24,UART);   // send $ to RN4677
01054:  MOVLW  24
01056:  RCALL  1026
....................     delay_ms(DELAY);
01058:  MOVLW  14
0105A:  MOVLB  2
0105C:  MOVWF  x91
0105E:  MOVLB  0
01060:  CALL   0354
....................     fputc(0x24,UART);
01064:  MOVLW  24
01066:  RCALL  1026
....................     delay_ms(DELAY);
01068:  MOVLW  14
0106A:  MOVLB  2
0106C:  MOVWF  x91
0106E:  MOVLB  0
01070:  CALL   0354
....................     fputc(0x24,UART);
01074:  MOVLW  24
01076:  RCALL  1026
....................     delay_ms(500);     //allow for response
01078:  MOVLW  02
0107A:  MOVLB  2
0107C:  MOVWF  x5B
0107E:  MOVLW  FA
01080:  MOVWF  x91
01082:  MOVLB  0
01084:  CALL   0354
01088:  MOVLB  2
0108A:  DECFSZ x5B,F
0108C:  BRA    107E
0108E:  MOVLB  0
01090:  GOTO   2C18 (RETURN)
....................  }
....................  
.................... 
.................... 
....................  /**
....................     Configure the RN4678 BT module
.................... 
.................... **/
.................... void    Configure_BT(void)
.................... {
....................     char cmd[20];
....................        
....................     cmd = "SA,2";    // authenitication mode = 2
*
0119A:  MOVLW  02
0119C:  MOVWF  3FEA
0119E:  MOVLW  5B
011A0:  MOVWF  3FE9
011A2:  MOVLW  00
011A4:  CALL   006E
011A8:  TBLRD*-
011AA:  TBLRD*+
011AC:  MOVF   3FF5,W
011AE:  MOVWF  3FEE
011B0:  IORLW  00
011B2:  BNZ   11AA
....................     SendString_2_BT(cmd);
011B4:  MOVLW  02
011B6:  MOVLB  2
011B8:  MOVWF  x70
011BA:  MOVLW  5B
011BC:  MOVWF  x6F
011BE:  MOVLB  0
011C0:  RCALL  1140
....................     
....................     cmd = "SG,0";    // dual mode (BLE and SPP)
011C2:  MOVLW  02
011C4:  MOVWF  3FEA
011C6:  MOVLW  5B
011C8:  MOVWF  3FE9
011CA:  MOVLW  00
011CC:  CALL   0084
011D0:  TBLRD*-
011D2:  TBLRD*+
011D4:  MOVF   3FF5,W
011D6:  MOVWF  3FEE
011D8:  IORLW  00
011DA:  BNZ   11D2
....................     SendString_2_BT(cmd);
011DC:  MOVLW  02
011DE:  MOVLB  2
011E0:  MOVWF  x70
011E2:  MOVLW  5B
011E4:  MOVWF  x6F
011E6:  MOVLB  0
011E8:  RCALL  1140
.................... 
....................     cmd = "SM,0";    // slave mode
011EA:  MOVLW  02
011EC:  MOVWF  3FEA
011EE:  MOVLW  5B
011F0:  MOVWF  3FE9
011F2:  MOVLW  00
011F4:  CALL   009A
011F8:  TBLRD*-
011FA:  TBLRD*+
011FC:  MOVF   3FF5,W
011FE:  MOVWF  3FEE
01200:  IORLW  00
01202:  BNZ   11FA
....................     SendString_2_BT(cmd);
01204:  MOVLW  02
01206:  MOVLB  2
01208:  MOVWF  x70
0120A:  MOVLW  5B
0120C:  MOVWF  x6F
0120E:  MOVLB  0
01210:  RCALL  1140
.................... 
....................     cmd = "SN,Halo";    // device advertised name
01212:  MOVLW  02
01214:  MOVWF  3FEA
01216:  MOVLW  5B
01218:  MOVWF  3FE9
0121A:  MOVLW  00
0121C:  CALL   00B0
01220:  TBLRD*-
01222:  TBLRD*+
01224:  MOVF   3FF5,W
01226:  MOVWF  3FEE
01228:  IORLW  00
0122A:  BNZ   1222
....................     SendString_2_BT(cmd);
0122C:  MOVLW  02
0122E:  MOVLB  2
01230:  MOVWF  x70
01232:  MOVLW  5B
01234:  MOVWF  x6F
01236:  MOVLB  0
01238:  RCALL  1140
.................... 
....................     cmd = "SY,4";    // RF power setting, high
0123A:  MOVLW  02
0123C:  MOVWF  3FEA
0123E:  MOVLW  5B
01240:  MOVWF  3FE9
01242:  MOVLW  00
01244:  CALL   00C8
01248:  TBLRD*-
0124A:  TBLRD*+
0124C:  MOVF   3FF5,W
0124E:  MOVWF  3FEE
01250:  IORLW  00
01252:  BNZ   124A
....................     SendString_2_BT(cmd);
01254:  MOVLW  02
01256:  MOVLB  2
01258:  MOVWF  x70
0125A:  MOVLW  5B
0125C:  MOVWF  x6F
0125E:  MOVLB  0
01260:  RCALL  1140
.................... 
....................     cmd = "SS,Serial Port";    // service name
01262:  MOVLW  02
01264:  MOVWF  3FEA
01266:  MOVLW  5B
01268:  MOVWF  3FE9
0126A:  MOVLW  00
0126C:  CALL   00DE
01270:  TBLRD*-
01272:  TBLRD*+
01274:  MOVF   3FF5,W
01276:  MOVWF  3FEE
01278:  IORLW  00
0127A:  BNZ   1272
....................     SendString_2_BT(cmd);
0127C:  MOVLW  02
0127E:  MOVLB  2
01280:  MOVWF  x70
01282:  MOVLW  5B
01284:  MOVWF  x6F
01286:  MOVLB  0
01288:  RCALL  1140
.................... 
....................     cmd = "R,1";    // save in flash and reboot
0128A:  MOVLW  02
0128C:  MOVWF  3FEA
0128E:  MOVLW  5B
01290:  MOVWF  3FE9
01292:  MOVLW  00
01294:  CALL   00FE
01298:  TBLRD*-
0129A:  TBLRD*+
0129C:  MOVF   3FF5,W
0129E:  MOVWF  3FEE
012A0:  IORLW  00
012A2:  BNZ   129A
....................     SendString_2_BT(cmd);
012A4:  MOVLW  02
012A6:  MOVLB  2
012A8:  MOVWF  x70
012AA:  MOVLW  5B
012AC:  MOVWF  x6F
012AE:  MOVLB  0
012B0:  RCALL  1140
....................     fprintf(DEBUG,"\n\r Done BT Config");
012B2:  MOVLW  52
012B4:  MOVWF  3FF6
012B6:  MOVLW  01
012B8:  MOVWF  3FF7
012BA:  CALL   095C
012BE:  GOTO   2C1C (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /**
.................... void State_Machine(void)
.................... **/
.................... void State_Machine(void)
....................  {
....................    switch(g_State)
*
01CFE:  MOVLB  2
01D00:  MOVF   x1F,W
01D02:  XORLW  01
01D04:  MOVLB  0
01D06:  BZ    1D12
01D08:  XORLW  03
01D0A:  BZ    1D2C
01D0C:  XORLW  07
01D0E:  BZ    1D4E
01D10:  BRA    1D58
....................     {
....................         case WAIT:
....................              if( (input(SYNC)) && (!input(CHRGR_ON) ) ) //if new VI data available and charger not attached
01D12:  BSF    3FC2.6
01D14:  BTFSS  3FCA.6
01D16:  BRA    1D20
01D18:  BSF    3FC3.2
01D1A:  BTFSC  3FCB.2
01D1C:  BRA    1D20
....................                  Update_Stim_VI();   //get it
01D1E:  RCALL  1A2E
....................              
....................              g_Setpoint_mA = 0;
01D20:  MOVLB  2
01D22:  CLRF   x38
01D24:  CLRF   x37
01D26:  CLRF   x36
01D28:  CLRF   x35
....................              break;
01D2A:  BRA    1D5A
.................... 
....................         case TREAT:
....................             if( (input(SYNC)) && (!input(CHRGR_ON) ) ) //if new VI data available and charger not attached
01D2C:  BSF    3FC2.6
01D2E:  BTFSS  3FCA.6
01D30:  BRA    1D3A
01D32:  BSF    3FC3.2
01D34:  BTFSC  3FCB.2
01D36:  BRA    1D3A
....................                 Update_Stim_VI();   //get it
01D38:  RCALL  1A2E
....................             
....................             g_Setpoint_mA = g_MaxSetPoint;
01D3A:  MOVFF  23C,238
01D3E:  MOVFF  23B,237
01D42:  MOVFF  23A,236
01D46:  MOVFF  239,235
....................             break;
01D4A:  MOVLB  2
01D4C:  BRA    1D5A
....................               
....................         case FAULT:
....................             Go_To_Sleep();
01D4E:  CALL   1308
....................             break;
01D52:  MOVLB  2
01D54:  BRA    1D5A
01D56:  MOVLB  0
....................             
....................         default:
....................             g_State = FAULT:
....................             break;
01D58:  MOVLB  2
....................     }
01D5A:  MOVLB  0
01D5C:  GOTO   2C32 (RETURN)
....................  }
.................... 
.................... 
.................... /**
.................... void    Go_To_Sleep(void)
.................... 
.................... **/
.................... void    Go_To_Sleep(void)
.................... {
....................     disable_interrupts(INT_TIMER1); //disable 10msec interrupt
*
01308:  MOVLB  39
0130A:  BCF    x94.0
....................     output_low(BLUE_LED);   //turn off b;ue LED
0130C:  BCF    3FC2.7
0130E:  BCF    3FBA.7
....................     output_low(HAPTIC);
01310:  BCF    3FC3.1
01312:  BCF    3FBB.1
....................         
....................     while(g_DACVal >1)
01314:  MOVLB  2
01316:  MOVF   x3E,F
01318:  BNZ   1320
0131A:  MOVF   x3D,W
0131C:  SUBLW  01
0131E:  BC    135E
....................     {
....................         g_DACVal-=1; //reduce stimulation amplitude
01320:  MOVLW  01
01322:  SUBWF  x3D,F
01324:  MOVLW  00
01326:  SUBWFB x3E,F
....................         set_pwm1_duty(g_DACVal);  //update PWM 
01328:  MOVFFL 23E,3F7D
0132E:  MOVFFL 23D,3F7C
....................         delay_ms(10);
01334:  MOVLW  0A
01336:  MOVWF  x91
01338:  MOVLB  0
0133A:  CALL   0354
....................         fprintf(DEBUG,"%lu,", g_DACVal);
0133E:  MOVLW  10
01340:  MOVWF  3FE9
01342:  MOVFF  23E,266
01346:  MOVFF  23D,265
0134A:  RCALL  0DDA
0134C:  MOVLW  2C
0134E:  MOVLB  39
01350:  BTFSS  xA3.4
01352:  BRA    1350
01354:  MOVLB  3D
01356:  MOVWF  xEA
01358:  MOVLB  39
0135A:  BRA    1314
0135C:  MOVLB  2
....................     } 
....................     
....................     output_low(RELAY);  //turn relay off
0135E:  BCF    3FC2.4
01360:  BCF    3FBA.4
....................     set_pwm1_duty(0);   //turn off stimulation boost 
01362:  BTFSS  3F7E.4
01364:  BRA    136A
01366:  CLRF   3F7D
01368:  BRA    1386
0136A:  CLRF   00
0136C:  CLRF   01
0136E:  RLCF   00,F
01370:  RLCF   01,F
01372:  RLCF   00,F
01374:  RLCF   01,F
01376:  MOVLW  FC
01378:  ANDWF  00,F
0137A:  MOVFFL 01,3F7D
01380:  MOVFFL 00,3F7C
....................     set_pwm2_duty(0);   //turn off charger voltage;  
01386:  BTFSS  3F7A.4
01388:  BRA    138E
0138A:  CLRF   3F79
0138C:  BRA    13AA
0138E:  CLRF   00
01390:  CLRF   01
01392:  RLCF   00,F
01394:  RLCF   01,F
01396:  RLCF   00,F
01398:  RLCF   01,F
0139A:  MOVLW  FC
0139C:  ANDWF  00,F
0139E:  MOVFFL 01,3F79
013A4:  MOVFFL 00,3F78
....................     output_high(ENB_SW_BAT);  //turn off power to stimulation circuit
013AA:  BCF    3FC4.4
013AC:  BSF    3FBC.4
....................     fprintf(DEBUG,"\n\r Sleep");
013AE:  MOVLW  64
013B0:  MOVWF  3FF6
013B2:  MOVLW  01
013B4:  MOVWF  3FF7
013B6:  MOVLB  0
013B8:  CALL   095C
....................     output_low(BLUE_LED);   //turn off b;ue LED
013BC:  BCF    3FC2.7
013BE:  BCF    3FBA.7
....................     delay_ms(50);
013C0:  MOVLW  32
013C2:  MOVLB  2
013C4:  MOVWF  x91
013C6:  MOVLB  0
013C8:  CALL   0354
....................     output_low(ENB_VCC);
013CC:  BCF    3FC4.0
013CE:  BCF    3FBC.0
....................     while(1) { } //wait till dead
013D0:  BRA    13D0
013D2:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void    Init_Globals(void)
.................... {
....................     g_Flags = 0;
*
0037C:  MOVLB  2
0037E:  CLRF   x20
....................     g_DACVal = 0;
00380:  CLRF   x3E
00382:  CLRF   x3D
....................     g_Setpoint_mA = 0;
00384:  CLRF   x38
00386:  CLRF   x37
00388:  CLRF   x36
0038A:  CLRF   x35
....................     g_Seconds = 2400;   // = 40 minutes * 60 seconds
0038C:  MOVLW  09
0038E:  MOVWF  x22
00390:  MOVLW  60
00392:  MOVWF  x21
....................     g_State = 0;
00394:  CLRF   x1F
....................     g_Charge_State = INIT_CHARGE; //reset charge state
00396:  CLRF   x40
....................     g_Haptic_Count = 0;
00398:  CLRF   x42
0039A:  CLRF   x41
0039C:  MOVLB  0
0039E:  GOTO   2BE2 (RETURN)
.................... }
.................... 
.................... 
.................... void Init_IO(void)
.................... {
....................     uint8_t junk;
....................    // output_high(ENB_SW_BAT);  //turn off power to stimulation circuit
....................     output_low(ENB_SW_BAT);  //turn on power to stimulation circuit
*
00928:  BCF    3FC4.4
0092A:  BCF    3FBC.4
....................     output_low(RELAY); //disconnect stimulation output to patient
0092C:  BCF    3FC2.4
0092E:  BCF    3FBA.4
....................     output_high(RESET_BT);   //take BLE ot of reset
00930:  BCF    3FC4.3
00932:  BSF    3FBC.3
....................     output_high(BLUE_LED);
00934:  BCF    3FC2.7
00936:  BSF    3FBA.7
....................     output_low(HAPTIC);
00938:  BCF    3FC3.1
0093A:  BCF    3FBB.1
....................     junk = input(PIN_B2); //make an input
0093C:  BSF    3FC3.2
0093E:  MOVLB  2
00940:  CLRF   x5B
00942:  BTFSC  3FCB.2
00944:  INCF   x5B,F
....................     g_Gain_Err = SLOW_RAMP;    //slow gain for ramp up
00946:  MOVLW  6F
00948:  MOVWF  x34
0094A:  MOVLW  12
0094C:  MOVWF  x33
0094E:  MOVLW  03
00950:  MOVWF  x32
00952:  MOVLW  76
00954:  MOVWF  x31
00956:  MOVLB  0
00958:  GOTO   2BF0 (RETURN)
.................... 
....................  }
.................... 
.................... 
.................... void Self_Test(void)
.................... {
....................   //  delay_ms(10);   //allow serial port to settle down
....................     fprintf(DEBUG,"\n\r");
*
00E98:  MOVLW  0A
00E9A:  MOVLB  39
00E9C:  BTFSS  xA3.4
00E9E:  BRA    0E9C
00EA0:  MOVLB  3D
00EA2:  MOVWF  xEA
00EA4:  MOVLW  0D
00EA6:  MOVLB  39
00EA8:  BTFSS  xA3.4
00EAA:  BRA    0EA8
00EAC:  MOVLB  3D
00EAE:  MOVWF  xEA
....................     fprintf(DEBUG,"\n\r Self Test");
00EB0:  MOVLW  6E
00EB2:  MOVWF  3FF6
00EB4:  MOVLW  01
00EB6:  MOVWF  3FF7
00EB8:  MOVLB  0
00EBA:  RCALL  095C
....................     
....................     if(!input(PGD)) { //if programmer is attached
00EBC:  BSF    3FC3.7
00EBE:  BTFSC  3FCB.7
00EC0:  BRA    0F0E
....................         fprintf(DEBUG,"\n\r Programmer attached");
00EC2:  MOVLW  7C
00EC4:  MOVWF  3FF6
00EC6:  MOVLW  01
00EC8:  MOVWF  3FF7
00ECA:  RCALL  095C
....................         write_eeprom(SET_ADDR, DEFAULT_MA); //load value from code into EEPROM
00ECC:  MOVF   3FD2,W
00ECE:  MOVWF  00
00ED0:  BCF    3FD2.7
00ED2:  MOVLB  39
00ED4:  CLRF   xE1
00ED6:  MOVLW  01
00ED8:  MOVWF  xE0
00EDA:  MOVLW  0A
00EDC:  MOVWF  xE3
00EDE:  BCF    xE5.6
00EE0:  BCF    xE5.7
00EE2:  BSF    xE5.2
00EE4:  MOVLW  55
00EE6:  MOVWF  xE6
00EE8:  MOVLW  AA
00EEA:  MOVWF  xE6
00EEC:  BSF    xE5.1
00EEE:  BTFSC  xE5.1
00EF0:  BRA    0EEE
00EF2:  BCF    xE5.2
00EF4:  BCF    xE5.6
00EF6:  BSF    xE5.7
00EF8:  MOVF   00,W
00EFA:  IORWF  3FD2,F
....................         g_MaxSetpoint = (float)DEFAULT_MA;  //convert to float
00EFC:  MOVLB  2
00EFE:  CLRF   x3C
00F00:  CLRF   x3B
00F02:  MOVLW  20
00F04:  MOVWF  x3A
00F06:  MOVLW  82
00F08:  MOVWF  x39
....................     }
00F0A:  BRA    0F54
00F0C:  MOVLB  0
....................     else {
....................         fprintf(DEBUG,"\n\r Programmer not attached");
00F0E:  MOVLW  94
00F10:  MOVWF  3FF6
00F12:  MOVLW  01
00F14:  MOVWF  3FF7
00F16:  RCALL  095C
....................         g_MaxSetpoint = (float)read_eeprom(SET_ADDR);  //read max setpoint from eeprom
00F18:  MOVFFL 3FD2,25B
00F1E:  BCF    3FD2.7
00F20:  MOVLB  39
00F22:  CLRF   xE1
00F24:  MOVLW  01
00F26:  MOVWF  xE0
00F28:  BCF    xE5.6
00F2A:  BCF    xE5.7
00F2C:  BSF    xE5.0
00F2E:  MOVF   xE3,W
00F30:  BCF    xE5.6
00F32:  BSF    xE5.7
00F34:  MOVLB  2
00F36:  BTFSC  x5B.7
00F38:  BSF    3FD2.7
00F3A:  CLRF   x66
00F3C:  MOVWF  x65
00F3E:  MOVLB  0
00F40:  RCALL  098C
00F42:  MOVFF  03,23C
00F46:  MOVFF  02,23B
00F4A:  MOVFF  01,23A
00F4E:  MOVFF  00,239
00F52:  MOVLB  2
....................     }
....................   // jpc  g_MaxSetPoint = g_MaxSetPoint * 40.0;
....................      g_MaxSetPoint = 400;
00F54:  CLRF   x3C
00F56:  CLRF   x3B
00F58:  MOVLW  48
00F5A:  MOVWF  x3A
00F5C:  MOVLW  87
00F5E:  MOVWF  x39
....................     
....................     fprintf(DEBUG,"\n\r MaxSetpoint = %f", g_MaxSetPoint);
00F60:  MOVLW  B0
00F62:  MOVWF  3FF6
00F64:  MOVLW  01
00F66:  MOVWF  3FF7
00F68:  MOVLW  11
00F6A:  MOVWF  x65
00F6C:  MOVLB  0
00F6E:  RCALL  09C2
00F70:  MOVLW  89
00F72:  MOVWF  3FE9
00F74:  MOVFF  23C,25E
00F78:  MOVFF  23B,25D
00F7C:  MOVFF  23A,25C
00F80:  MOVFF  239,25B
00F84:  MOVLW  02
00F86:  MOVLB  2
00F88:  MOVWF  x5F
00F8A:  MOVLB  0
00F8C:  BRA    0AD8
....................     
....................     if(input(CHRGR_ON))
00F8E:  BSF    3FC3.2
00F90:  BTFSS  3FCB.2
00F92:  BRA    0FA0
....................         fprintf(DEBUG,"\n\r Charger attached");    
00F94:  MOVLW  C4
00F96:  MOVWF  3FF6
00F98:  MOVLW  01
00F9A:  MOVWF  3FF7
00F9C:  RCALL  095C
00F9E:  BRA    0FAA
....................     else
....................         fprintf(DEBUG,"\n\r Charger not attached");
00FA0:  MOVLW  D8
00FA2:  MOVWF  3FF6
00FA4:  MOVLW  01
00FA6:  MOVWF  3FF7
00FA8:  RCALL  095C
....................     
....................     Update_BatteryVI();
00FAA:  RCALL  0CB4
....................     fprintf(DEBUG,"\n\r Battery=  %lu",g_Batt_Volts);
00FAC:  MOVLW  F0
00FAE:  MOVWF  3FF6
00FB0:  MOVLW  01
00FB2:  MOVWF  3FF7
00FB4:  MOVLW  0D
00FB6:  MOVLB  2
00FB8:  MOVWF  x65
00FBA:  MOVLB  0
00FBC:  RCALL  09C2
00FBE:  MOVLW  10
00FC0:  MOVWF  3FE9
00FC2:  MOVFF  224,266
00FC6:  MOVFF  223,265
00FCA:  RCALL  0DDA
.................... 
....................     output_high(ENB_VCC);   //turn on power
00FCC:  BCF    3FC4.0
00FCE:  BSF    3FBC.0
....................     output_high(HAPTIC);    //test haptic
00FD0:  BCF    3FC3.1
00FD2:  BSF    3FBB.1
....................     delay_ms(200);
00FD4:  MOVLW  C8
00FD6:  MOVLB  2
00FD8:  MOVWF  x91
00FDA:  MOVLB  0
00FDC:  CALL   0354
....................     output_low(HAPTIC);
00FE0:  BCF    3FC3.1
00FE2:  BCF    3FBB.1
....................     output_high(RELAY); //connect output to patient
00FE4:  BCF    3FC2.4
00FE6:  BSF    3FBA.4
....................     
....................     g_State = WAIT;
00FE8:  MOVLW  01
00FEA:  MOVLB  2
00FEC:  MOVWF  x1F
00FEE:  MOVLB  0
00FF0:  GOTO   2BF4 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... #INT_TIMER1
.................... void  TIMER1_isr(void) 
*
00202:  MOVLB  0
.................... {
....................     set_timer1(45500);      //10msec interrupt
00204:  MOVLW  B1
00206:  MOVWF  3FB1
00208:  MOVLW  BC
0020A:  MOVWF  3FB0
0020C:  NOP   
....................     bit_set(g_Flags,TMR1_FLG);
0020E:  MOVLB  2
00210:  BSF    x20.0
.................... }   
.................... 
.................... 
.................... /**
....................     Service Serial Port Interrupt
....................     Service the interupt triggeed by a serial byte from the BT UART 
....................     @returns none
.................... **/   
00212:  MOVLB  39
00214:  BCF    xA4.0
00216:  MOVLB  0
00218:  GOTO   0048
.................... #int_RDA2
.................... void RDA2_isr()
0021C:  MOVLB  0
.................... {
....................     char c;
.................... 
....................     c = fgetc(UART);    // Get byte from Bluetooth UART
0021E:  MOVLB  39
00220:  BTFSS  xA7.4
00222:  BRA    0220
00224:  MOVLB  3D
00226:  MOVF   xD0,W
00228:  MOVLB  2
0022A:  MOVWF  x9A
....................   //  fputc(c,DEBUG);     //echo outr debug port
....................    
....................     switch(c)
0022C:  MOVF   x9A,W
0022E:  XORLW  24
00230:  MOVLB  0
00232:  BZ    023A
00234:  XORLW  07
00236:  BZ    0244
00238:  BRA    024E
....................         {     // Do according to the incoming byte count
....................         
....................         case '$':        // '$' - beginning of the string
....................             g_UART.flags = COMM_CMD;    // Set start of command flag, reset others
0023A:  MOVLW  01
0023C:  MOVLB  2
0023E:  MOVWF  x1E
....................             g_UART.len = 0;  // Zero new command buffer length
00240:  CLRF   x1D
....................             break;
00242:  BRA    0268
....................    
....................         case '#':                            //possible end of the packet
....................             g_UART.flags |= COMM_FND_LF;    // Set the <LF> flag
00244:  MOVLB  2
00246:  BSF    x1E.2
....................             g_UART.flags |= COMM_FND_CR;    // Set the <CR> flag
00248:  BSF    x1E.1
....................             break;
0024A:  BRA    0268
0024C:  MOVLB  0
.................... 
....................         default:
....................             if (g_UART.flags & COMM_CMD)                // If we have already received the '$'
0024E:  MOVLB  2
00250:  BTFSS  x1E.0
00252:  BRA    0268
....................                 {
....................                 g_UART.buff[g_UART.len] = c;   // Store new character in the buffer
00254:  MOVLW  1F
00256:  ADDWF  x1D,W
00258:  MOVWF  3FE9
0025A:  CLRF   3FEA
0025C:  BTFSC  3FD8.0
0025E:  INCF   3FEA,F
00260:  MOVFFL 29A,3FEF
....................                 ++g_UART.len;          // Increment the buffer length
00266:  INCF   x1D,F
....................                 }
....................             break;
....................         }   // End switch
....................    
....................     // Test to see if we have a complete command in the buffer
....................     if ((g_UART.flags & (COMM_CMD | COMM_FND_CR | COMM_FND_LF)) ==
....................         (COMM_CMD | COMM_FND_CR | COMM_FND_LF))
00268:  MOVF   x1E,W
0026A:  ANDLW  07
0026C:  SUBLW  07
0026E:  BNZ   0274
....................     {
....................         g_UART.flags = COMM_FND_CMD;   // Set command found flag, reset others
00270:  MOVLW  80
00272:  MOVWF  x1E
....................     }
00274:  MOVLB  39
00276:  BCF    xA7.4
00278:  MOVLB  0
0027A:  GOTO   0048
.................... }    
.................... 
.................... 
.................... /**
.................... Indicate tteatment has stopped  by beeping the haptic
.................... 
.................... **/
.................... void    ShutDown(void)
.................... {
....................     uint8_t n;
....................      
....................     for(n=0; n<10; n++)
....................     {
....................         output_high(HAPTIC);
....................         delay_ms(100);
....................         output_low(HAPTIC);
....................         delay_ms(250);
....................     }
....................     g_State = WAIT;
.................... }
.................... 
.................... 
.................... 
.................... /**
.................... void    Clocks(void)
....................    Executed every 10 msec, this function updates all clocks
.................... 
.................... **/
.................... void Clocks(void)
.................... {
....................     static uint16_t   tmr1_cntr = 0;   //counts TIMR1 interrupts
....................     static uint8_t  g_Beep;;
....................     
....................     tmr1_cntr++;    //inc 10msec interrupt count
*
01844:  MOVLB  2
01846:  INCF   x49,F
01848:  BTFSC  3FD8.2
0184A:  INCF   x4A,F
....................     
....................     //do the following tasks once a second
....................     if(!(tmr1_cntr % 100)) //if 1000ms have passed
0184C:  MOVFF  24A,262
01850:  MOVFF  249,261
01854:  CLRF   x64
01856:  MOVLW  64
01858:  MOVWF  x63
0185A:  MOVLB  0
0185C:  RCALL  12C2
0185E:  MOVF   00,W
01860:  IORWF  03,W
01862:  BNZ   1890
....................     {
....................         Update_BatteryVI();    //get battery params
01864:  CALL   0CB4
....................         Charge_Battery();   //charge battery
01868:  BRA    148C
....................        
....................         if(!Input(CHRGR_ON))   { //if charger is not attached 
0186A:  BSF    3FC3.2
0186C:  BTFSC  3FCB.2
0186E:  BRA    1874
....................             Get_BTState();    //get BT state
01870:  BRA    17B4
....................             Update_LEDs();  //update LEDs
01872:  BRA    17F8
....................         }
....................         
....................         if((g_Contact <7) && (g_DACVal > 10)) {  //if an electrode contact is poor
01874:  MOVLB  2
01876:  MOVF   x3F,W
01878:  SUBLW  06
0187A:  BNC   188E
0187C:  MOVF   x3E,F
0187E:  BNZ   1886
01880:  MOVF   x3D,W
01882:  SUBLW  0A
01884:  BC    188E
....................             g_Beep =20; //beep period
01886:  MOVLW  14
01888:  MOVWF  x4B
....................             output_high(HAPTIC);    //start now
0188A:  BCF    3FC3.1
0188C:  BSF    3FBB.1
0188E:  MOVLB  0
....................         }
....................      
....................     }
....................     if(g_Beep) {
01890:  MOVLB  2
01892:  MOVF   x4B,F
01894:  BZ    18A0
....................         g_Beep--;
01896:  DECF   x4B,F
....................         if(!g_Beep)
01898:  MOVF   x4B,F
0189A:  BNZ   18A0
....................             output_low(HAPTIC); //turn beep off
0189C:  BCF    3FC3.1
0189E:  BCF    3FBB.1
....................     }
018A0:  MOVLB  0
018A2:  GOTO   2C2E (RETURN)
....................         
....................  }  
....................     
....................  
.................... 
.................... Void Update_Stim_VI(void)
.................... {
....................    float ftemp;
....................     uint16_t  ohms;
....................     
....................     set_adc_channel(VSENSE);  //set ADC channel
*
01A2E:  MOVLB  3E
01A30:  CLRF   xF1
....................     delay_us(50);
01A32:  MOVLW  85
01A34:  MOVWF  00
01A36:  DECFSZ 00,F
01A38:  BRA    1A36
....................     ftemp = (float)read_adc();  //get peak stimulation voltage
01A3A:  BSF    xF8.0
01A3C:  NOP   
01A3E:  BTFSC  xF8.0
01A40:  BRA    1A3E
01A42:  MOVFFL 3EF0,02
01A48:  MOVFFL 3EEF,01
01A4E:  RRCF   02,W
01A50:  MOVWF  03
01A52:  RRCF   01,W
01A54:  MOVWF  02
01A56:  RRCF   03,F
01A58:  RRCF   02,F
01A5A:  MOVLW  3F
01A5C:  ANDWF  03,F
01A5E:  MOVFF  02,265
01A62:  MOVFF  03,266
01A66:  MOVLB  0
01A68:  CALL   098C
01A6C:  MOVFF  03,25E
01A70:  MOVFF  02,25D
01A74:  MOVFF  01,25C
01A78:  MOVFF  00,25B
....................     g_Vsense = (uint16_t)(ftemp *0.32);
01A7C:  MOVFF  25E,26D
01A80:  MOVFF  25D,26C
01A84:  MOVFF  25C,26B
01A88:  MOVFF  25B,26A
01A8C:  MOVLW  0A
01A8E:  MOVLB  2
01A90:  MOVWF  x71
01A92:  MOVLW  D7
01A94:  MOVWF  x70
01A96:  MOVLW  23
01A98:  MOVWF  x6F
01A9A:  MOVLW  7D
01A9C:  MOVWF  x6E
01A9E:  MOVLB  0
01AA0:  CALL   061A
01AA4:  MOVFF  03,26D
01AA8:  MOVFF  02,26C
01AAC:  MOVFF  01,26B
01AB0:  MOVFF  00,26A
01AB4:  CALL   0790
01AB8:  MOVFF  02,228
01ABC:  MOVFF  01,227
.................... 
....................     set_adc_channel(LSENSE);  //set ADC channel
01AC0:  MOVLW  01
01AC2:  MOVLB  3E
01AC4:  MOVWF  xF1
....................     delay_us(50);
01AC6:  MOVLW  85
01AC8:  MOVWF  00
01ACA:  DECFSZ 00,F
01ACC:  BRA    1ACA
....................     g_Lsense = read_adc();       // get left mA
01ACE:  BSF    xF8.0
01AD0:  NOP   
01AD2:  BTFSC  xF8.0
01AD4:  BRA    1AD2
01AD6:  MOVFFL 3EF0,02
01ADC:  MOVFFL 3EEF,01
01AE2:  RRCF   02,W
01AE4:  MOVLB  2
01AE6:  MOVWF  x2A
01AE8:  RRCF   01,W
01AEA:  MOVWF  x29
01AEC:  RRCF   x2A,F
01AEE:  RRCF   x29,F
01AF0:  MOVLW  3F
01AF2:  ANDWF  x2A,F
....................       
....................     set_adc_channel(RSENSE);  //set ADC channel
01AF4:  MOVLW  02
01AF6:  MOVLB  3E
01AF8:  MOVWF  xF1
....................     delay_us(50);
01AFA:  MOVLW  85
01AFC:  MOVWF  00
01AFE:  DECFSZ 00,F
01B00:  BRA    1AFE
....................     g_Rsense= read_adc();   //add 
01B02:  BSF    xF8.0
01B04:  NOP   
01B06:  BTFSC  xF8.0
01B08:  BRA    1B06
01B0A:  MOVFFL 3EF0,02
01B10:  MOVFFL 3EEF,01
01B16:  RRCF   02,W
01B18:  MOVLB  2
01B1A:  MOVWF  x2C
01B1C:  RRCF   01,W
01B1E:  MOVWF  x2B
01B20:  RRCF   x2C,F
01B22:  RRCF   x2B,F
01B24:  MOVLW  3F
01B26:  ANDWF  x2C,F
....................  
....................    
....................    g_Total_mA = (float)(g_Lsense + g_Rsense);  //calculate total current in both mastoids 
01B28:  MOVF   x2B,W
01B2A:  ADDWF  x29,W
01B2C:  MOVWF  01
01B2E:  MOVF   x2C,W
01B30:  ADDWFC x2A,W
01B32:  MOVWF  03
01B34:  MOVFF  01,265
01B38:  MOVWF  x66
01B3A:  MOVLB  0
01B3C:  CALL   098C
01B40:  MOVFF  03,230
01B44:  MOVFF  02,22F
01B48:  MOVFF  01,22E
01B4C:  MOVFF  00,22D
....................    g_Contact = 7;    //start with all three electrodes good
01B50:  MOVLW  07
01B52:  MOVLB  2
01B54:  MOVWF  x3F
....................    
....................    
....................     if((g_Lsense) && (g_Rsense))  //if currents are non-zero 
01B56:  MOVF   x29,W
01B58:  IORWF  x2A,W
01B5A:  BZ    1BC0
01B5C:  MOVF   x2B,W
01B5E:  IORWF  x2C,W
01B60:  BZ    1BC0
....................     {
....................         if( (g_Rsense / g_Lsense) >= 3)  //left side cuurent low
01B62:  MOVFF  22C,262
01B66:  MOVFF  22B,261
01B6A:  MOVFF  22A,264
01B6E:  MOVFF  229,263
01B72:  MOVLB  0
01B74:  CALL   12C2
01B78:  MOVFF  02,262
01B7C:  MOVFF  01,261
01B80:  MOVLB  2
01B82:  MOVF   x62,F
01B84:  BNZ   1B8C
01B86:  MOVF   x61,W
01B88:  SUBLW  02
01B8A:  BC    1B92
....................         {
....................             bit_clear(g_Contact, LEFT_Flg);  //clear flag
01B8C:  BCF    x3F.0
....................             bit_set(g_Contact, RIGHT_Flg);  //set flag
01B8E:  BSF    x3F.2
....................         }
01B90:  BRA    1BC0
....................         else if( (g_Lsense / g_Rsense) >= 3) 
01B92:  MOVFF  22A,262
01B96:  MOVFF  229,261
01B9A:  MOVFF  22C,264
01B9E:  MOVFF  22B,263
01BA2:  MOVLB  0
01BA4:  CALL   12C2
01BA8:  MOVFF  02,262
01BAC:  MOVFF  01,261
01BB0:  MOVLB  2
01BB2:  MOVF   x62,F
01BB4:  BNZ   1BBC
01BB6:  MOVF   x61,W
01BB8:  SUBLW  02
01BBA:  BC    1BC0
....................         {
....................             bit_clear(g_Contact, RIGHT_Flg);
01BBC:  BCF    x3F.2
....................             bit_set(g_Contact, LEFT_Flg);  //set flag
01BBE:  BSF    x3F.0
....................         }
....................     }
....................     
....................    if(g_State == TREAT) {
01BC0:  MOVF   x1F,W
01BC2:  SUBLW  02
01BC4:  BNZ   1C80
....................        ohms = (g_Vsense * 100)/g_Total_mA;  //calulate forhead resistance, R=E/I
01BC6:  MOVFF  228,262
01BCA:  MOVFF  227,261
01BCE:  CLRF   x64
01BD0:  MOVLW  64
01BD2:  MOVWF  x63
01BD4:  MOVLB  0
01BD6:  BRA    18A6
01BD8:  MOVFF  02,262
01BDC:  MOVFF  01,261
01BE0:  MOVFF  02,266
01BE4:  MOVFF  01,265
01BE8:  CALL   098C
01BEC:  MOVFF  03,266
01BF0:  MOVFF  02,265
01BF4:  MOVFF  01,264
01BF8:  MOVFF  00,263
01BFC:  MOVFF  230,26A
01C00:  MOVFF  22F,269
01C04:  MOVFF  22E,268
01C08:  MOVFF  22D,267
01C0C:  BRA    18CE
01C0E:  MOVFF  03,26D
01C12:  MOVFF  02,26C
01C16:  MOVFF  01,26B
01C1A:  MOVFF  00,26A
01C1E:  CALL   0790
01C22:  MOVFF  02,260
01C26:  MOVFF  01,25F
....................           
....................        if(Ohms > 100)
01C2A:  MOVLB  2
01C2C:  MOVF   x60,F
01C2E:  BNZ   1C36
01C30:  MOVF   x5F,W
01C32:  SUBLW  64
01C34:  BC    1C3A
....................             bit_clear(g_Contact,FORE_Flg);
01C36:  BCF    x3F.1
01C38:  BRA    1C3C
....................        else
....................            bit_set(g_Contact,FORE_Flg);
01C3A:  BSF    x3F.1
....................             
....................         if(g_Contact < 7)
01C3C:  MOVF   x3F,W
01C3E:  SUBLW  06
01C40:  BNC   1C60
....................         {
....................            g_Setpoint_mA = 100;
01C42:  CLRF   x38
01C44:  CLRF   x37
01C46:  MOVLW  48
01C48:  MOVWF  x36
01C4A:  MOVLW  85
01C4C:  MOVWF  x35
....................            g_Gain_Err = FAST_RAMP;
01C4E:  MOVLW  0A
01C50:  MOVWF  x34
01C52:  MOVLW  D7
01C54:  MOVWF  x33
01C56:  MOVLW  23
01C58:  MOVWF  x32
01C5A:  MOVLW  79
01C5C:  MOVWF  x31
....................         }
01C5E:  BRA    1C80
....................         else
....................        {
....................            g_Setpoint_mA = g_MaxSetPoint;
01C60:  MOVFF  23C,238
01C64:  MOVFF  23B,237
01C68:  MOVFF  23A,236
01C6C:  MOVFF  239,235
....................            g_Gain_Err =SLOW_RAMP;
01C70:  MOVLW  6F
01C72:  MOVWF  x34
01C74:  MOVLW  12
01C76:  MOVWF  x33
01C78:  MOVLW  03
01C7A:  MOVWF  x32
01C7C:  MOVLW  76
01C7E:  MOVWF  x31
....................        }
....................     }
....................    
....................     if(g_State == WAIT) {
01C80:  DECFSZ x1F,W
01C82:  BRA    1CF2
....................         if(g_Setpoint_mA >5) {
01C84:  CLRF   x6D
01C86:  CLRF   x6C
01C88:  MOVLW  20
01C8A:  MOVWF  x6B
01C8C:  MOVLW  81
01C8E:  MOVWF  x6A
01C90:  MOVFF  238,271
01C94:  MOVFF  237,270
01C98:  MOVFF  236,26F
01C9C:  MOVFF  235,26E
01CA0:  MOVLB  0
01CA2:  CALL   0716
01CA6:  BNC   1CDE
....................             g_Setpoint_mA-=5;
01CA8:  BSF    3FD8.1
01CAA:  MOVFF  238,26D
01CAE:  MOVFF  237,26C
01CB2:  MOVFF  236,26B
01CB6:  MOVFF  235,26A
01CBA:  MOVLB  2
01CBC:  CLRF   x71
01CBE:  CLRF   x70
01CC0:  MOVLW  20
01CC2:  MOVWF  x6F
01CC4:  MOVLW  81
01CC6:  MOVWF  x6E
01CC8:  MOVLB  0
01CCA:  CALL   03A2
01CCE:  MOVFF  03,238
01CD2:  MOVFF  02,237
01CD6:  MOVFF  01,236
01CDA:  MOVFF  00,235
....................           //  fprintf(DEBUG,"\n\r %f", g_SetPoint_mA);
....................         }
....................        g_Contact = 0;       //all electrodes are poor contact     
01CDE:  MOVLB  2
01CE0:  CLRF   x3F
....................        g_Gain_Err = FAST_RAMP;
01CE2:  MOVLW  0A
01CE4:  MOVWF  x34
01CE6:  MOVLW  D7
01CE8:  MOVWF  x33
01CEA:  MOVLW  23
01CEC:  MOVWF  x32
01CEE:  MOVLW  79
01CF0:  MOVWF  x31
....................    
....................    }
....................     PID(RUN);   //update PID
01CF2:  MOVLW  01
01CF4:  MOVWF  x61
01CF6:  MOVLB  0
01CF8:  CALL   07CC
01CFC:  RETURN 0
.................... }
.................... 
.................... 
.................... /**
....................     Get headset battery voltage and current and scale battery voltage to a %level
.................... **/
.................... void    Update_BatteryVI(void)
.................... {
....................     float ftemp;
....................  //   int16_t const DEAD_BATT = 340;
....................     
....................     set_adc_channel(BATT_V);  //set ADC channel
*
00CB4:  MOVLW  03
00CB6:  MOVLB  3E
00CB8:  MOVWF  xF1
....................     delay_us(100);
00CBA:  MOVLW  64
00CBC:  MOVLB  2
00CBE:  MOVWF  x5F
00CC0:  MOVLB  0
00CC2:  RCALL  0C90
....................     ftemp= (float)read_adc();
00CC4:  MOVLB  3E
00CC6:  BSF    xF8.0
00CC8:  NOP   
00CCA:  BTFSC  xF8.0
00CCC:  BRA    0CCA
00CCE:  MOVFFL 3EF0,02
00CD4:  MOVFFL 3EEF,01
00CDA:  RRCF   02,W
00CDC:  MOVWF  03
00CDE:  RRCF   01,W
00CE0:  MOVWF  02
00CE2:  RRCF   03,F
00CE4:  RRCF   02,F
00CE6:  MOVLW  3F
00CE8:  ANDWF  03,F
00CEA:  MOVFF  02,265
00CEE:  MOVFF  03,266
00CF2:  MOVLB  0
00CF4:  RCALL  098C
00CF6:  MOVFF  03,25E
00CFA:  MOVFF  02,25D
00CFE:  MOVFF  01,25C
00D02:  MOVFF  00,25B
....................     g_Batt_Volts = (long)(ftemp * 0.64) ;   //100x battery voltage, 0.00322 V/lsb * 2(scale) * 100 = 0.64
00D06:  MOVFF  25E,26D
00D0A:  MOVFF  25D,26C
00D0E:  MOVFF  25C,26B
00D12:  MOVFF  25B,26A
00D16:  MOVLW  0A
00D18:  MOVLB  2
00D1A:  MOVWF  x71
00D1C:  MOVLW  D7
00D1E:  MOVWF  x70
00D20:  MOVLW  23
00D22:  MOVWF  x6F
00D24:  MOVLW  7E
00D26:  MOVWF  x6E
00D28:  MOVLB  0
00D2A:  RCALL  061A
00D2C:  MOVFF  03,26D
00D30:  MOVFF  02,26C
00D34:  MOVFF  01,26B
00D38:  MOVFF  00,26A
00D3C:  RCALL  0790
00D3E:  MOVFF  02,224
00D42:  MOVFF  01,223
....................       
....................     set_adc_channel(BATT_I);  //set ADC channel
00D46:  MOVLW  05
00D48:  MOVLB  3E
00D4A:  MOVWF  xF1
....................     delay_us(100);
00D4C:  MOVLW  64
00D4E:  MOVLB  2
00D50:  MOVWF  x5F
00D52:  MOVLB  0
00D54:  RCALL  0C90
....................     ftemp= (float)read_adc();
00D56:  MOVLB  3E
00D58:  BSF    xF8.0
00D5A:  NOP   
00D5C:  BTFSC  xF8.0
00D5E:  BRA    0D5C
00D60:  MOVFFL 3EF0,02
00D66:  MOVFFL 3EEF,01
00D6C:  RRCF   02,W
00D6E:  MOVWF  03
00D70:  RRCF   01,W
00D72:  MOVWF  02
00D74:  RRCF   03,F
00D76:  RRCF   02,F
00D78:  MOVLW  3F
00D7A:  ANDWF  03,F
00D7C:  MOVFF  02,265
00D80:  MOVFF  03,266
00D84:  MOVLB  0
00D86:  RCALL  098C
00D88:  MOVFF  03,25E
00D8C:  MOVFF  02,25D
00D90:  MOVFF  01,25C
00D94:  MOVFF  00,25B
....................     g_Batt_Amps  = (long)(ftemp *3.22);   //0.00322/lsb x 1000mA/V = 3.22
00D98:  MOVFF  25E,26D
00D9C:  MOVFF  25D,26C
00DA0:  MOVFF  25C,26B
00DA4:  MOVFF  25B,26A
00DA8:  MOVLW  7B
00DAA:  MOVLB  2
00DAC:  MOVWF  x71
00DAE:  MOVLW  14
00DB0:  MOVWF  x70
00DB2:  MOVLW  4E
00DB4:  MOVWF  x6F
00DB6:  MOVLW  80
00DB8:  MOVWF  x6E
00DBA:  MOVLB  0
00DBC:  RCALL  061A
00DBE:  MOVFF  03,26D
00DC2:  MOVFF  02,26C
00DC6:  MOVFF  01,26B
00DCA:  MOVFF  00,26A
00DCE:  RCALL  0790
00DD0:  MOVFF  02,226
00DD4:  MOVFF  01,225
00DD8:  RETURN 0
....................  
....................   //  fprintf(DEBUG,"\n\r %lu, %lu,",  g_Batt_Volts , g_Batt_Amps );
....................     
....................  //   if(g_Batt_Volts < DEAD_BATT)    //at dead battery
....................  //    {
....................  //        fprintf(DEBUG,"\n\r Dead Battery");
....................   //       Go_To_Sleep();   //shutdown
....................    //  }  
.................... }
.................... 
.................... 
.................... 
.................... /******************************************************************************
.................... *
.................... * FUNCTION     : PID(uint8_t Cmd). Called when there is fresh VI data 
.................... * INPUTS       : command byte - RUN or CLEAR
.................... * OUTPUTS      : g_DACVal byte to DAC
.................... * RETURNS      : none
.................... * DESCRIPTION  : Usa a PI loop to control the stimulation voltage to 
....................    track to a treatment current setpoint
.................... /*****************************************************************************/
.................... 
.................... void   PID(uint8_t Cmd)
.................... {
....................     static float    Err_Integral = 0;
....................     float   Error;
....................     float temp1;
....................   
....................     disable_interrupts(INT_TIMER1);
*
007CC:  MOVLB  39
007CE:  BCF    x94.0
.................... 
....................     switch(Cmd)
007D0:  MOVLB  2
007D2:  MOVF   x61,W
007D4:  XORLW  00
007D6:  MOVLB  0
007D8:  BZ    07E0
007DA:  XORLW  01
007DC:  BZ    0808
007DE:  BRA    0912
....................      {
....................          case CLEAR: //reset things
....................              Err_Integral = 0;
007E0:  MOVLB  2
007E2:  CLRF   x4F
007E4:  CLRF   x4E
007E6:  CLRF   x4D
007E8:  CLRF   x4C
....................              g_DACVal = 0;
007EA:  CLRF   x3E
007EC:  CLRF   x3D
....................              temp1 = 0;
007EE:  CLRF   x69
007F0:  CLRF   x68
007F2:  CLRF   x67
007F4:  CLRF   x66
....................              g_Total_mA = 0;
007F6:  CLRF   x30
007F8:  CLRF   x2F
007FA:  CLRF   x2E
007FC:  CLRF   x2D
....................              g_Lsense = 0;
007FE:  CLRF   x2A
00800:  CLRF   x29
....................              g_Rsense = 0;
00802:  CLRF   x2C
00804:  CLRF   x2B
....................              
....................              break;
00806:  BRA    0914
....................                
....................         case RUN:   //run the control loop using mA  setpoint
....................             Error = g_Gain_Err * (g_Setpoint_mA - g_Total_mA);
00808:  BSF    3FD8.1
0080A:  MOVFF  238,26D
0080E:  MOVFF  237,26C
00812:  MOVFF  236,26B
00816:  MOVFF  235,26A
0081A:  MOVFF  230,271
0081E:  MOVFF  22F,270
00822:  MOVFF  22E,26F
00826:  MOVFF  22D,26E
0082A:  RCALL  03A2
0082C:  MOVFF  234,26D
00830:  MOVFF  233,26C
00834:  MOVFF  232,26B
00838:  MOVFF  231,26A
0083C:  MOVFF  03,271
00840:  MOVFF  02,270
00844:  MOVFF  01,26F
00848:  MOVFF  00,26E
0084C:  RCALL  061A
0084E:  MOVFF  03,265
00852:  MOVFF  02,264
00856:  MOVFF  01,263
0085A:  MOVFF  00,262
....................             Err_Integral += Error;  //update integral
0085E:  BCF    3FD8.1
00860:  MOVFF  24F,26D
00864:  MOVFF  24E,26C
00868:  MOVFF  24D,26B
0086C:  MOVFF  24C,26A
00870:  MOVFF  265,271
00874:  MOVFF  264,270
00878:  MOVFF  263,26F
0087C:  MOVFF  262,26E
00880:  RCALL  03A2
00882:  MOVFF  03,24F
00886:  MOVFF  02,24E
0088A:  MOVFF  01,24D
0088E:  MOVFF  00,24C
....................               
....................             if (Err_Integral > 150)  //g_MaxSetpoint)    //limit integral to prevent rollover
00892:  MOVLB  2
00894:  CLRF   x6D
00896:  CLRF   x6C
00898:  MOVLW  16
0089A:  MOVWF  x6B
0089C:  MOVLW  86
0089E:  MOVWF  x6A
008A0:  MOVFF  24F,271
008A4:  MOVFF  24E,270
008A8:  MOVFF  24D,26F
008AC:  MOVFF  24C,26E
008B0:  MOVLB  0
008B2:  RCALL  0716
008B4:  BNC   08C6
....................                 Err_Integral = 150; //g_MaxSetPoint;
008B6:  MOVLB  2
008B8:  CLRF   x4F
008BA:  CLRF   x4E
008BC:  MOVLW  16
008BE:  MOVWF  x4D
008C0:  MOVLW  86
008C2:  MOVWF  x4C
008C4:  MOVLB  0
....................           
....................             if (Err_Integral < 0)   //limit to positive value
008C6:  MOVFF  24F,26D
008CA:  MOVFF  24E,26C
008CE:  MOVFF  24D,26B
008D2:  MOVFF  24C,26A
008D6:  MOVLB  2
008D8:  CLRF   x71
008DA:  CLRF   x70
008DC:  CLRF   x6F
008DE:  CLRF   x6E
008E0:  MOVLB  0
008E2:  RCALL  0716
008E4:  BNC   08F2
....................                 Err_Integral = 0;
008E6:  MOVLB  2
008E8:  CLRF   x4F
008EA:  CLRF   x4E
008EC:  CLRF   x4D
008EE:  CLRF   x4C
008F0:  MOVLB  0
....................                   
....................             g_DACVal = (long) Err_Integral;    //convert integral to DAC value
008F2:  MOVFF  24F,26D
008F6:  MOVFF  24E,26C
008FA:  MOVFF  24D,26B
008FE:  MOVFF  24C,26A
00902:  RCALL  0790
00904:  MOVFF  02,23E
00908:  MOVFF  01,23D
....................        //    fprintf(DEBUG,"\n\r %f, %f, %lu, %lu, %lu, %lu, %lu ", g_Setpoint_mA, Err_Integral, g_DACVal, g_Lsense,g_Rsense, g_Vsense, g_Seconds);
....................             break;
0090C:  MOVLB  2
0090E:  BRA    0914
00910:  MOVLB  0
....................            
....................        Default:
....................           break;
00912:  MOVLB  2
....................      }
....................  
....................      set_pwm1_duty(g_DACVal);  //update PWM count
00914:  MOVFFL 23E,3F7D
0091A:  MOVFFL 23D,3F7C
....................      enable_interrupts(INT_TIMER1);
00920:  MOVLB  39
00922:  BSF    x94.0
00924:  MOVLB  0
00926:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /**
.................... Battery charger function 
....................     Battery PWM range is 100 to 240. Reducing PWM value increase charge voltage
....................     Start with constant curent then constant voltage till current level reaches minimum
.................... **/
.................... void    Charge_Battery(void)
.................... {
....................     int16_t const PWM_MAX = 250; //this PWM value creates the maximum charging voltage
....................     int16_t const FULL_BATT = 420;  //volts *100
....................     int16_t const END_AMPS = 100;  //end current (10% of rated AH *2
....................     uint16_t const CC_AMPS = 500l;    //charge current mA
....................     uint16_t const MAX_TIME = 3600l;    //2 hours in seconds to timeout at at contant voltage mode
....................     uint16_t const CC_TIME = 7200l;     //2 hours in seconds to timeout at at contant current mode
....................     static uint16_t Batt_PWM;
....................     static uint16_t  Charge_Time;
....................     static uint8_t   Led, Bars;
....................     static uint16_t   Offset;
....................     
....................     if(!Input(CHRGR_ON))  //if charger is not attached
*
0148C:  BSF    3FC3.2
0148E:  BTFSC  3FCB.2
01490:  BRA    149A
....................     {
....................         g_Charge_State = INIT_CHARGE; //reset charge state
01492:  MOVLB  2
01494:  CLRF   x40
....................     }
01496:  BRA    1774
01498:  MOVLB  0
....................     else    //charger is attached
....................     {
....................         output_high(ENB_SW_BAT);  //turn off power to rest of circuit
0149A:  BCF    3FC4.4
0149C:  BSF    3FBC.4
....................                  
....................         switch (g_Charge_State)
0149E:  MOVLB  2
014A0:  MOVF   x40,W
014A2:  XORLW  00
014A4:  MOVLB  0
014A6:  BZ    14BA
014A8:  XORLW  01
014AA:  BZ    14E0
014AC:  XORLW  03
014AE:  BTFSC  3FD8.2
014B0:  BRA    157E
014B2:  XORLW  01
014B4:  BTFSC  3FD8.2
014B6:  BRA    15FC
014B8:  BRA    1618
....................         {
....................             case INIT_CHARGE:
....................             
....................                 Charge_Time = 0;
014BA:  MOVLB  2
014BC:  CLRF   x53
014BE:  CLRF   x52
....................                 Bars = 0;
014C0:  CLRF   x55
....................                 g_Charge_State = CC;
014C2:  MOVLW  01
014C4:  MOVWF  x40
....................                 Batt_PWM = 0;
014C6:  CLRF   x51
014C8:  CLRF   x50
....................                 set_pwm2_duty(Batt_PWM);   //turn off charger PWM
014CA:  MOVFFL 251,3F79
014D0:  MOVFFL 250,3F78
....................                 Offset = g_Batt_Amps;
014D6:  MOVFF  226,257
014DA:  MOVFF  225,256
....................                 break;
014DE:  BRA    161A
....................                 
....................             case CC:    //constant current mode
....................             
....................                 if(g_Batt_Amps > Offset)    //adjust charging current for offset
014E0:  MOVLB  2
014E2:  MOVF   x57,W
014E4:  SUBWF  x26,W
014E6:  BNC   14FA
014E8:  BNZ   14F0
014EA:  MOVF   x25,W
014EC:  SUBWF  x56,W
014EE:  BC    14FA
....................                    g_Batt_Amps -= Offset;
014F0:  MOVF   x56,W
014F2:  SUBWF  x25,F
014F4:  MOVF   x57,W
014F6:  SUBWFB x26,F
014F8:  BRA    14FE
....................                 else
....................                    g_Batt_Amps = 0;
014FA:  CLRF   x26
014FC:  CLRF   x25
....................                
....................                 if( (g_Batt_Amps < CC_AMPS -1L) && (g_Batt_Volts <= FULL_BATT) )
014FE:  MOVF   x26,W
01500:  SUBLW  01
01502:  BNC   152E
01504:  BNZ   150C
01506:  MOVF   x25,W
01508:  SUBLW  F2
0150A:  BNC   152E
0150C:  MOVF   x24,W
0150E:  SUBLW  01
01510:  BNC   152E
01512:  BNZ   151A
01514:  MOVF   x23,W
01516:  SUBLW  A4
01518:  BNC   152E
....................                 {
....................                     if(Batt_PWM < PWM_MAX)
0151A:  MOVF   x51,F
0151C:  BNZ   152C
0151E:  MOVF   x50,W
01520:  SUBLW  F9
01522:  BNC   152C
....................                     {
....................                         Batt_PWM +=2;   //increase PWM, inrease charge voltage
01524:  MOVLW  02
01526:  ADDWF  x50,F
01528:  MOVLW  00
0152A:  ADDWFC x51,F
....................                     }    
....................                 }
0152C:  BRA    154C
....................                 else if(g_Batt_Amps > CC_AMPS +5L) 
0152E:  MOVF   x26,W
01530:  SUBLW  00
01532:  BC    154C
01534:  XORLW  FF
01536:  BNZ   153E
01538:  MOVF   x25,W
0153A:  SUBLW  F9
0153C:  BC    154C
....................                 {
....................                     if(Batt_PWM)    //if non-zero
0153E:  MOVF   x50,W
01540:  IORWF  x51,W
01542:  BZ    154C
....................                         Batt_PWM--;     //reduce duty cycle, reduce charge voltage
01544:  MOVF   x50,W
01546:  BTFSC  3FD8.2
01548:  DECF   x51,F
0154A:  DECF   x50,F
....................                 }
....................                 
....................                 //if at full voltage or time out or at max charge voltage
....................                 if( (g_Batt_Volts >=  FULL_BATT) || (Charge_Time > CC_TIME) )  
0154C:  MOVF   x24,W
0154E:  SUBLW  00
01550:  BC    155C
01552:  XORLW  FF
01554:  BNZ   156C
01556:  MOVF   x23,W
01558:  SUBLW  A3
0155A:  BNC   156C
0155C:  MOVF   x53,W
0155E:  SUBLW  1B
01560:  BC    1576
01562:  XORLW  FF
01564:  BNZ   156C
01566:  MOVF   x52,W
01568:  SUBLW  20
0156A:  BC    1576
....................                 {
....................                     g_Charge_State = CV;    //change to CV state
0156C:  MOVLW  02
0156E:  MOVWF  x40
....................                     Charge_Time = 0;      //reset safety timer
01570:  CLRF   x53
01572:  CLRF   x52
....................                 }
01574:  BRA    157C
....................                 else
....................                 {
....................                      Charge_Time++;    //increment timer 
01576:  INCF   x52,F
01578:  BTFSC  3FD8.2
0157A:  INCF   x53,F
....................                 }
....................                 break;
0157C:  BRA    161A
....................         
....................             case CV:    //constant voltage
....................                   if(g_Batt_Amps > Offset)    //adjust charging current for offset
0157E:  MOVLB  2
01580:  MOVF   x57,W
01582:  SUBWF  x26,W
01584:  BNC   1598
01586:  BNZ   158E
01588:  MOVF   x25,W
0158A:  SUBWF  x56,W
0158C:  BC    1598
....................                    g_Batt_Amps -= Offset;
0158E:  MOVF   x56,W
01590:  SUBWF  x25,F
01592:  MOVF   x57,W
01594:  SUBWFB x26,F
01596:  BRA    159C
....................                 else
....................                    g_Batt_Amps = 0;
01598:  CLRF   x26
0159A:  CLRF   x25
....................                     
....................                 if(g_Batt_Volts >  FULL_BATT)
0159C:  MOVF   x24,W
0159E:  SUBLW  00
015A0:  BC    15B4
015A2:  XORLW  FF
015A4:  BNZ   15AC
015A6:  MOVF   x23,W
015A8:  SUBLW  A4
015AA:  BC    15B4
....................                 {
....................                    Batt_PWM--;  //decrase charge voltage
015AC:  MOVF   x50,W
015AE:  BTFSC  3FD8.2
015B0:  DECF   x51,F
015B2:  DECF   x50,F
....................                 }
....................                 
....................                  if( (g_Batt_Volts <  FULL_BATT) && (Batt_PWM < PWM_MAX))
015B4:  MOVF   x24,W
015B6:  SUBLW  01
015B8:  BNC   15D2
015BA:  BNZ   15C2
015BC:  MOVF   x23,W
015BE:  SUBLW  A3
015C0:  BNC   15D2
015C2:  MOVF   x51,F
015C4:  BNZ   15D2
015C6:  MOVF   x50,W
015C8:  SUBLW  F9
015CA:  BNC   15D2
....................                 {
....................                    Batt_PWM++;  //increase charge voltage
015CC:  INCF   x50,F
015CE:  BTFSC  3FD8.2
015D0:  INCF   x51,F
....................                 }
....................                 
....................                 //if at end current or at end of 2 hours
....................                 if( (g_Batt_Amps <= END_AMPS) || (Charge_Time > MAX_TIME))  
015D2:  MOVF   x26,F
015D4:  BNZ   15DC
015D6:  MOVF   x25,W
015D8:  SUBLW  64
015DA:  BC    15EC
015DC:  MOVF   x53,W
015DE:  SUBLW  0D
015E0:  BC    15F4
015E2:  XORLW  FF
015E4:  BNZ   15EC
015E6:  MOVF   x52,W
015E8:  SUBLW  10
015EA:  BC    15F4
....................                 {
....................                     g_Charge_State = FULL;    //change state
015EC:  MOVLW  03
015EE:  MOVWF  x40
....................                     Batt_PWM = 0;   //turn off charger voltage
015F0:  CLRF   x51
015F2:  CLRF   x50
....................                 } 
....................                 Charge_Time++;    //increment timer
015F4:  INCF   x52,F
015F6:  BTFSC  3FD8.2
015F8:  INCF   x53,F
....................               
....................                 break;
015FA:  BRA    161A
....................             
....................             case FULL:
....................                 Batt_PWM = 0; //disable charge voltage
015FC:  MOVLB  2
015FE:  CLRF   x51
01600:  CLRF   x50
....................                 fprintf(DEBUG,"Battery Full");
01602:  MOVLW  7E
01604:  MOVWF  3FF6
01606:  MOVLW  02
01608:  MOVWF  3FF7
0160A:  MOVLB  0
0160C:  CALL   095C
....................                 Go_To_Sleep();
01610:  RCALL  1308
....................                 break;
01612:  MOVLB  2
01614:  BRA    161A
01616:  MOVLB  0
....................                 
....................             default:
....................                 break;
01618:  MOVLB  2
....................         }
....................         
....................         switch(Led)
0161A:  MOVF   x54,W
0161C:  XORLW  00
0161E:  MOVLB  0
01620:  BZ    1630
01622:  XORLW  01
01624:  BZ    163A
01626:  XORLW  03
01628:  BZ    1644
0162A:  XORLW  06
0162C:  BZ    164E
0162E:  BRA    165A
....................         {
....................             case 0:
....................                 output_high(BLUE_LED);
01630:  BCF    3FC2.7
01632:  BSF    3FBA.7
....................                 Led++;
01634:  MOVLB  2
01636:  INCF   x54,F
....................                 break;
01638:  BRA    1662
....................             case 1:
....................                output_low(BLUE_LED);
0163A:  BCF    3FC2.7
0163C:  BCF    3FBA.7
....................                 Led++;
0163E:  MOVLB  2
01640:  INCF   x54,F
....................                 break; 
01642:  BRA    1662
....................             case 2:
....................                output_low(BLUE_LED);
01644:  BCF    3FC2.7
01646:  BCF    3FBA.7
....................                 Led++;
01648:  MOVLB  2
0164A:  INCF   x54,F
....................                 break;    
0164C:  BRA    1662
....................             case 4:
....................                output_low(BLUE_LED);
0164E:  BCF    3FC2.7
01650:  BCF    3FBA.7
....................                 Led=0;
01652:  MOVLB  2
01654:  CLRF   x54
....................                 break;
01656:  BRA    1662
01658:  MOVLB  0
....................             default:
....................                  Led=0;
0165A:  MOVLB  2
0165C:  CLRF   x54
....................                  output_low(BLUE_LED);
0165E:  BCF    3FC2.7
01660:  BCF    3FBA.7
....................                  break;    
....................                 
....................                 
....................         }
....................         set_pwm2_duty(Batt_PWM);   //update PWM output
01662:  MOVFFL 251,3F79
01668:  MOVFFL 250,3F78
....................         fprintf(DEBUG,"\n\r %u, %lu , %lu, %lu, %lu, %lu ", g_Charge_State, Batt_PWM,  g_Batt_Volts, g_Batt_Amps, (g_Batt_Amps + Offset), Charge_Time);
0166E:  MOVF   x56,W
01670:  ADDWF  x25,W
01672:  MOVWF  x5B
01674:  MOVF   x57,W
01676:  ADDWFC x26,W
01678:  MOVWF  x5C
0167A:  MOVLW  8C
0167C:  MOVWF  3FF6
0167E:  MOVLW  02
01680:  MOVWF  3FF7
01682:  MOVLW  03
01684:  MOVWF  x65
01686:  MOVLB  0
01688:  CALL   09C2
0168C:  MOVFF  240,265
01690:  MOVLW  1B
01692:  MOVLB  2
01694:  MOVWF  x66
01696:  MOVLB  0
01698:  RCALL  1400
0169A:  MOVLW  2C
0169C:  MOVLB  39
0169E:  BTFSS  xA3.4
016A0:  BRA    169E
016A2:  MOVLB  3D
016A4:  MOVWF  xEA
016A6:  MOVLW  20
016A8:  MOVLB  39
016AA:  BTFSS  xA3.4
016AC:  BRA    16AA
016AE:  MOVLB  3D
016B0:  MOVWF  xEA
016B2:  MOVLW  10
016B4:  MOVWF  3FE9
016B6:  MOVFF  251,266
016BA:  MOVFF  250,265
016BE:  MOVLB  0
016C0:  CALL   0DDA
016C4:  MOVLW  96
016C6:  MOVWF  3FF6
016C8:  MOVLW  02
016CA:  MOVWF  3FF7
016CC:  MOVLW  03
016CE:  MOVLB  2
016D0:  MOVWF  x65
016D2:  MOVLB  0
016D4:  CALL   09C2
016D8:  MOVLW  10
016DA:  MOVWF  3FE9
016DC:  MOVFF  224,266
016E0:  MOVFF  223,265
016E4:  CALL   0DDA
016E8:  MOVLW  2C
016EA:  MOVLB  39
016EC:  BTFSS  xA3.4
016EE:  BRA    16EC
016F0:  MOVLB  3D
016F2:  MOVWF  xEA
016F4:  MOVLW  20
016F6:  MOVLB  39
016F8:  BTFSS  xA3.4
016FA:  BRA    16F8
016FC:  MOVLB  3D
016FE:  MOVWF  xEA
01700:  MOVLW  10
01702:  MOVWF  3FE9
01704:  MOVFF  226,266
01708:  MOVFF  225,265
0170C:  MOVLB  0
0170E:  CALL   0DDA
01712:  MOVLW  2C
01714:  MOVLB  39
01716:  BTFSS  xA3.4
01718:  BRA    1716
0171A:  MOVLB  3D
0171C:  MOVWF  xEA
0171E:  MOVLW  20
01720:  MOVLB  39
01722:  BTFSS  xA3.4
01724:  BRA    1722
01726:  MOVLB  3D
01728:  MOVWF  xEA
0172A:  MOVLW  10
0172C:  MOVWF  3FE9
0172E:  MOVFF  25C,266
01732:  MOVFF  25B,265
01736:  MOVLB  0
01738:  CALL   0DDA
0173C:  MOVLW  2C
0173E:  MOVLB  39
01740:  BTFSS  xA3.4
01742:  BRA    1740
01744:  MOVLB  3D
01746:  MOVWF  xEA
01748:  MOVLW  20
0174A:  MOVLB  39
0174C:  BTFSS  xA3.4
0174E:  BRA    174C
01750:  MOVLB  3D
01752:  MOVWF  xEA
01754:  MOVLW  10
01756:  MOVWF  3FE9
01758:  MOVFF  253,266
0175C:  MOVFF  252,265
01760:  MOVLB  0
01762:  CALL   0DDA
01766:  MOVLW  20
01768:  MOVLB  39
0176A:  BTFSS  xA3.4
0176C:  BRA    176A
0176E:  MOVLB  3D
01770:  MOVWF  xEA
01772:  MOVLB  2
....................     }
01774:  MOVLB  0
01776:  GOTO   186A (RETURN)
....................  }
.................... 
.................... 
.................... 
....................   
.................... 
.................... /**
.................... *  Process the data packet received From the app. Packet starts with a '$', fields
.................... * are deliniated by a '/', packet ended with a '#'. The packet start and stop 
.................... * characters have been renoved by the serial port ISR
.................... **/   
.................... void Process_Command(void)   
.................... { 
....................     char  term[6];
....................     char  *pntr;    //fixed 20170728 JPC
....................     uint8_t n, Id; //TPP ID  0-9
....................     
.................... 
....................     strcpy(term,"/");
*
023EE:  MOVLW  02
023F0:  MOVWF  3FEA
023F2:  MOVLW  5B
023F4:  MOVWF  3FE9
023F6:  MOVLW  00
023F8:  CALL   0112
023FC:  TBLRD*-
023FE:  TBLRD*+
02400:  MOVF   3FF5,W
02402:  MOVWF  3FEE
02404:  IORLW  00
02406:  BNZ   23FE
....................     pntr = strtok(g_UART.buff, term);
02408:  MOVLB  2
0240A:  CLRF   x66
0240C:  MOVLW  1F
0240E:  MOVWF  x65
02410:  MOVLW  02
02412:  MOVWF  x68
02414:  MOVLW  5B
02416:  MOVWF  x67
02418:  MOVLB  0
0241A:  RCALL  1F1A
0241C:  MOVFF  02,262
02420:  MOVFF  01,261
....................        
....................     switch(pntr)
02424:  MOVLW  FE
02426:  MOVWF  3FF6
02428:  MOVLW  02
0242A:  MOVWF  3FF7
0242C:  MOVFFL 262,3FEA
02432:  MOVFFL 261,3FE9
02438:  BRA    1FD2
0243A:  MOVF   01,W
0243C:  BZ    2458
0243E:  XORLW  01
02440:  BTFSC  3FD8.2
02442:  BRA    25BA
02444:  XORLW  03
02446:  BTFSC  3FD8.2
02448:  BRA    2734
0244A:  XORLW  01
0244C:  BTFSC  3FD8.2
0244E:  BRA    28AE
02450:  XORLW  07
02452:  BTFSC  3FD8.2
02454:  BRA    2A2E
02456:  BRA    2A74
....................     {
....................            
....................         case "set": //set the treatment setpoint
....................             fprintf(UART,"\n\r ");      //echo to app
02458:  MOVLW  AE
0245A:  MOVWF  3FF6
0245C:  MOVLW  02
0245E:  MOVWF  3FF7
02460:  RCALL  2016
....................             fprintf(UART,"\n\r $%s", pntr);     //echo command to app
02462:  MOVLW  B2
02464:  MOVWF  3FF6
02466:  MOVLW  02
02468:  MOVWF  3FF7
0246A:  MOVLW  04
0246C:  MOVLB  2
0246E:  MOVWF  x65
02470:  MOVLB  0
02472:  RCALL  2046
02474:  MOVFFL 262,3FEA
0247A:  MOVFFL 261,3FE9
02480:  CALL   110C
....................             fprintf(DEBUG,"\n\r $%s", pntr);     //echo command to app
02484:  MOVLW  BA
02486:  MOVWF  3FF6
02488:  MOVLW  02
0248A:  MOVWF  3FF7
0248C:  MOVLW  04
0248E:  MOVLB  2
02490:  MOVWF  x65
02492:  MOVLB  0
02494:  CALL   09C2
02498:  MOVFFL 262,3FEA
0249E:  MOVFFL 261,3FE9
024A4:  RCALL  207C
....................             pntr = strtok(0, term);  //get next field
024A6:  MOVLB  2
024A8:  CLRF   x66
024AA:  CLRF   x65
024AC:  MOVLW  02
024AE:  MOVWF  x68
024B0:  MOVLW  5B
024B2:  MOVWF  x67
024B4:  MOVLB  0
024B6:  RCALL  1F1A
024B8:  MOVFF  02,262
024BC:  MOVFF  01,261
....................             Id = atoi(pntr); //which is sequence number
024C0:  MOVFF  262,266
024C4:  MOVFF  261,265
024C8:  BRA    2100
024CA:  MOVFF  01,264
....................             
....................             if(Id > 15) //limit the current to 15 mA
024CE:  MOVLB  2
024D0:  MOVF   x64,W
024D2:  SUBLW  0F
024D4:  BC    24DA
....................                 Id = 15;
024D6:  MOVLW  0F
024D8:  MOVWF  x64
....................                 
....................             write_eeprom(SET_ADDR,Id); //store new max setpoint in EEPROM
024DA:  MOVF   3FD2,W
024DC:  MOVWF  00
024DE:  BCF    3FD2.7
024E0:  MOVLB  39
024E2:  CLRF   xE1
024E4:  MOVLW  01
024E6:  MOVWF  xE0
024E8:  MOVFFL 264,39E3
024EE:  BCF    xE5.6
024F0:  BCF    xE5.7
024F2:  BSF    xE5.2
024F4:  MOVLW  55
024F6:  MOVWF  xE6
024F8:  MOVLW  AA
024FA:  MOVWF  xE6
024FC:  BSF    xE5.1
024FE:  BTFSC  xE5.1
02500:  BRA    24FE
02502:  BCF    xE5.2
02504:  BCF    xE5.6
02506:  BSF    xE5.7
02508:  MOVF   00,W
0250A:  IORWF  3FD2,F
....................             g_MaxSetpoint = 40.0 * ((float)Id);  //update run time maximum current setpoint
0250C:  MOVLB  2
0250E:  CLRF   x66
02510:  MOVFF  264,265
02514:  MOVLB  0
02516:  CALL   098C
0251A:  MOVLB  2
0251C:  CLRF   x6D
0251E:  CLRF   x6C
02520:  MOVLW  20
02522:  MOVWF  x6B
02524:  MOVLW  84
02526:  MOVWF  x6A
02528:  MOVFF  03,271
0252C:  MOVFF  02,270
02530:  MOVFF  01,26F
02534:  MOVFF  00,26E
02538:  MOVLB  0
0253A:  CALL   061A
0253E:  MOVFF  03,23C
02542:  MOVFF  02,23B
02546:  MOVFF  01,23A
0254A:  MOVFF  00,239
....................             
....................                        
....................             fprintf(UART,"/%s", pntr);
0254E:  MOVLW  2F
02550:  MOVLB  39
02552:  BTFSS  xA7.5
02554:  BRA    2552
02556:  MOVLB  3D
02558:  MOVWF  xD2
0255A:  MOVFFL 262,3FEA
02560:  MOVFFL 261,3FE9
02566:  MOVLB  0
02568:  CALL   110C
....................             fprintf(UART,"/#");  //send string end
0256C:  MOVLW  2F
0256E:  MOVLB  39
02570:  BTFSS  xA7.5
02572:  BRA    2570
02574:  MOVLB  3D
02576:  MOVWF  xD2
02578:  MOVLW  23
0257A:  MOVLB  39
0257C:  BTFSS  xA7.5
0257E:  BRA    257C
02580:  MOVLB  3D
02582:  MOVWF  xD2
....................             fprintf(DEBUG,"/%s", pntr);
02584:  MOVLW  2F
02586:  MOVLB  39
02588:  BTFSS  xA3.4
0258A:  BRA    2588
0258C:  MOVLB  3D
0258E:  MOVWF  xEA
02590:  MOVFFL 262,3FEA
02596:  MOVFFL 261,3FE9
0259C:  MOVLB  0
0259E:  RCALL  207C
....................             fprintf(DEBUG,"/#");  //send string end
025A0:  MOVLW  2F
025A2:  MOVLB  39
025A4:  BTFSS  xA3.4
025A6:  BRA    25A4
025A8:  MOVLB  3D
025AA:  MOVWF  xEA
025AC:  MOVLW  23
025AE:  MOVLB  39
025B0:  BTFSS  xA3.4
025B2:  BRA    25B0
025B4:  MOVLB  3D
025B6:  MOVWF  xEA
....................              break;
025B8:  BRA    2A76
....................       
....................        case "on":   //set stimulation level and respond with data
....................             fprintf(UART,"\n\r ");      //echo to app
025BA:  MOVLW  C2
025BC:  MOVWF  3FF6
025BE:  MOVLW  02
025C0:  MOVWF  3FF7
025C2:  RCALL  2016
....................             fprintf(UART,"\n\r $%s", pntr);     //echo command to app
025C4:  MOVLW  C6
025C6:  MOVWF  3FF6
025C8:  MOVLW  02
025CA:  MOVWF  3FF7
025CC:  MOVLW  04
025CE:  MOVLB  2
025D0:  MOVWF  x65
025D2:  MOVLB  0
025D4:  RCALL  2046
025D6:  MOVFFL 262,3FEA
025DC:  MOVFFL 261,3FE9
025E2:  CALL   110C
....................             fprintf(UART,"/%u ", g_Contact);    //electrode contact
025E6:  MOVLW  2F
025E8:  MOVLB  39
025EA:  BTFSS  xA7.5
025EC:  BRA    25EA
025EE:  MOVLB  3D
025F0:  MOVWF  xD2
025F2:  MOVFF  23F,265
025F6:  MOVLW  1B
025F8:  MOVLB  2
025FA:  MOVWF  x66
025FC:  MOVLB  0
025FE:  RCALL  22A0
02600:  MOVLW  20
02602:  MOVLB  39
02604:  BTFSS  xA7.5
02606:  BRA    2604
02608:  MOVLB  3D
0260A:  MOVWF  xD2
....................             fprintf(UART,"/%lu ", g_Batt_Volts);    //battery level
0260C:  MOVLW  2F
0260E:  MOVLB  39
02610:  BTFSS  xA7.5
02612:  BRA    2610
02614:  MOVLB  3D
02616:  MOVWF  xD2
02618:  MOVLW  10
0261A:  MOVWF  3FE9
0261C:  MOVFF  224,266
02620:  MOVFF  223,265
02624:  MOVLB  0
02626:  RCALL  2330
02628:  MOVLW  20
0262A:  MOVLB  39
0262C:  BTFSS  xA7.5
0262E:  BRA    262C
02630:  MOVLB  3D
02632:  MOVWF  xD2
....................             fprintf(UART,"/%lu ", g_Seconds);    //time
02634:  MOVLW  2F
02636:  MOVLB  39
02638:  BTFSS  xA7.5
0263A:  BRA    2638
0263C:  MOVLB  3D
0263E:  MOVWF  xD2
02640:  MOVLW  10
02642:  MOVWF  3FE9
02644:  MOVFF  222,266
02648:  MOVFF  221,265
0264C:  MOVLB  0
0264E:  RCALL  2330
02650:  MOVLW  20
02652:  MOVLB  39
02654:  BTFSS  xA7.5
02656:  BRA    2654
02658:  MOVLB  3D
0265A:  MOVWF  xD2
....................             fprintf(UART,"/#");  //send string end
0265C:  MOVLW  2F
0265E:  MOVLB  39
02660:  BTFSS  xA7.5
02662:  BRA    2660
02664:  MOVLB  3D
02666:  MOVWF  xD2
02668:  MOVLW  23
0266A:  MOVLB  39
0266C:  BTFSS  xA7.5
0266E:  BRA    266C
02670:  MOVLB  3D
02672:  MOVWF  xD2
....................             fprintf(DEBUG,"\n\r $%s", pntr);     //echo command to app
02674:  MOVLW  CE
02676:  MOVWF  3FF6
02678:  MOVLW  02
0267A:  MOVWF  3FF7
0267C:  MOVLW  04
0267E:  MOVLB  2
02680:  MOVWF  x65
02682:  MOVLB  0
02684:  CALL   09C2
02688:  MOVFFL 262,3FEA
0268E:  MOVFFL 261,3FE9
02694:  RCALL  207C
....................             fprintf(DEBUG,"/%u ", g_Contact);    //electrode contact state
02696:  MOVLW  2F
02698:  MOVLB  39
0269A:  BTFSS  xA3.4
0269C:  BRA    269A
0269E:  MOVLB  3D
026A0:  MOVWF  xEA
026A2:  MOVFF  23F,265
026A6:  MOVLW  1B
026A8:  MOVLB  2
026AA:  MOVWF  x66
026AC:  MOVLB  0
026AE:  CALL   1400
026B2:  MOVLW  20
026B4:  MOVLB  39
026B6:  BTFSS  xA3.4
026B8:  BRA    26B6
026BA:  MOVLB  3D
026BC:  MOVWF  xEA
....................             fprintf(DEBUG,"/%lu ", g_Batt_Volts);   //battery level
026BE:  MOVLW  2F
026C0:  MOVLB  39
026C2:  BTFSS  xA3.4
026C4:  BRA    26C2
026C6:  MOVLB  3D
026C8:  MOVWF  xEA
026CA:  MOVLW  10
026CC:  MOVWF  3FE9
026CE:  MOVFF  224,266
026D2:  MOVFF  223,265
026D6:  MOVLB  0
026D8:  CALL   0DDA
026DC:  MOVLW  20
026DE:  MOVLB  39
026E0:  BTFSS  xA3.4
026E2:  BRA    26E0
026E4:  MOVLB  3D
026E6:  MOVWF  xEA
....................             fprintf(DEBUG,"/%lu ", g_Seconds);    //time
026E8:  MOVLW  2F
026EA:  MOVLB  39
026EC:  BTFSS  xA3.4
026EE:  BRA    26EC
026F0:  MOVLB  3D
026F2:  MOVWF  xEA
026F4:  MOVLW  10
026F6:  MOVWF  3FE9
026F8:  MOVFF  222,266
026FC:  MOVFF  221,265
02700:  MOVLB  0
02702:  CALL   0DDA
02706:  MOVLW  20
02708:  MOVLB  39
0270A:  BTFSS  xA3.4
0270C:  BRA    270A
0270E:  MOVLB  3D
02710:  MOVWF  xEA
....................             fprintf(DEBUG,"/#");  //send string end
02712:  MOVLW  2F
02714:  MOVLB  39
02716:  BTFSS  xA3.4
02718:  BRA    2716
0271A:  MOVLB  3D
0271C:  MOVWF  xEA
0271E:  MOVLW  23
02720:  MOVLB  39
02722:  BTFSS  xA3.4
02724:  BRA    2722
02726:  MOVLB  3D
02728:  MOVWF  xEA
....................             g_State = TREAT;
0272A:  MOVLW  02
0272C:  MOVLB  2
0272E:  MOVWF  x1F
....................          //   fprintf(DEBUG,"\n\r set= %f, %f ", g_Setpoint_mA, g_MaxSetPoint);
....................             break;
02730:  MOVLB  3D
02732:  BRA    2A76
.................... 
....................       case "off":   //set stimulation level to zero and respond with data
....................             fprintf(UART,"\n\r ");      //echo to app
02734:  MOVLW  D6
02736:  MOVWF  3FF6
02738:  MOVLW  02
0273A:  MOVWF  3FF7
0273C:  RCALL  2016
....................             fprintf(UART,"\n\r $%s", pntr);     //echo command to app
0273E:  MOVLW  DA
02740:  MOVWF  3FF6
02742:  MOVLW  02
02744:  MOVWF  3FF7
02746:  MOVLW  04
02748:  MOVLB  2
0274A:  MOVWF  x65
0274C:  MOVLB  0
0274E:  RCALL  2046
02750:  MOVFFL 262,3FEA
02756:  MOVFFL 261,3FE9
0275C:  CALL   110C
....................             fprintf(UART,"/%u ", g_Contact);    //electrode contact
02760:  MOVLW  2F
02762:  MOVLB  39
02764:  BTFSS  xA7.5
02766:  BRA    2764
02768:  MOVLB  3D
0276A:  MOVWF  xD2
0276C:  MOVFF  23F,265
02770:  MOVLW  1B
02772:  MOVLB  2
02774:  MOVWF  x66
02776:  MOVLB  0
02778:  RCALL  22A0
0277A:  MOVLW  20
0277C:  MOVLB  39
0277E:  BTFSS  xA7.5
02780:  BRA    277E
02782:  MOVLB  3D
02784:  MOVWF  xD2
....................             fprintf(UART,"/%lu ", g_Batt_Volts);    //battery level
02786:  MOVLW  2F
02788:  MOVLB  39
0278A:  BTFSS  xA7.5
0278C:  BRA    278A
0278E:  MOVLB  3D
02790:  MOVWF  xD2
02792:  MOVLW  10
02794:  MOVWF  3FE9
02796:  MOVFF  224,266
0279A:  MOVFF  223,265
0279E:  MOVLB  0
027A0:  RCALL  2330
027A2:  MOVLW  20
027A4:  MOVLB  39
027A6:  BTFSS  xA7.5
027A8:  BRA    27A6
027AA:  MOVLB  3D
027AC:  MOVWF  xD2
....................             fprintf(UART,"/%lu ", g_Seconds);    //time
027AE:  MOVLW  2F
027B0:  MOVLB  39
027B2:  BTFSS  xA7.5
027B4:  BRA    27B2
027B6:  MOVLB  3D
027B8:  MOVWF  xD2
027BA:  MOVLW  10
027BC:  MOVWF  3FE9
027BE:  MOVFF  222,266
027C2:  MOVFF  221,265
027C6:  MOVLB  0
027C8:  RCALL  2330
027CA:  MOVLW  20
027CC:  MOVLB  39
027CE:  BTFSS  xA7.5
027D0:  BRA    27CE
027D2:  MOVLB  3D
027D4:  MOVWF  xD2
....................             fprintf(UART,"/#");  //send string end
027D6:  MOVLW  2F
027D8:  MOVLB  39
027DA:  BTFSS  xA7.5
027DC:  BRA    27DA
027DE:  MOVLB  3D
027E0:  MOVWF  xD2
027E2:  MOVLW  23
027E4:  MOVLB  39
027E6:  BTFSS  xA7.5
027E8:  BRA    27E6
027EA:  MOVLB  3D
027EC:  MOVWF  xD2
....................             fprintf(DEBUG,"\n\r $%s", pntr);     //echo command to app
027EE:  MOVLW  E2
027F0:  MOVWF  3FF6
027F2:  MOVLW  02
027F4:  MOVWF  3FF7
027F6:  MOVLW  04
027F8:  MOVLB  2
027FA:  MOVWF  x65
027FC:  MOVLB  0
027FE:  CALL   09C2
02802:  MOVFFL 262,3FEA
02808:  MOVFFL 261,3FE9
0280E:  RCALL  207C
....................             fprintf(DEBUG,"/%u ", g_Contact);    //electrode contact state
02810:  MOVLW  2F
02812:  MOVLB  39
02814:  BTFSS  xA3.4
02816:  BRA    2814
02818:  MOVLB  3D
0281A:  MOVWF  xEA
0281C:  MOVFF  23F,265
02820:  MOVLW  1B
02822:  MOVLB  2
02824:  MOVWF  x66
02826:  MOVLB  0
02828:  CALL   1400
0282C:  MOVLW  20
0282E:  MOVLB  39
02830:  BTFSS  xA3.4
02832:  BRA    2830
02834:  MOVLB  3D
02836:  MOVWF  xEA
....................             fprintf(DEBUG,"/%lu ", g_Batt_Volts);   //battery level
02838:  MOVLW  2F
0283A:  MOVLB  39
0283C:  BTFSS  xA3.4
0283E:  BRA    283C
02840:  MOVLB  3D
02842:  MOVWF  xEA
02844:  MOVLW  10
02846:  MOVWF  3FE9
02848:  MOVFF  224,266
0284C:  MOVFF  223,265
02850:  MOVLB  0
02852:  CALL   0DDA
02856:  MOVLW  20
02858:  MOVLB  39
0285A:  BTFSS  xA3.4
0285C:  BRA    285A
0285E:  MOVLB  3D
02860:  MOVWF  xEA
....................             fprintf(DEBUG,"/%lu ", g_Seconds);    //time
02862:  MOVLW  2F
02864:  MOVLB  39
02866:  BTFSS  xA3.4
02868:  BRA    2866
0286A:  MOVLB  3D
0286C:  MOVWF  xEA
0286E:  MOVLW  10
02870:  MOVWF  3FE9
02872:  MOVFF  222,266
02876:  MOVFF  221,265
0287A:  MOVLB  0
0287C:  CALL   0DDA
02880:  MOVLW  20
02882:  MOVLB  39
02884:  BTFSS  xA3.4
02886:  BRA    2884
02888:  MOVLB  3D
0288A:  MOVWF  xEA
....................             fprintf(DEBUG,"/#");  //send string end
0288C:  MOVLW  2F
0288E:  MOVLB  39
02890:  BTFSS  xA3.4
02892:  BRA    2890
02894:  MOVLB  3D
02896:  MOVWF  xEA
02898:  MOVLW  23
0289A:  MOVLB  39
0289C:  BTFSS  xA3.4
0289E:  BRA    289C
028A0:  MOVLB  3D
028A2:  MOVWF  xEA
....................             g_State = WAIT;
028A4:  MOVLW  01
028A6:  MOVLB  2
028A8:  MOVWF  x1F
....................          // fprintf(DEBUG,"\n\r set= %f, %f ", g_Setpoint_mA, g_MaxSetPoint);
....................             break;
028AA:  MOVLB  3D
028AC:  BRA    2A76
.................... 
....................        case "data":   //set stimulation level and respond with data
....................             fprintf(UART,"\n\r ");      //echo to app
028AE:  MOVLW  EA
028B0:  MOVWF  3FF6
028B2:  MOVLW  02
028B4:  MOVWF  3FF7
028B6:  CALL   2016
....................             fprintf(UART,"\n\r $%s", pntr);     //echo command to app
028BA:  MOVLW  EE
028BC:  MOVWF  3FF6
028BE:  MOVLW  02
028C0:  MOVWF  3FF7
028C2:  MOVLW  04
028C4:  MOVLB  2
028C6:  MOVWF  x65
028C8:  MOVLB  0
028CA:  CALL   2046
028CE:  MOVFFL 262,3FEA
028D4:  MOVFFL 261,3FE9
028DA:  CALL   110C
....................             fprintf(UART,"/%u ", g_Contact);    //electrode contact
028DE:  MOVLW  2F
028E0:  MOVLB  39
028E2:  BTFSS  xA7.5
028E4:  BRA    28E2
028E6:  MOVLB  3D
028E8:  MOVWF  xD2
028EA:  MOVFF  23F,265
028EE:  MOVLW  1B
028F0:  MOVLB  2
028F2:  MOVWF  x66
028F4:  MOVLB  0
028F6:  RCALL  22A0
028F8:  MOVLW  20
028FA:  MOVLB  39
028FC:  BTFSS  xA7.5
028FE:  BRA    28FC
02900:  MOVLB  3D
02902:  MOVWF  xD2
....................             fprintf(UART,"/%lu ", g_Batt_Volts);    //battery level
02904:  MOVLW  2F
02906:  MOVLB  39
02908:  BTFSS  xA7.5
0290A:  BRA    2908
0290C:  MOVLB  3D
0290E:  MOVWF  xD2
02910:  MOVLW  10
02912:  MOVWF  3FE9
02914:  MOVFF  224,266
02918:  MOVFF  223,265
0291C:  MOVLB  0
0291E:  RCALL  2330
02920:  MOVLW  20
02922:  MOVLB  39
02924:  BTFSS  xA7.5
02926:  BRA    2924
02928:  MOVLB  3D
0292A:  MOVWF  xD2
....................             fprintf(UART,"/%lu ", g_Seconds);    //time
0292C:  MOVLW  2F
0292E:  MOVLB  39
02930:  BTFSS  xA7.5
02932:  BRA    2930
02934:  MOVLB  3D
02936:  MOVWF  xD2
02938:  MOVLW  10
0293A:  MOVWF  3FE9
0293C:  MOVFF  222,266
02940:  MOVFF  221,265
02944:  MOVLB  0
02946:  RCALL  2330
02948:  MOVLW  20
0294A:  MOVLB  39
0294C:  BTFSS  xA7.5
0294E:  BRA    294C
02950:  MOVLB  3D
02952:  MOVWF  xD2
....................             fprintf(UART,"/#");  //send string end
02954:  MOVLW  2F
02956:  MOVLB  39
02958:  BTFSS  xA7.5
0295A:  BRA    2958
0295C:  MOVLB  3D
0295E:  MOVWF  xD2
02960:  MOVLW  23
02962:  MOVLB  39
02964:  BTFSS  xA7.5
02966:  BRA    2964
02968:  MOVLB  3D
0296A:  MOVWF  xD2
....................             fprintf(DEBUG,"\n\r $%s", pntr);     //echo command to app
0296C:  MOVLW  F6
0296E:  MOVWF  3FF6
02970:  MOVLW  02
02972:  MOVWF  3FF7
02974:  MOVLW  04
02976:  MOVLB  2
02978:  MOVWF  x65
0297A:  MOVLB  0
0297C:  CALL   09C2
02980:  MOVFFL 262,3FEA
02986:  MOVFFL 261,3FE9
0298C:  CALL   207C
....................             fprintf(DEBUG,"/%u ", g_Contact);    //electrode contact state
02990:  MOVLW  2F
02992:  MOVLB  39
02994:  BTFSS  xA3.4
02996:  BRA    2994
02998:  MOVLB  3D
0299A:  MOVWF  xEA
0299C:  MOVFF  23F,265
029A0:  MOVLW  1B
029A2:  MOVLB  2
029A4:  MOVWF  x66
029A6:  MOVLB  0
029A8:  CALL   1400
029AC:  MOVLW  20
029AE:  MOVLB  39
029B0:  BTFSS  xA3.4
029B2:  BRA    29B0
029B4:  MOVLB  3D
029B6:  MOVWF  xEA
....................             fprintf(DEBUG,"/%lu ", g_Batt_Volts);   //battery level
029B8:  MOVLW  2F
029BA:  MOVLB  39
029BC:  BTFSS  xA3.4
029BE:  BRA    29BC
029C0:  MOVLB  3D
029C2:  MOVWF  xEA
029C4:  MOVLW  10
029C6:  MOVWF  3FE9
029C8:  MOVFF  224,266
029CC:  MOVFF  223,265
029D0:  MOVLB  0
029D2:  CALL   0DDA
029D6:  MOVLW  20
029D8:  MOVLB  39
029DA:  BTFSS  xA3.4
029DC:  BRA    29DA
029DE:  MOVLB  3D
029E0:  MOVWF  xEA
....................             fprintf(DEBUG,"/%lu ", g_Seconds);    //time
029E2:  MOVLW  2F
029E4:  MOVLB  39
029E6:  BTFSS  xA3.4
029E8:  BRA    29E6
029EA:  MOVLB  3D
029EC:  MOVWF  xEA
029EE:  MOVLW  10
029F0:  MOVWF  3FE9
029F2:  MOVFF  222,266
029F6:  MOVFF  221,265
029FA:  MOVLB  0
029FC:  CALL   0DDA
02A00:  MOVLW  20
02A02:  MOVLB  39
02A04:  BTFSS  xA3.4
02A06:  BRA    2A04
02A08:  MOVLB  3D
02A0A:  MOVWF  xEA
....................             fprintf(DEBUG,"/#");  //send string end
02A0C:  MOVLW  2F
02A0E:  MOVLB  39
02A10:  BTFSS  xA3.4
02A12:  BRA    2A10
02A14:  MOVLB  3D
02A16:  MOVWF  xEA
02A18:  MOVLW  23
02A1A:  MOVLB  39
02A1C:  BTFSS  xA3.4
02A1E:  BRA    2A1C
02A20:  MOVLB  3D
02A22:  MOVWF  xEA
....................             g_State = TREAT;
02A24:  MOVLW  02
02A26:  MOVLB  2
02A28:  MOVWF  x1F
....................          //  fprintf(DEBUG,"\n\r set= %f, %f ", g_Setpoint_mA, g_MaxSetPoint);
....................             break;
02A2A:  MOVLB  3D
02A2C:  BRA    2A76
....................             
....................         case "sleep": //this command will sound 5 peeps onthe haptic then power down
....................             enable_interrupts(INT_TIMER1);
02A2E:  MOVLB  39
02A30:  BSF    x94.0
....................             for(n=0; n<=5; n++)  {  //beep 5 times
02A32:  MOVLB  2
02A34:  CLRF   x63
02A36:  MOVF   x63,W
02A38:  SUBLW  05
02A3A:  BNC   2A68
....................                 output_high(HAPTIC);
02A3C:  BCF    3FC3.1
02A3E:  BSF    3FBB.1
....................                 delay_ms(200);
02A40:  MOVLW  C8
02A42:  MOVWF  x91
02A44:  MOVLB  0
02A46:  CALL   0354
....................                 output_low(HAPTIC);
02A4A:  BCF    3FC3.1
02A4C:  BCF    3FBB.1
....................                 delay_ms(500); 
02A4E:  MOVLW  02
02A50:  MOVLB  2
02A52:  MOVWF  x65
02A54:  MOVLW  FA
02A56:  MOVWF  x91
02A58:  MOVLB  0
02A5A:  CALL   0354
02A5E:  MOVLB  2
02A60:  DECFSZ x65,F
02A62:  BRA    2A54
02A64:  INCF   x63,F
02A66:  BRA    2A36
....................             }
....................             Go_To_Sleep();
02A68:  MOVLB  0
02A6A:  CALL   1308
....................             break;
02A6E:  MOVLB  3D
02A70:  BRA    2A76
02A72:  MOVLB  0
....................             
....................         default:
....................             break;
02A74:  MOVLB  3D
....................     }
02A76:  MOVLB  0
02A78:  GOTO   2C56 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... // Look for charger being unplugged
.................... void Check_Charger(void)
.................... {
....................     static uint8_t Charger_State;
....................     static uint8_t Last_State = 0;
....................     
....................     Charger_State = input(CHRGR_ON);    //update state
*
01D92:  BSF    3FC3.2
01D94:  MOVLB  2
01D96:  CLRF   x58
01D98:  BTFSC  3FCB.2
01D9A:  INCF   x58,F
....................  
....................     if( (Last_State) && (!Charger_State))   //if charging has stopped
01D9C:  MOVF   x59,F
01D9E:  BZ    1DC6
01DA0:  MOVF   x58,F
01DA2:  BNZ   1DC6
....................     {
....................        fprintf(DEBUG,"\n\r Sleep");
01DA4:  MOVLW  16
01DA6:  MOVWF  3FF6
01DA8:  MOVLW  03
01DAA:  MOVWF  3FF7
01DAC:  MOVLB  0
01DAE:  CALL   095C
....................        delay_ms(50);
01DB2:  MOVLW  32
01DB4:  MOVLB  2
01DB6:  MOVWF  x91
01DB8:  MOVLB  0
01DBA:  CALL   0354
....................        output_low(ENB_VCC); //disable CPU power     //go to sleep
01DBE:  BCF    3FC4.0
01DC0:  BCF    3FBC.0
....................        while(1) {}  // hang forever
01DC2:  BRA    1DC2
01DC4:  MOVLB  2
....................  
....................     }
....................     Last_State = Charger_State;
01DC6:  MOVFF  258,259
01DCA:  MOVLB  0
01DCC:  GOTO   2C40 (RETURN)
.................... }
.................... 
.................... 
.................... void    Check_Button(void)
.................... {
....................     uint8_t ButtonLevel;
....................     static uint8_t  LastButton = 1;
....................     
....................     ButtonLevel = input(BUTTON);    //active low when pressed
*
01D60:  BSF    3FC3.0
01D62:  MOVLB  2
01D64:  CLRF   x5B
01D66:  BTFSC  3FCB.0
01D68:  INCF   x5B,F
.................... 
....................     if( (ButtonLevel) && (!LastButton) )    //if button released
01D6A:  MOVF   x5B,F
01D6C:  BZ    1D88
01D6E:  MOVF   x5A,F
01D70:  BNZ   1D88
....................     {
....................         fprintf(DEBUG,"\n\r Sleep");
01D72:  MOVLW  20
01D74:  MOVWF  3FF6
01D76:  MOVLW  03
01D78:  MOVWF  3FF7
01D7A:  MOVLB  0
01D7C:  CALL   095C
....................         output_low(ENB_VCC); //disable CPU power
01D80:  BCF    3FC4.0
01D82:  BCF    3FBC.0
....................         while(1) {}  // hang forever
01D84:  BRA    1D84
01D86:  MOVLB  2
....................         
....................     }
....................     LastButton = ButtonLevel;   //refresh button status
01D88:  MOVFF  25B,25A
01D8C:  MOVLB  0
01D8E:  GOTO   2C3C (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /**
....................     Clear serial port error flags
.................... **/
.................... void    ClearPorts(void)
.................... {
....................     if(bit_test(RCSTA1,OERR))   //if error bit set
*
00FF4:  MOVLB  F
00FF6:  BTFSS  xAB.1
00FF8:  BRA    100C
....................     {
....................         bit_clear(RCSTA1,SPEN);     //toggle these bits
00FFA:  BCF    xAB.7
....................         bit_clear(RCSTA1,CREN);
00FFC:  BCF    xAB.4
....................         delay_us(10);
00FFE:  MOVLW  1A
01000:  MOVWF  00
01002:  DECFSZ 00,F
01004:  BRA    1002
01006:  NOP   
....................         bit_set(RCSTA1,SPEN);
01008:  BSF    xAB.7
....................         bit_set(RCSTA1,CREN);
0100A:  BSF    xAB.4
....................     }
....................     
....................       if(bit_test(RCSTA2,OERR))   //if error bit set
0100C:  BTFSS  x71.1
0100E:  BRA    1022
....................     {
....................         bit_clear(RCSTA2,SPEN);     //toggle these bits
01010:  BCF    x71.7
....................         bit_clear(RCSTA2,CREN);
01012:  BCF    x71.4
....................         delay_us(10);
01014:  MOVLW  1A
01016:  MOVWF  00
01018:  DECFSZ 00,F
0101A:  BRA    1018
0101C:  NOP   
....................         bit_set(RCSTA2,SPEN);
0101E:  BSF    x71.7
....................         bit_set(RCSTA2,CREN);
01020:  BSF    x71.4
....................     }
01022:  MOVLB  0
01024:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /**
.................... void main(void)
.................... 
.................... **/
.................... void main(void)
*
02A7C:  MOVLB  39
02A7E:  BSF    xE5.7
02A80:  BCF    xE5.6
02A82:  CLRF   3FF8
02A84:  BCF    3FD2.5
02A86:  BSF    07.7
02A88:  MOVLB  E
02A8A:  MOVLW  55
02A8C:  MOVLB  3A
02A8E:  MOVWF  xBF
02A90:  MOVLW  AA
02A92:  MOVWF  xBF
02A94:  BCF    xBF.0
02A96:  MOVLW  17
02A98:  MOVWF  xE7
02A9A:  MOVLW  0B
02A9C:  MOVWF  xEA
02A9E:  MOVLW  16
02AA0:  MOVWF  x0C
02AA2:  MOVLW  0A
02AA4:  MOVWF  x11
02AA6:  MOVLW  09
02AA8:  MOVWF  x12
02AAA:  MOVLW  13
02AAC:  MOVWF  x16
02AAE:  MOVLW  55
02AB0:  MOVWF  xBF
02AB2:  MOVLW  AA
02AB4:  MOVWF  xBF
02AB6:  BSF    xBF.0
02AB8:  MOVLB  39
02ABA:  CLRF   xDE
02ABC:  CLRF   xDB
02ABE:  CLRF   xDD
02AC0:  MOVLW  06
02AC2:  MOVWF  xDF
02AC4:  MOVLW  60
02AC6:  MOVWF  xD9
02AC8:  MOVLB  3D
02ACA:  BCF    xF3.7
02ACC:  BCF    3FC4.6
02ACE:  BSF    3FBC.6
02AD0:  MOVLW  B0
02AD2:  MOVWF  xF2
02AD4:  CLRF   xF6
02AD6:  MOVLW  44
02AD8:  MOVWF  xF5
02ADA:  CLRF   xF4
02ADC:  BSF    xF3.7
02ADE:  BCF    xDB.7
02AE0:  BCF    3FC3.4
02AE2:  BSF    3FBB.4
02AE4:  MOVLW  B0
02AE6:  MOVWF  xDA
02AE8:  CLRF   xDE
02AEA:  MOVLW  44
02AEC:  MOVWF  xDD
02AEE:  CLRF   xDC
02AF0:  BSF    xDB.7
02AF2:  MOVLB  2
02AF4:  CLRF   x3F
02AF6:  CLRF   x46
02AF8:  CLRF   x45
02AFA:  MOVLB  3A
02AFC:  CLRF   x40
02AFE:  CLRF   x50
02B00:  CLRF   x60
02B02:  CLRF   x80
02B04:  MOVLB  3E
02B06:  CLRF   xBD
02B08:  CLRF   xBE
02B0A:  CLRF   xBF
02B0C:  CLRF   xBC
02B0E:  CLRF   xB9
02B10:  CLRF   xBA
02B12:  CLRF   xBB
02B14:  CLRF   xB8
02B16:  CLRF   19
02B18:  CLRF   1A
02B1A:  MOVLB  2
02B1C:  CLRF   x44
02B1E:  MOVLW  01
02B20:  MOVWF  x47
02B22:  CLRF   x48
02B24:  CLRF   x49
02B26:  CLRF   x4A
02B28:  CLRF   x4B
02B2A:  CLRF   x4C
02B2C:  CLRF   x4D
02B2E:  CLRF   x4E
02B30:  CLRF   x4F
02B32:  CLRF   x50
02B34:  CLRF   x51
02B36:  CLRF   x52
02B38:  CLRF   x53
02B3A:  CLRF   x54
02B3C:  CLRF   x55
02B3E:  CLRF   x56
02B40:  CLRF   x57
02B42:  CLRF   x58
02B44:  CLRF   x59
02B46:  MOVWF  x5A
.................... {
....................     output_high(ENB_VCC);
02B48:  BCF    3FC4.0
02B4A:  BSF    3FBC.0
....................     delay_ms(1000); //allow user to get finger off button
02B4C:  MOVLW  04
02B4E:  MOVWF  x5B
02B50:  MOVLW  FA
02B52:  MOVWF  x91
02B54:  MOVLB  0
02B56:  CALL   0354
02B5A:  MOVLB  2
02B5C:  DECFSZ x5B,F
02B5E:  BRA    2B50
....................     
....................     setup_adc_ports(sAN0 | sAN1 | sAN2 | sAN3 | sAN5 | VSS_VDD);
02B60:  MOVLW  00
02B62:  MOVLB  3E
02B64:  MOVWF  xFD
02B66:  MOVLW  2F
02B68:  MOVLB  3A
02B6A:  MOVWF  x40
02B6C:  MOVLW  00
02B6E:  MOVWF  x50
02B70:  MOVWF  x60
02B72:  MOVWF  x80
....................     setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_0);
02B74:  MOVLW  08
02B76:  MOVLB  3E
02B78:  MOVWF  xFA
02B7A:  CLRF   xFB
02B7C:  CLRF   xFF
02B7E:  CLRF   xF4
02B80:  CLRF   xF3
02B82:  CLRF   xEC
02B84:  MOVLW  94
02B86:  MOVWF  xF8
....................     
....................     setup_timer_1(T1_INTERNAL|T1_DIV_BY_4);        //32.7 ms overflow
02B88:  MOVLW  01
02B8A:  MOVWF  3FB5
02B8C:  MOVLW  27
02B8E:  MOVWF  3FB2
02B90:  CLRF   3FB3
02B92:  CLRF   3FB4
....................     setup_timer_2(T2_DIV_BY_1 | T2_CLK_INTERNAL,63,1);    //8.0 us overflow, 8.0 us interrupt, 
02B94:  CLRF   3FAF
02B96:  CLRF   3FAD
02B98:  MOVLW  01
02B9A:  MOVWF  3FAE
02B9C:  MOVLW  3F
02B9E:  MOVWF  3FAB
02BA0:  MOVLW  80
02BA2:  MOVWF  3FAC
....................   
....................     setup_ccp1(CCP_PWM);        //DAC_PWM, 125KHz, 256 max
02BA4:  BCF    3FC4.2
02BA6:  BCF    3FBC.2
02BA8:  BCF    3F7E.7
02BAA:  MOVLW  0C
02BAC:  MOVWF  3F7E
02BAE:  MOVLW  FC
02BB0:  MOVLB  3F
02BB2:  ANDWF  x5E,F
02BB4:  MOVLW  01
02BB6:  IORWF  x5E,F
02BB8:  BSF    3F7E.7
....................     setup_ccp2(CCP_PWM);        //BATTERY_PWM, 125KHz, 256 max
02BBA:  BCF    3FC4.1
02BBC:  BCF    3FBC.1
02BBE:  BCF    3F7A.7
02BC0:  MOVLW  0C
02BC2:  MOVWF  3F7A
02BC4:  MOVLW  F3
02BC6:  ANDWF  x5E,F
02BC8:  MOVLW  04
02BCA:  IORWF  x5E,F
02BCC:  BSF    3F7A.7
....................     set_pwm1_duty((int16)0);    //increase PWM to increase stimulation
02BCE:  CLRF   3F7D
02BD0:  CLRF   3F7C
....................     set_pwm2_duty((int16)0);   //increse PWM to increase charge voltage
02BD2:  CLRF   3F79
02BD4:  CLRF   3F78
.................... 
....................     port_b_pullups(128);
02BD6:  MOVLW  80
02BD8:  MOVLB  3A
02BDA:  MOVWF  x51
....................     Init_Globals();
02BDC:  MOVLB  0
02BDE:  GOTO   037C
....................     PID(CLEAR);
02BE2:  MOVLB  2
02BE4:  CLRF   x61
02BE6:  MOVLB  0
02BE8:  CALL   07CC
....................     Init_IO();
02BEC:  GOTO   0928
....................     Self_Test();
02BF0:  GOTO   0E98
....................     fprintf(DEBUG,"\n\r Initializing Main Controller Ver 3.0.5");
02BF4:  MOVLW  2A
02BF6:  MOVWF  3FF6
02BF8:  MOVLW  03
02BFA:  MOVWF  3FF7
02BFC:  CALL   095C
....................     
....................  
....................    clear_interrupt(INT_RDA2);
02C00:  MOVLB  3D
02C02:  MOVF   xD0,W
....................     enable_interrupts(INT_RDA2);  
02C04:  MOVLB  39
02C06:  BSF    x97.4
....................    enable_interrupts(INT_TIMER1);
02C08:  BSF    x94.0
....................    enable_interrupts(GLOBAL);
02C0A:  MOVLW  C0
02C0C:  IORWF  3FD2,F
....................    
....................  //  if(!input(PGD)) { //if programmer is attached
....................         ClearPorts();   //check for Bluetooth UART serial port error
02C0E:  MOVLB  0
02C10:  CALL   0FF4
....................         CMD_Mode(); //place BT device into command mode
02C14:  GOTO   1034
....................         Configure_BT(); //and configure it
02C18:  GOTO   119A
....................   //  }
....................     enable_interrupts(INT_TIMER1);
02C1C:  MOVLB  39
02C1E:  BSF    x94.0
....................   
....................     while(TRUE)
....................     {
.................... 
....................         If(bit_test(g_Flags,TMR1_FLG))  //do things on interrupt
02C20:  MOVLB  2
02C22:  BTFSS  x20.0
02C24:  BRA    2C42
....................         {
....................             bit_clear(g_Flags,TMR1_FLG);    //clear 1 msec interrupt flag
02C26:  BCF    x20.0
....................             Clocks();   //update clocks
02C28:  MOVLB  0
02C2A:  GOTO   1844
....................             State_Machine();    //state machine
02C2E:  GOTO   1CFE
....................             
....................             if(!input(CHRGR_ON))    //charger not attached
02C32:  BSF    3FC3.2
02C34:  BTFSC  3FCB.2
02C36:  BRA    2C3C
....................                 Check_Button(); //look for power button closure
02C38:  GOTO   1D60
....................          
....................             Check_Charger();   //check charger
02C3C:  GOTO   1D92
02C40:  MOVLB  2
....................         }
.................... 
.................... 
....................         //perform the following tasks as quickly as possible
....................          ClearPorts();   //check for Bluetooth UART serial port error
02C42:  MOVLB  0
02C44:  CALL   0FF4
....................                  
....................         // Check for packet from GUI 
....................         if (g_UART.flags == COMM_FND_CMD)   // Check for the communications buffer
02C48:  MOVLB  2
02C4A:  MOVF   x1E,W
02C4C:  SUBLW  80
02C4E:  BNZ   2C5A
....................         {  
....................           // disable_interrupts(INT_TIMER1); //then enable 10msec interrupt
....................            Process_Command();    // Process command
02C50:  MOVLB  0
02C52:  GOTO   23EE
....................          //  enable_interrupts(INT_TIMER1); //then enable 10msec interrupt  
....................             g_UART.flags &= ~COMM_FND_CMD;          // Reset command found flag
02C56:  MOVLB  2
02C58:  BCF    x1E.7
....................         }  // End check comm buffer  
02C5A:  BRA    2C22
....................     }
.................... }
.................... 
02C5C:  SLEEP 
.................... 

Configuration Fuses:
   Word  1: FFEC   NOEXTOSC RSTOSC_HFINTRC_1MHZ NOCLKOUT PRLOCK1WAY CKS FCMEN
   Word  2: FF37   MCLR NOPUT NOMVECEN IVT1WAY NOLPBOR NOBROWNOUT BORV24 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   BBSIZ512 NOBOOTBLOCK NOSAF NOWRT NOWRTB NOWRTC NOWRTD NOWRTSAF NOLVP
   Word  5: FFFF   NOPROTECT
